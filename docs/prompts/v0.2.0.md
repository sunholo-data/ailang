---
layout: page
title: AI Prompt - v0.2.0
parent: AI Prompts
nav_order: 1
---

# AILANG AI Teaching Prompt (v0.2.0-rc1)

**CRITICAL: You MUST write code in AILANG syntax. This is NOT Python, NOT Rust, NOT JavaScript.**

You are writing code in AILANG, a pure functional programming language with Hindley-Milner type inference and algebraic effects.

**IMPORTANT SYNTAX RULES:**
- Use `func` NOT `fn`, `function`, or `def`
- Use `type Name[a] = Constructor(a) | Constructor2` NOT `type Name { }` or `enum`
- NO namespace syntax (`::`), just use constructor names directly
- NO semicolons at end of statements in blocks (only between let bindings)
- Pattern matching uses `=>` NOT `:` or `->`
- NO `for`, `while`, `var`, `const`, `let mut`, or any imperative constructs

## Current Version: v0.2.0-rc1 (Module Execution + Effects)

**✅ WHAT WORKS:**
- ✅ **Module declarations** - `module path/to/module`
- ✅ **Function declarations** - `export func name(params) -> Type { body }`
- ✅ **Import statements** - `import std/io (println)`
- ✅ **Pattern matching** - Constructors, tuples, lists, wildcards
- ✅ **Effect system** - `! {IO, FS}` for side effects
- ✅ **ADTs** - Algebraic data types: `type Option[a] = Some(a) | None`

**⚠️ LIMITATIONS:**
- ⚠️ NO `for`/`while` loops - use recursion
- ⚠️ NO `var` - everything is immutable
- ⚠️ NO pattern guards in match (yet)
- ⚠️ Let expressions limited to 3 nesting levels

## Module Structure

Every AILANG program must be a module with exported functions:

```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello, World!")
}
```

**IMPORTANT**: Always use `module benchmark/solution` as the module name for benchmark programs.

## Functions

```ailang
-- Simple pure function
export func add(x: int, y: int) -> int {
  x + y
}

-- Function with effects (IO, FS)
export func greet(name: string) -> () ! {IO} {
  println("Hello, " ++ name)
}

-- Generic function
export func identity[a](x: a) -> a {
  x
}

-- Multi-statement body (use semicolons)
export func compute() -> int {
  let x = 10;
  let y = 20;
  x + y
}
```

## Algebraic Data Types (ADTs)

**✅ CORRECT AILANG SYNTAX:**
```ailang
type Option[a] = Some(a) | None
type Result[a, e] = Ok(a) | Err(e)
type List[a] = Cons(a, List[a]) | Nil

export func getOrElse[a](opt: Option[a], default: a) -> a {
  match opt {
    Some(x) => x,
    None => default
  }
}
```

**❌ WRONG - This is Rust/other languages, NOT AILANG:**
```rust
type Option {        // ❌ Wrong - no { } braces
  Some(value)        // ❌ Wrong - not AILANG syntax
  None
}

Option::Some(42)     // ❌ Wrong - AILANG has no :: operator
fn divide(a, b) { }  // ❌ Wrong - use 'func' not 'fn'
```

**✅ CORRECT - Use constructors directly:**
```ailang
Some(42)             // ✅ Correct - no namespace needed
None                 // ✅ Correct
```

## Available Imports

**std/io** - IO operations (requires `! {IO}` effect)
```ailang
import std/io (println, print, readLine)

export func main() -> () ! {IO} {
  println("text")
}
```

**std/fs** - File operations (requires `! {FS}` effect)
```ailang
import std/fs (readFile, writeFile, exists)

export func readData() -> string ! {FS} {
  readFile("data.txt")
}
```

**std/option** - Option type
```ailang
import std/option (Option, Some, None)
```

## Recursion (instead of loops)

```ailang
export func factorial(n: int) -> int {
  if n <= 1
  then 1
  else n * factorial(n - 1)
}

export func sum(xs: [int]) -> int {
  match xs {
    [] => 0,
    _ => head(xs) + sum(tail(xs))
  }
}
```

## Common Mistakes to Avoid

❌ **Don't use for/while loops:**
```ailang
for i in [1, 2, 3] { println(i) }  -- ❌ NOT supported
```

✅ **Use recursion or pattern matching:**
```ailang
export func printAll(xs: [int]) -> () ! {IO} {
  match xs {
    [] => (),
    _ => {
      println(show(head(xs)));
      printAll(tail(xs))
    }
  }
}
```

❌ **Don't use mutable variables:**
```ailang
var x = 5
x = x + 1  -- ❌ NOT supported
```

✅ **Use let bindings:**
```ailang
let x = 5;
let y = x + 1;
y
```

❌ **Don't forget module and export:**
```ailang
func main() {  -- ❌ Missing 'module' declaration and 'export'
  println("hello")
}
```

✅ **Always use module and export:**
```ailang
module examples/hello
import std/io (println)

export func main() -> () ! {IO} {
  println("hello")
}
```

## Complete Working Examples

### Example 1: Safe Division with Option
```ailang
module benchmark/solution

import std/io (println)

type Option[a] = Some(a) | None

export func safeDivide(a: float, b: float) -> Option[float] {
  if b == 0.0
  then None
  else Some(a / b)
}

export func printResult(result: Option[float]) -> () ! {IO} {
  match result {
    Some(v) => println("Result: " ++ show(v)),
    None => println("Error: Division by zero")
  }
}

export func main() -> () ! {IO} {
  let r1 = safeDivide(10.0, 2.0);
  printResult(r1);
  let r2 = safeDivide(10.0, 0.0);
  printResult(r2)
}
```

### Example 2: Recursive Loop (FizzBuzz pattern)
```ailang
module benchmark/solution

import std/io (println)

export func loop(start: int, end: int, action: int -> () ! {IO}) -> () ! {IO} {
  if start > end
  then ()
  else {
    action(start);
    loop(start + 1, end, action)
  }
}

export func main() -> () ! {IO} {
  loop(1, 10, \i. println(show(i)))
}
```

### Example 3: List Processing (NO for loops!)
```ailang
module benchmark/solution

import std/io (println)

export func printEach(xs: [int]) -> () ! {IO} {
  match xs {
    [] => (),
    _ => {
      println(show(head(xs)));
      printEach(tail(xs))
    }
  }
}

export func main() -> () ! {IO} {
  printEach([1, 2, 3, 4, 5])
}
```

## Summary

**Structure:**
1. Start with `module benchmark/solution` (REQUIRED for benchmarks!)
2. Import what you need from stdlib (`import std/io (println)`)
3. Define exported functions with `export func name(params) -> ReturnType { }`
4. Declare effects with `! {IO, FS}` when using IO/FS operations
5. Use recursion instead of loops - AILANG has NO for/while loops!

**Remember:**
- ✅ Use `func` NOT `fn`, `function`, or `def`
- ✅ ADTs use `type Name[a] = Cons1(a) | Cons2` syntax
- ✅ NO `::` operator - use constructors directly
- ✅ NO for/while loops - use recursion
- ✅ Everything is immutable (no `var` or mutation)
- ✅ Pattern matching uses `=>` arrows
- ✅ Functions need type signatures
- ✅ Effects must be declared with `! {IO}` or `! {FS}` or `! {IO, FS}`
- ✅ Program runs via: `ailang run file.ail --entry main --caps IO`

**If you're not sure, look at the examples above!** They show the exact AILANG syntax.
