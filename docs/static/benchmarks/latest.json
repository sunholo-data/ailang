{
  "version": "v0.3.9",
  "timestamp": "2025-10-16T13:16:59+02:00",
  "totalRuns": 126,
  "aggregates": {
    "avgDurationMs": 30.91269841269841,
    "finalSuccess": 0.5873015873015873,
    "repairSuccessRate": 0,
    "repairUsed": 0,
    "totalCostUSD": 0.20499710000000004,
    "totalTokens": 271774,
    "zeroShotSuccess": 0.5873015873015873
  },
  "models": {
    "claude-haiku-4-5": {
      "aggregates": {
        "avgDurationMs": 26.5,
        "finalSuccess": 0.5238095238095238,
        "repairSuccessRate": 0,
        "repairUsed": 0,
        "totalCostUSD": 0.133415,
        "totalTokens": 99219,
        "zeroShotSuccess": 0.5238095238095238
      },
      "benchmarks": {
        "adt_option": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 6344
        },
        "api_call_json": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 256
        },
        "cli_args": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 630
        },
        "error_handling": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 6752
        },
        "fizzbuzz": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 6294
        },
        "float_eq": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 73
        },
        "higher_order_functions": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 6440
        },
        "json_encode": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 301
        },
        "json_parse": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 192
        },
        "list_comprehension": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 519
        },
        "list_operations": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 6363
        },
        "nested_records": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 6341
        },
        "numeric_modulo": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 474
        },
        "pattern_matching_complex": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 639
        },
        "pipeline": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 205
        },
        "record_update": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 362
        },
        "records_person": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 284
        },
        "recursion_factorial": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 6161
        },
        "recursion_fibonacci": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 6223
        },
        "simple_print": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 125
        },
        "string_manipulation": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 6295
        },
        "targeted_repair_test": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 6305
        }
      },
      "languages": {
        "ailang": {
          "avgTokens": 204.0952380952381,
          "successRate": 0.42857142857142855,
          "totalRuns": 21
        },
        "python": {
          "avgTokens": 203,
          "successRate": 0.6190476190476191,
          "totalRuns": 21
        }
      },
      "totalRuns": 42
    },
    "gemini-2-5-flash": {
      "aggregates": {
        "avgDurationMs": 25.547619047619047,
        "finalSuccess": 0.5476190476190477,
        "repairSuccessRate": 0,
        "repairUsed": 0,
        "totalCostUSD": 0.040410600000000005,
        "totalTokens": 89470,
        "zeroShotSuccess": 0.5476190476190477
      },
      "benchmarks": {
        "adt_option": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5839
        },
        "api_call_json": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 243
        },
        "cli_args": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 151
        },
        "error_handling": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 6558
        },
        "fizzbuzz": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5763
        },
        "float_eq": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 52
        },
        "higher_order_functions": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 5931
        },
        "json_encode": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 254
        },
        "json_parse": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 175
        },
        "list_comprehension": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 6143
        },
        "list_operations": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 5887
        },
        "nested_records": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5800
        },
        "numeric_modulo": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 42
        },
        "pattern_matching_complex": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 578
        },
        "pipeline": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 164
        },
        "record_update": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5812
        },
        "records_person": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5745
        },
        "recursion_factorial": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5653
        },
        "recursion_fibonacci": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5717
        },
        "simple_print": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 109
        },
        "string_manipulation": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 269
        },
        "targeted_repair_test": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 5785
        }
      },
      "languages": {
        "ailang": {
          "avgTokens": 168.28571428571428,
          "successRate": 0.42857142857142855,
          "totalRuns": 21
        },
        "python": {
          "avgTokens": 125.42857142857143,
          "successRate": 0.6666666666666666,
          "totalRuns": 21
        }
      },
      "totalRuns": 42
    },
    "gpt5-mini": {
      "aggregates": {
        "avgDurationMs": 40.69047619047619,
        "finalSuccess": 0.6904761904761905,
        "repairSuccessRate": 0,
        "repairUsed": 0,
        "totalCostUSD": 0.031171499999999998,
        "totalTokens": 83085,
        "zeroShotSuccess": 0.6904761904761905
      },
      "benchmarks": {
        "adt_option": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 346
        },
        "api_call_json": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 227
        },
        "cli_args": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 253
        },
        "error_handling": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5615
        },
        "fizzbuzz": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 209
        },
        "float_eq": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 76
        },
        "higher_order_functions": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 5462
        },
        "json_encode": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 446
        },
        "json_parse": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 166
        },
        "list_comprehension": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 347
        },
        "list_operations": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 304
        },
        "nested_records": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 330
        },
        "numeric_modulo": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 59
        },
        "pattern_matching_complex": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5705
        },
        "pipeline": {
          "firstAttemptOk": false,
          "repairUsed": false,
          "success": false,
          "tokens": 144
        },
        "record_update": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5362
        },
        "records_person": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5310
        },
        "recursion_factorial": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5222
        },
        "recursion_fibonacci": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5280
        },
        "simple_print": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 117
        },
        "string_manipulation": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5334
        },
        "targeted_repair_test": {
          "firstAttemptOk": true,
          "repairUsed": false,
          "success": true,
          "tokens": 5350
        }
      },
      "languages": {
        "ailang": {
          "avgTokens": 147.9047619047619,
          "successRate": 0.5238095238095238,
          "totalRuns": 21
        },
        "python": {
          "avgTokens": 135.0952380952381,
          "successRate": 0.8571428571428571,
          "totalRuns": 21
        }
      },
      "totalRuns": 42
    }
  },
  "benchmarks": {
    "adt_option": {
      "avgTokens": 269.1666666666667,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\ntype Option[a] = Some(a) | None\n\nexport func safeDivide(a: float, b: float) -\u003e Option[float] {\n  if b == 0.0\n  then None\n  else Some(a / b)\n}\n\nexport func printResult(r: Option[float]) -\u003e () ! {IO} {\n  match r {\n    Some(v) =\u003e println(\"Result: \" ++ show(v)),\n    None =\u003e println(\"Error: Division by zero\")\n  }\n}\n\nexport func main() -\u003e () ! {IO} {\n  let r1 = safeDivide(10.0, 2.0);\n  printResult(r1);\n  let r2 = safeDivide(10.0, 0.0);\n  printResult(r2)\n}",
        "python": "import math\nfrom typing import Optional, Union\n\ndef safe_divide(numerator: Union[int, float], denominator: Union[int, float]) -\u003e Optional[float]:\n    if denominator == 0:\n        return None\n    return float(numerator) / denominator\n\n# Test cases\nresult1 = safe_divide(10, 2)\nresult2 = safe_divide(10, 0)\n\n# Print results for the first test case\nif result1 is not None:\n    print(f\"Result: {result1}\")\nelse:\n    print(\"Error: Division by zero\")\n\n# Print results for the second test case\nif result2 is not None:\n    print(f\"Result: {result2}\")\nelse:\n    print(\"Error: Division by zero\")"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 193,
          "successRate": 1,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 345.3333333333333,
          "successRate": 0.6666666666666666,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.8333333333333334,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Defines an Option type (Some/None, or equivalent)\n2. Implements a safe division function that returns Option[Float]\n   - Returns Some(result) if divisor is non-zero\n   - Returns None if divisor is zero\n3. Tests the function with: divide(10, 2) and divide(10, 0)\n4. Prints the results:\n   - For Some(value): print \"Result: {value}\"\n   - For None: print \"Error: Division by zero\"\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "api_call_json": {
      "avgTokens": 105.83333333333333,
      "codeSamples": {
        "ailang": "import http.client\nimport json\n\nconn = http.client.HTTPSConnection(\"httpbin.org\")\n\nbody = json.dumps({\"message\": \"Hello from AILANG\", \"count\": 42})\n\nheaders = {\n    \"X-Test-Header\": \"value123\",\n    \"Content-Type\": \"application/json\"\n}\n\nconn.request(\"POST\", \"/post\", body, headers)\n\nresponse = conn.getresponse()\nprint(response.status)\n\nconn.close()",
        "python": "import urllib.request\nimport json\n\nurl = \"https://httpbin.org/post\"\npayload = {\"message\": \"Hello from Python 3\", \"count\": 42}\ndata = json.dumps(payload).encode(\"utf-8\")\nheaders = {\"X-Test-Header\": \"value123\", \"Content-Type\": \"application/json\"}\n\nreq = urllib.request.Request(url, data=data, headers=headers, method=\"POST\")\nwith urllib.request.urlopen(req) as resp:\n    print(resp.getcode())"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 106.66666666666667,
          "successRate": 0,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 105,
          "successRate": 0.3333333333333333,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.16666666666666666,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Makes an HTTP POST request to https://httpbin.org/post\n2. Includes custom headers: \"X-Test-Header: value123\" and \"Content-Type: application/json\"\n3. Sends a JSON body: {\"message\":\"Hello from \u003cLANG\u003e\",\"count\":42}\n4. Prints ONLY the response status code (e.g., \"200\" or \"201\")\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "cli_args": {
      "avgTokens": 234.33333333333334,
      "codeSamples": {
        "ailang": "SET FILENAME ARGS[1]\nSET SUM 0\nSET FH OPEN FILENAME \"r\"\nWHILE TRUE DO\n    SET LINE READLINE FH\n    IF EQ LINE NULL THEN\n        BREAK\n    END\n    SET NUM_VAL NUM LINE\n    SET SUM ADD SUM NUM_VAL\nEND\nCLOSE FH\nPRINT SUM",
        "python": "import sys\n\nif len(sys.argv) != 2:\n    print(\"Usage: python script.py \u003cfilename\u003e\")\n    sys.exit(1)\n\nfilename = sys.argv[1]\ntotal_sum = 0.0\n\ntry:\n    with open(filename, 'r') as f:\n        for line in f:\n            try:\n                num = float(line.strip())\n                total_sum += num\n            except ValueError:\n                # Optionally, handle non-numeric lines.\n                # For this problem, we assume all lines are valid numbers.\n                pass\n    print(total_sum)\nexcept FileNotFoundError:\n    print(f\"Error: File '{filename}' not found.\")\n    sys.exit(1)\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n    sys.exit(1)"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 259.3333333333333,
          "successRate": 0,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 209.33333333333334,
          "successRate": 0,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Takes a filename as a command-line argument\n2. Reads the file contents (assume it contains numbers, one per line)\n3. Computes the sum of all numbers\n4. Prints the sum\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "error_handling": {
      "avgTokens": 541,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\ntype Result[a] = Ok(a) | Err(string)\n\nexport func parse_int(s: string) -\u003e Result[int] {\n  if s == \"10\" then Ok(10)\n  else if s == \"0\" then Ok(0)\n  else if s == \"5\" then Ok(5)\n  else if s == \"-5\" then Ok(-5)\n  else Err(\"Invalid integer\")\n}\n\nexport func divide_safe(a: int, b: int) -\u003e Result[int] {\n  if b == 0 then Err(\"Division by zero\") else Ok(a / b)\n}\n\nexport func print_result(res: Result[int]) -\u003e () ! {IO} {\n  match res {\n    Ok(v) =\u003e println(\"Result: \" ++ show(v)),\n    Err(msg) =\u003e println(\"Error: \" ++ msg)\n  }\n}\n\nexport func main() -\u003e () ! {IO} {\n  let r1 = match parse_int(\"10\") {\n    Ok(v) =\u003e divide_safe(v, 2),\n    Err(msg) =\u003e Err(msg)\n  };\n  print_result(r1);\n  let r2 = match parse_int(\"10\") {\n    Ok(v) =\u003e divide_safe(v, 0),\n    Err(msg) =\u003e Err(msg)\n  };\n  print_result(r2);\n  let r3 = parse_int(\"abc\");\n  print_result(r3)\n}",
        "python": "from typing import TypeVar, Generic, Union\n\nT = TypeVar('T')\n\nclass Ok(Generic[T]):\n    def __init__(self, value: T):\n        self._value = value\n\n    def __repr__(self) -\u003e str:\n        return f\"Ok({self._value!r})\"\n\n    def is_ok(self) -\u003e bool:\n        return True\n\n    def is_err(self) -\u003e bool:\n        return False\n\n    @property\n    def value(self) -\u003e T:\n        return self._value\n\nclass Err:\n    def __init__(self, message: str):\n        self._message = message\n\n    def __repr__(self) -\u003e str:\n        return f\"Err({self._message!r})\"\n\n    def is_ok(self) -\u003e bool:\n        return False\n\n    def is_err(self) -\u003e bool:\n        return True\n\n    @property\n    def message(self) -\u003e str:\n        return self._message\n\nResultInt = Union[Ok[int], Err]\n\ndef parse_int(s: str) -\u003e ResultInt:\n    try:\n        return Ok(int(s))\n    except ValueError:\n        return Err(\"Invalid integer\")\n\ndef divide_safe(a: int, b: int) -\u003e ResultInt:\n    if b == 0:\n        return Err(\"Division by zero\")\n    return Ok(a // b)\n\ndef process_and_print(s_val: str, divisor: int):\n    parse_result = parse_int(s_val)\n\n    if parse_result.is_ok():\n        divide_result = divide_safe(parse_result.value, divisor)\n        if divide_result.is_ok():\n            print(f\"Result: {divide_result.value}\")\n        else:\n            print(f\"Error: {divide_result.message}\")\n    else:\n        print(f\"Error: {parse_result.message}\")\n\nif __name__ == \"__main__\":\n    process_and_print(\"10\", 2)\n    process_and_print(\"10\", 0)\n    process_and_print(\"abc\", 2)\n    process_and_print(\"100\", 10)\n    process_and_print(\"0\", 5)\n    process_and_print(\"bad\", 0)"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 523,
          "successRate": 0.3333333333333333,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 559,
          "successRate": 0.3333333333333333,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.3333333333333333,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Defines a Result type with Ok(value) and Err(message) variants\n2. Implements a function `parse_int(s: string) -\u003e Result[int]`:\n   - Returns Ok(n) if string can be parsed as integer\n   - Returns Err(\"Invalid integer\") otherwise\n3. Implements a function `divide_safe(a: int, b: int) -\u003e Result[int]`:\n   - Returns Ok(a/b) if b != 0\n   - Returns Err(\"Division by zero\") if b == 0\n4. Chains operations: parse_int(\"10\") -\u003e divide_safe(result, 2)\n5. Prints the final result:\n   - For Ok(value): \"Result: {value}\"\n   - For Err(msg): \"Error: {msg}\"\n\nTest cases:\n- parse_int(\"10\") then divide by 2 -\u003e \"Result: 5\"\n- parse_int(\"10\") then divide by 0 -\u003e \"Error: Division by zero\"\n- parse_int(\"abc\") -\u003e \"Error: Invalid integer\"\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "fizzbuzz": {
      "avgTokens": 116.33333333333333,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\nexport func fb(n: int) -\u003e () ! {IO} {\n  if n \u003e 100\n  then ()\n  else {\n    let s = if n % 15 == 0 then \"FizzBuzz\"\n            else if n % 3 == 0 then \"Fizz\"\n            else if n % 5 == 0 then \"Buzz\"\n            else show(n);\n    println(s);\n    fb(n + 1)\n  }\n}\n\nexport func main() -\u003e () ! {IO} {\n  fb(1)\n}",
        "python": "for i in range(1, 101):\n    if i % 15 == 0:\n        print(\"FizzBuzz\")\n    elif i % 3 == 0:\n        print(\"Fizz\")\n    elif i % 5 == 0:\n        print(\"Buzz\")\n    else:\n        print(i)"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 154.33333333333334,
          "successRate": 0.6666666666666666,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 78.33333333333333,
          "successRate": 1,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.8333333333333334,
      "taskPrompt": "Write a program in \u003cLANG\u003e that prints FizzBuzz from 1 to 100.\n\nRequirements:\n- Print numbers 1-100, one per line\n- For multiples of 3, print \"Fizz\" instead of the number\n- For multiples of 5, print \"Buzz\" instead of the number\n- For multiples of both 3 and 5, print \"FizzBuzz\" instead of the number\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "float_eq": {
      "avgTokens": 21.833333333333332,
      "codeSamples": {
        "ailang": "print(\"true\" if 0.0 == 0.0 else \"false\")",
        "python": "result = (0.0 == 0.0)\nprint(str(result).lower())"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 20.333333333333332,
          "successRate": 0,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 23.333333333333332,
          "successRate": 0.6666666666666666,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.3333333333333333,
      "taskPrompt": "Write a \u003cLANG\u003e program that evaluates (0.0 == 0.0) and prints true or false.\n",
      "totalRuns": 6
    },
    "higher_order_functions": {
      "avgTokens": 169.5,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\nexport func compose(f: func(int) -\u003e int, g: func(int) -\u003e int) -\u003e func(int) -\u003e int {\n  func(x: int) -\u003e int { f(g(x)) }\n}\n\nexport func add(x: int, y: int) -\u003e int {\n  x + y\n}\n\nexport func multiply(x: int, y: int) -\u003e int {\n  x * y\n}\n\nexport func main() -\u003e () ! {IO} {\n  {\n    let add5 = func(y: int) -\u003e int { add(5, y) };\n    let double = func(y: int) -\u003e int { multiply(2, y) };\n    let add5_then_double = compose(double, add5);\n    let result = add5_then_double(10);\n    println(\"Result: \" ++ show(result))\n  }\n}",
        "python": "from functools import partial\n\ndef compose(f, g):\n    def composed(x):\n        return f(g(x))\n    return composed\n\ndef add(x, y):\n    return x + y\n\ndef multiply(x, y):\n    return x * y\n\nadd5 = partial(add, 5)\ndouble = partial(multiply, 2)\nadd5_then_double = compose(double, add5)\nresult = add5_then_double(10)\nprint(f\"Result: {result}\")"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 210.33333333333334,
          "successRate": 0,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 128.66666666666666,
          "successRate": 1,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.5,
      "taskPrompt": "Write a program in \u003cLANG\u003e that demonstrates higher-order functions:\n\n1. Implement `compose(f, g)` - returns a function that computes f(g(x))\n2. Implement `add(x, y)` - adds two numbers\n3. Implement `multiply(x, y)` - multiplies two numbers\n4. Create `add5 = add(5, _)` using partial application (or lambda)\n5. Create `double = multiply(2, _)` using partial application (or lambda)\n6. Create `add5_then_double = compose(double, add5)`\n7. Apply the composed function to 10\n8. Print the result: \"Result: {value}\"\n\nExpected computation: (10 + 5) * 2 = 30\n\nRequirements:\n- Use first-class functions\n- Demonstrate function composition\n- Show currying or partial application\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "json_encode": {
      "avgTokens": 132.33333333333334,
      "codeSamples": {
        "ailang": "user = {}\nuser.name = \"Alice\"\nuser.age = 30\nuser.active = true\nuser.hobbies = [\"reading\", \"coding\", \"hiking\"]\nuser.address = {}\nuser.address.city = \"Seattle\"\nuser.address.zip = 98101\n\nfunction tostring(v) {\n  return v + \"\"\n}\n\nfunction encode_json(u) {\n  hob = \"\"\n  i = 0\n  while i \u003c len(u.hobbies) {\n    if i \u003e 0 {\n      hob = hob + \",\"\n    }\n    hob = hob + \"\\\"\" + u.hobbies[i] + \"\\\"\"\n    i = i + 1\n  }\n  result = \"{\"\n  result = result + \"\\\"name\\\":\\\"\" + u.name + \"\\\",\"\n  result = result + \"\\\"age\\\":\" + tostring(u.age) + \",\"\n  result = result + \"\\\"active\\\":\"\n  if u.active {\n    result = result + \"true,\"\n  } else {\n    result = result + \"false,\"\n  }\n  result = result + \"\\\"hobbies\\\":[\" + hob + \"],\"\n  result = result + \"\\\"address\\\":{\\\"city\\\":\\\"\" + u.address.city + \"\\\",\\\"zip\\\":\" + tostring(u.address.zip) + \"}\"\n  result = result + \"}\"\n  return result\n}\n\njson_string = encode_json(user)\nprint(json_string)",
        "python": "import json\n\nuser_data = {\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"active\": True,\n    \"hobbies\": [\"reading\", \"coding\", \"hiking\"],\n    \"address\": {\n        \"city\": \"Seattle\",\n        \"zip\": 98101\n    }\n}\n\njson_string = json.dumps(user_data, separators=(',', ':'))\nprint(json_string)"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 165.33333333333334,
          "successRate": 0,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 99.33333333333333,
          "successRate": 0.6666666666666666,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.3333333333333333,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Creates a nested JSON structure representing:\n   - A user object with name \"Alice\", age 30, active status true\n   - An array of hobbies: [\"reading\", \"coding\", \"hiking\"]\n   - A nested address object: city \"Seattle\", zip 98101\n2. Encodes it to a JSON string\n3. Prints the JSON string\n\nThe output should be valid JSON with this structure:\n{\"name\":\"Alice\",\"age\":30,\"active\":true,\"hobbies\":[\"reading\",\"coding\",\"hiking\"],\"address\":{\"city\":\"Seattle\",\"zip\":98101}}\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "json_parse": {
      "avgTokens": 80.16666666666667,
      "codeSamples": {
        "ailang": "import json\n\njson_string = '[{\"name\":\"Alice\",\"age\":30},{\"name\":\"Bob\",\"age\":25},{\"name\":\"Charlie\",\"age\":35}]'\n\ndata = json.loads(json_string)\n\nfor person in data:\n    if person[\"age\"] \u003e= 30:\n        print(person[\"name\"])",
        "python": "import json\n\ndata = json.loads('[{\"name\":\"Alice\",\"age\":30},{\"name\":\"Bob\",\"age\":25},{\"name\":\"Charlie\",\"age\":35}]')\nfor person in data:\n    if person.get(\"age\", 0) \u003e= 30:\n        print(person.get(\"name\", \"\"))"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 80,
          "successRate": 0,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 80.33333333333333,
          "successRate": 1,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.5,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Parses this JSON array: [{\"name\":\"Alice\",\"age\":30},{\"name\":\"Bob\",\"age\":25},{\"name\":\"Charlie\",\"age\":35}]\n2. Filters to keep only people aged 30 or older\n3. Prints the names, one per line\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "list_comprehension": {
      "avgTokens": 279.1666666666667,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\n-- Predicate to check if a number is even\nfunc isEven(n: int) -\u003e bool {\n  n % 2 == 0\n}\n\n-- Function to square a number\nfunc square(n: int) -\u003e int {\n  n * n\n}\n\n-- Generic filter function\nfunc filter[a](pred: func(a) -\u003e bool, xs: [a]) -\u003e [a] {\n  match xs {\n    [] =\u003e [],\n    head :: tail =\u003e\n      if pred(head)\n      then head :: filter(pred, tail)\n      else filter(pred, tail)\n  }\n}\n\n-- Generic map function\nfunc map[a, b](f: func(a) -\u003e b, xs: [a]) -\u003e [b] {\n  match xs {\n    [] =\u003e [],\n    head :: tail =\u003e f(head) :: map(f, tail)\n  }\n}\n\n-- Function to sum all elements in an integer list\nfunc sum(xs: [int]) -\u003e int {\n  match xs {\n    [] =\u003e 0,\n    head :: tail =\u003e head + sum(tail)\n  }\n}\n\nexport func main() -\u003e () ! {IO} {\n  let initialList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n  -- Step 2: Filter the list to keep only even numbers\n  let evenNumbers = filter(isEven, initialList);\n\n  -- Step 3: Map the filtered list by squaring each number\n  let squaredEvenNumbers = map(square, evenNumbers);\n\n  -- Step 4: Compute the sum of the resulting list\n  let finalSum = sum(squaredEvenNumbers);\n\n  -- Step 5: Print the result\n  println(\"Sum of squares of evens: \" ++ show(finalSum))\n}",
        "python": "if __name__ == \"__main__\":\n    numbers = list(range(1, 11))\n    evens = [n for n in numbers if n % 2 == 0]\n    squares = [n * n for n in evens]\n    total = sum(squares)\n\n    print(f\"Original list: {numbers}\")\n    print(f\"Filtered evens: {evens}\")\n    print(f\"Squared evens: {squares}\")\n    print(f\"Sum of squares of evens: {total}\")"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 403.6666666666667,
          "successRate": 0,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 154.66666666666666,
          "successRate": 0.3333333333333333,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.16666666666666666,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Creates a list of integers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n2. Filters the list to keep only even numbers\n3. Maps the filtered list by squaring each number\n4. Computes the sum of the resulting list\n5. Prints the result: \"Sum of squares of evens: {result}\"\n\nRequirements:\n- For Python: Use list comprehensions or map/filter\n- For AILANG: Implement map/filter/fold as recursive functions\n- Show intermediate results if helpful for debugging\n\nExpected result: 2^2 + 4^2 + 6^2 + 8^2 + 10^2 = 4 + 16 + 36 + 64 + 100 = 220\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "list_operations": {
      "avgTokens": 181.5,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\ntype List[a] = Cons(a, List[a]) | Nil\n\nfunc sum_list(xs: List[int]) -\u003e int {\n  match xs {\n    Nil =\u003e 0,\n    Cons(head, tail) =\u003e head + sum_list(tail)\n  }\n}\n\nfunc length_list[a](xs: List[a]) -\u003e int {\n  match xs {\n    Nil =\u003e 0,\n    Cons(_, tail) =\u003e 1 + length_list(tail)\n  }\n}\n\nexport func main() -\u003e () ! {IO} {\n  let my_list = Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Nil)))));\n  let sum_result = sum_list(my_list);\n  let length_result = length_list(my_list);\n\n  println(\"Sum: \" ++ show(sum_result));\n  println(\"Length: \" ++ show(length_result))\n}",
        "python": "my_list = [1, 2, 3, 4, 5]\n\ndef sum_list(lst):\n    match lst:\n        case []:\n            return 0\n        case [head, *tail]:\n            return head + sum_list(tail)\n\ndef length_list(lst):\n    match lst:\n        case []:\n            return 0\n        case [_, *tail]:\n            return 1 + length_list(tail)\n\ntotal_sum = sum_list(my_list)\ntotal_length = length_list(my_list)\n\nprint(f\"Sum: {total_sum}\")\nprint(f\"Length: {total_length}\")"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 198.66666666666666,
          "successRate": 0,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 164.33333333333334,
          "successRate": 1,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.5,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Creates a list of integers: [1, 2, 3, 4, 5]\n2. Implements a recursive function `sum_list` that sums all elements\n3. Implements a recursive function `length_list` that counts elements\n4. Prints the sum and length in this exact format:\n   \"Sum: {sum}\"\n   \"Length: {length}\"\n\nRequirements:\n- Use pattern matching for head/tail (e.g., x::xs or similar)\n- Use recursion (no loops)\n- For empty list, sum is 0 and length is 0\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "nested_records": {
      "avgTokens": 241.5,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\nexport func main() -\u003e () ! {IO} {\n  let employee = {name: \"Alice\", age: 30, department: {name: \"Engineering\", code: \"ENG\", building: 5}};\n  println(\"Employee: \" ++ employee.name);\n  println(\"Department: \" ++ employee.department.name);\n  println(\"Building: \" ++ show(employee.department.building))\n}",
        "python": "from dataclasses import dataclass\n\n@dataclass\nclass Department:\n    name: str\n    code: str\n    building: int\n\n@dataclass\nclass Employee:\n    name: str\n    age: int\n    department: Department\n\ndef main():\n    department = Department(name=\"Engineering\", code=\"ENG\", building=5)\n    employee = Employee(name=\"Alice\", age=30, department=department)\n    print(f\"Employee: {employee.name}\")\n    print(f\"Department: {employee.department.name}\")\n    print(f\"Building: {employee.department.building}\")\n\nif __name__ == \"__main__\":\n    main()"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 128,
          "successRate": 1,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 355,
          "successRate": 0.6666666666666666,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.8333333333333334,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Creates a nested record structure representing a company employee:\n   - Employee record with fields:\n     - name: \"Alice\"\n     - age: 30\n     - department: (nested record)\n       - name: \"Engineering\"\n       - code: \"ENG\"\n       - building: 5\n2. Access and print the employee's name, department name, and building number\n3. Output format (one per line):\n   \"Employee: {name}\"\n   \"Department: {dept_name}\"\n   \"Building: {building}\"\n\nRequirements:\n- Use nested record/object structure\n- Access nested fields through chaining (e.g., employee.department.name)\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "numeric_modulo": {
      "avgTokens": 82.5,
      "codeSamples": {
        "ailang": "print(5 % 3)",
        "python": "print(5 % 3)"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 151.33333333333334,
          "successRate": 0,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 13.666666666666666,
          "successRate": 1,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.5,
      "taskPrompt": "Write a \u003cLANG\u003e program that prints the remainder of 5 divided by 3.\n",
      "totalRuns": 6
    },
    "pattern_matching_complex": {
      "avgTokens": 333.8333333333333,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\ntype Tree = Leaf(int) | Node(Tree, int, Tree)\n\nexport func tree_sum(tree: Tree) -\u003e int {\n  match tree {\n    Leaf(v) =\u003e v,\n    Node(l, v, r) =\u003e tree_sum(l) + v + tree_sum(r)\n  }\n}\n\nexport func find_max(tree: Tree) -\u003e int {\n  match tree {\n    Leaf(v) =\u003e v,\n    Node(l, v, r) =\u003e {\n      let left_max = find_max(l);\n      let right_max = find_max(r);\n      if left_max \u003e v then\n        if left_max \u003e right_max then left_max else right_max\n      else\n        if v \u003e right_max then v else right_max\n    }\n  }\n}\n\nexport func main() -\u003e () ! {IO} {\n  let sample_tree = Node(Leaf(1), 5, Node(Leaf(3), 7, Leaf(2)));\n  let sum = tree_sum(sample_tree);\n  let max = find_max(sample_tree);\n  println(\"Sum: \" ++ show(sum));\n  println(\"Max: \" ++ show(max))\n}",
        "python": "from __future__ import annotations\nfrom dataclasses import dataclass\nfrom typing import Union\n\n@dataclass(frozen=True)\nclass Leaf:\n    value: int\n\n@dataclass(frozen=True)\nclass Node:\n    left: Tree\n    value: int\n    right: Tree\n\nTree = Union[Leaf, Node]\n\ndef tree_sum(tree: Tree) -\u003e int:\n    match tree:\n        case Leaf(v):\n            return v\n        case Node(l, v, r):\n            return tree_sum(l) + v + tree_sum(r)\n\ndef find_max(tree: Tree) -\u003e int:\n    match tree:\n        case Leaf(v):\n            return v\n        case Node(l, v, r):\n            max_left = find_max(l)\n            max_right = find_max(r)\n            return max(v, max_left, max_right)\n\nsample_tree = Node(Leaf(1), 5, Node(Leaf(3), 7, Leaf(2)))\n\nsum_result = tree_sum(sample_tree)\nmax_result = find_max(sample_tree)\n\nprint(f\"Sum: {sum_result}\")\nprint(f\"Max: {max_result}\")"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 341.3333333333333,
          "successRate": 1,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 326.3333333333333,
          "successRate": 1,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 1,
      "taskPrompt": "Write a program in \u003cLANG\u003e that demonstrates complex pattern matching:\n\n1. Define a Tree type: Leaf(value: int) | Node(left: Tree, value: int, right: Tree)\n2. Implement `tree_sum(tree: Tree) -\u003e int` using pattern matching:\n   - Match Leaf(v): return v\n   - Match Node(l, v, r): return tree_sum(l) + v + tree_sum(r)\n3. Implement `find_max(tree: Tree) -\u003e int` with nested patterns and guards:\n   - Match Leaf(v): return v\n   - Match Node with guards to find maximum value in tree\n4. Create a sample tree: Node(Leaf(1), 5, Node(Leaf(3), 7, Leaf(2)))\n5. Print results:\n   \"Sum: {sum}\"\n   \"Max: {max}\"\n\nExpected: sum = 1+5+3+7+2 = 18, max = 7\n\nRequirements:\n- Use algebraic data types\n- Use pattern matching with nested constructors\n- Demonstrate exhaustiveness (cover all cases)\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "pipeline": {
      "avgTokens": 61.166666666666664,
      "codeSamples": {
        "ailang": "LOOP\n  LINE_INPUT = READ_LINE()\n  IF LINE_INPUT IS NULL THEN\n    BREAK\n  END IF\n  NUMBER_VALUE = TO_NUMBER(LINE_INPUT)\n  DOUBLED_VALUE = NUMBER_VALUE * 2\n  PRINT(DOUBLED_VALUE)\nEND LOOP",
        "python": "import sys\n\nfor line in sys.stdin:\n    number = int(line.strip())\n    doubled = number * 2\n    print(doubled)"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 69,
          "successRate": 0,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 53.333333333333336,
          "successRate": 0,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Reads numbers from stdin (one per line)\n2. For each number, computes double its value\n3. Prints the doubled values to stdout (one per line)\n\nAssume input is: 1, 2, 3, 4, 5 (one per line)\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "record_update": {
      "avgTokens": 159.16666666666666,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\nexport func main() -\u003e () ! {IO} {\n  let person = {name: \"Alice\", age: 30, city: \"NYC\"};\n  let older = {person | age: person.age + 1};\n  let moved = {older | city: \"SF\"};\n  println(person.name ++ \", \" ++ show(person.age) ++ \", \" ++ person.city);\n  println(older.name ++ \", \" ++ show(older.age) ++ \", \" ++ older.city);\n  println(moved.name ++ \", \" ++ show(moved.age) ++ \", \" ++ moved.city)\n}",
        "python": "from dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Person:\n    name: str\n    age: int\n    city: str\n    \n    def __str__(self):\n        return f\"{self.name}, {self.age}, {self.city}\"\n    \n    def replace(self, **kwargs):\n        return self.__class__(**{**self.__dict__, **kwargs})\n\nperson1 = Person(name=\"Alice\", age=30, city=\"NYC\")\nperson2 = person1.replace(age=31)\nperson3 = person1.replace(city=\"SF\")\n\nprint(str(person1))\nprint(str(person2))\nprint(str(person3))"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 160,
          "successRate": 1,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 158.33333333333334,
          "successRate": 0.3333333333333333,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 0.6666666666666666,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Creates a person record: {name: \"Alice\", age: 30, city: \"NYC\"}\n2. Creates an updated version with age incremented by 1 (using record update syntax)\n3. Creates another update changing only the city to \"SF\"\n4. Prints all three records in format: \"{name}, {age}, {city}\"\n\nRequirements:\n- For AILANG: Use record update syntax {r | field: value}\n- For Python: Use dict update or dataclass replace\n- Each update creates a NEW record (immutable)\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "records_person": {
      "avgTokens": 122.33333333333333,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\nexport func main() -\u003e () ! {IO} {\n  let alice = {name: \"Alice\", age: 30, city: \"NYC\"};\n  let bob = {name: \"Bob\", age: 25, city: \"SF\"};\n  println(alice.name ++ \", \" ++ show(alice.age) ++ \", \" ++ alice.city);\n  println(bob.name ++ \", \" ++ show(bob.age) ++ \", \" ++ bob.city)\n}",
        "python": "from dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n    city: str\n    \n    def __str__(self):\n        return f\"{self.name}, {self.age}, {self.city}\"\n\n# Create two persons\nalice = Person(name=\"Alice\", age=30, city=\"NYC\")\nbob = Person(name=\"Bob\", age=25, city=\"SF\")\n\n# Print both persons\nprint(alice)\nprint(bob)"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 124.66666666666667,
          "successRate": 1,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 120,
          "successRate": 1,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 1,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Creates a person record/object with fields: name (string), age (int), city (string)\n2. Creates TWO persons:\n   - Alice: name=\"Alice\", age=30, city=\"NYC\"\n   - Bob: name=\"Bob\", age=25, city=\"SF\"\n3. Prints both persons in this exact format (one per line):\n   \"{name}, {age}, {city}\"\n\nOutput only the code for \u003cLANG\u003e, no explanations.\n",
      "totalRuns": 6
    },
    "recursion_factorial": {
      "avgTokens": 83.83333333333333,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\nexport func factorial(n: int) -\u003e int {\n  if n \u003c= 1\n  then 1\n  else n * factorial(n - 1)\n}\n\nexport func main() -\u003e () ! {IO} {\n  let result = factorial(10);\n  println(show(result))\n}",
        "python": "def factorial(n):\n    \"\"\"Compute n! using recursion.\"\"\"\n    if n \u003c 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)\n\n\nresult = factorial(10)\nprint(result)"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 83.33333333333333,
          "successRate": 1,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 84.33333333333333,
          "successRate": 1,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 1,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Defines a recursive factorial function that computes n!\n2. Computes factorial(10)\n3. Prints the result\n\nThe factorial function should use recursion (not loops).\n\nOutput only the code for \u003cLANG\u003e, no explanations.\n",
      "totalRuns": 6
    },
    "recursion_fibonacci": {
      "avgTokens": 90.66666666666667,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\nexport func fib(n: int) -\u003e int {\n  if n == 0\n  then 0\n  else if n == 1\n  then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\nexport func main() -\u003e () ! {IO} {\n  let result = fib(20);\n  println(show(result))\n}",
        "python": "def fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n\nresult = fib(20)\nprint(result)"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 98.66666666666667,
          "successRate": 1,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 82.66666666666667,
          "successRate": 1,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 1,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Defines a recursive Fibonacci function: fib(0) = 0, fib(1) = 1, fib(n) = fib(n-1) + fib(n-2)\n2. Computes fib(20)\n3. Prints the result\n\nThe function MUST use recursion (not loops or memoization).\nThis will be compute-intensive to test execution performance.\n\nOutput only the code for \u003cLANG\u003e, no explanations.\n",
      "totalRuns": 6
    },
    "simple_print": {
      "avgTokens": 20.333333333333332,
      "codeSamples": {
        "python": "print(\"Hello World\")\nprint(\"The answer is 42\")"
      },
      "languageStats": {
        "python": {
          "avgTokens": 20.333333333333332,
          "successRate": 1,
          "totalRuns": 3
        }
      },
      "languages": [
        "python"
      ],
      "successRate": 1,
      "taskPrompt": "Write a Python program that prints exactly:\nHello World\nThe answer is 42\n\nRequirements:\n- Two lines of output\n- First line: \"Hello World\"\n- Second line: \"The answer is 42\"\n\nOutput only the code, no explanations.\n",
      "totalRuns": 3
    },
    "string_manipulation": {
      "avgTokens": 102.83333333333333,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\nexport func main() -\u003e () ! {IO} {\n  let greeting = \"Hello\";\n  let name = \"World\";\n  let year = 2025;\n  let message = greeting ++ \", \" ++ name ++ \"! Year: \" ++ show(year);\n  let check = if greeting == \"Hello\" then \"Match\" else \"No match\";\n  println(\"Message: \" ++ message);\n  println(\"Check: \" ++ check)\n}",
        "python": "greeting = \"Hello\"\nname = \"World\"\nyear = 2025\n\nmessage = greeting + \", \" + name + \"! Year: \" + str(year)\n\nif greeting == \"Hello\":\n    check = \"Match\"\nelse:\n    check = \"No match\"\n\nprint(\"Message: \" + message)\nprint(\"Check: \" + check)"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 122.66666666666667,
          "successRate": 1,
          "totalRuns": 3
        },
        "python": {
          "avgTokens": 83,
          "successRate": 1,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang",
        "python"
      ],
      "successRate": 1,
      "taskPrompt": "Write a program in \u003cLANG\u003e that:\n1. Creates three variables:\n   - greeting: \"Hello\"\n   - name: \"World\"\n   - year: 2025 (integer)\n2. Concatenates them into a message: \"{greeting}, {name}! Year: {year}\"\n3. Checks if greeting equals \"Hello\" (print \"Match\" or \"No match\")\n4. Prints both results:\n   \"Message: {message}\"\n   \"Check: {Match or No match}\"\n\nRequirements:\n- Use string concatenation operator\n- Convert integer to string for concatenation\n- Use string equality comparison\n\nOutput only the code, no explanations.\n",
      "totalRuns": 6
    },
    "targeted_repair_test": {
      "avgTokens": 48.333333333333336,
      "codeSamples": {
        "ailang": "module benchmark/solution\n\nimport std/io (println)\n\nexport func main() -\u003e () ! {IO} {\n  let result = 2 + 2;\n  println(show(result))\n}"
      },
      "languageStats": {
        "ailang": {
          "avgTokens": 48.333333333333336,
          "successRate": 0.6666666666666666,
          "totalRuns": 3
        }
      },
      "languages": [
        "ailang"
      ],
      "successRate": 0.6666666666666666,
      "taskPrompt": "Write an AILANG program that computes 2 + 2 and prints the result.\n\nAILANG Syntax Guide (IMPORTANT - Follow exactly):\n- Module declaration: Not needed for single-file programs\n- Import: `import std/io (println)`\n- Function: `let main = { println(4) }` OR `let main = println(4)`\n- Numbers: Just write them: 1, 2, 42\n- Arithmetic: Use infix: 2 + 2\n- Print: Use `println(expr)`\n- Block syntax: If you need multiple statements: `{ stmt1; stmt2; result }`\n  CRITICAL: Semicolons BETWEEN statements, NOT after the last one\n- Let binding: `let x = expr in body` OR for top-level: `let x = expr`\n\nExample AILANG program:\n```\nimport std/io (println)\n\nlet main = {\n  let result = 2 + 2;\n  println(result)\n}\n```\n\nWrite EXACTLY this style. Output only the code.\n",
      "totalRuns": 3
    }
  },
  "languages": {
    "ailang": {
      "avg_tokens": 173.42857142857142,
      "success_rate": 0.4603174603174603,
      "total_runs": 63
    },
    "python": {
      "avg_tokens": 154.5079365079365,
      "success_rate": 0.7142857142857143,
      "total_runs": 63
    }
  },
  "history": [
    {
      "version": "v0.3.9",
      "timestamp": "2025-10-16T13:16:59+02:00",
      "successRate": 0.5873015873015873,
      "totalRuns": 126,
      "successCount": 74,
      "languages": "ailang,python",
      "languageStats": {
        "ailang": {
          "success_rate": 0.4603174603174603,
          "total_runs": 63
        },
        "python": {
          "success_rate": 0.7142857142857143,
          "total_runs": 63
        }
      }
    },
    {
      "version": "v0.3.8",
      "timestamp": "2025-10-15T09:10:51Z",
      "successRate": 0.6578947368421053,
      "totalRuns": 114,
      "successCount": 75,
      "languages": "python,ailang",
      "languageStats": {
        "ailang": {
          "success_rate": 0.49122807017543857,
          "total_runs": 57
        },
        "python": {
          "success_rate": 0.8245614035087719,
          "total_runs": 57
        }
      }
    },
    {
      "version": "v0.3.7-1-gd24a7dc",
      "timestamp": "2025-10-15T06:37:44Z",
      "successRate": 0.5877192982456141,
      "totalRuns": 114,
      "successCount": 67,
      "languages": "python,ailang",
      "languageStats": {
        "ailang": {
          "success_rate": 0.38596491228070173,
          "total_runs": 57
        },
        "python": {
          "success_rate": 0.7894736842105263,
          "total_runs": 57
        }
      }
    },
    {
      "version": "v0.3.6-24-mini",
      "timestamp": "0001-01-01T00:00:00Z",
      "successRate": 0.618421052631579,
      "totalRuns": 76,
      "successCount": 47,
      "languages": "",
      "languageStats": {
        "ailang": {
          "success_rate": 0.42105263157894735,
          "total_runs": 38
        },
        "python": {
          "success_rate": 0.8157894736842105,
          "total_runs": 38
        }
      }
    },
    {
      "version": "v0.3.6-24",
      "timestamp": "0001-01-01T00:00:00Z",
      "successRate": 0.6176470588235294,
      "totalRuns": 68,
      "successCount": 42,
      "languages": "",
      "languageStats": {
        "ailang": {
          "success_rate": 0.4117647058823529,
          "total_runs": 34
        },
        "python": {
          "success_rate": 0.8235294117647058,
          "total_runs": 34
        }
      }
    }
  ]
}