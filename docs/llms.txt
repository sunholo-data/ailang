# AILANG Documentation for LLMs

This file contains all AILANG documentation in a single file for LLM consumption.

Last updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

---


# README

# AILANG: The AI-First Programming Language

![CI](https://github.com/sunholo-data/ailang/workflows/CI/badge.svg)
![Coverage](https://img.shields.io/badge/coverage-29.0%25-orange.svg)
![Go Version](https://img.shields.io/badge/go-%3E%3D1.22-blue.svg)
![License](https://img.shields.io/badge/license-Apache%202.0-green.svg)

AILANG is a purely functional programming language designed specifically for AI-assisted software development. It features static typing with algebraic effects, typed quasiquotes for safe string handling, CSP-based concurrency with session types, and automatic generation of training data for AI model improvement.

## Current Version: v0.3.0 (Clock & Net Effects + Type System Fixes)

**üéØ What Works**: Full module execution, **Clock effect** (monotonic time), **Net effect** (HTTP GET/POST with security), **record subsumption**, **row polymorphism** (opt-in), complete Hindley-Milner type inference, type classes (Num, Eq, Ord, Show), lambda calculus, REPL with full type checking, module execution runtime, effect system (IO, FS, Clock, Net with capability security), cross-module imports, pattern matching with exhaustiveness checking, **block expressions**, and **recursion support**.

**‚úÖ Major Milestones**:
- **Clock effect** with monotonic time and virtual time for deterministic execution
- **Net effect** with full Phase 2 PM security hardening:
  - DNS rebinding prevention
  - Protocol validation (https enforced, file:// blocked)
  - IP blocking (localhost, private IPs, link-local)
  - Redirect validation with IP re-check
  - Body size limits (5MB default)
  - Domain allowlist with wildcard support
- Records support subsumption: functions accepting `{id: int}` work with larger records
- Row polymorphism available via `AILANG_RECORDS_V2=1`

**üìä Test Coverage**: 48/66 examples passing (72.7%). All record subsumption, effect system (IO, FS, Clock, Net), type class, ADT, recursion, and block expression examples working. See [examples/STATUS.md](examples/STATUS.md) for details.

**üìñ Documentation**: [Implementation Status](docs/reference/implementation-status.md) | [CHANGELOG.md](CHANGELOG.md)

## Quick Start

### Installation

```bash
# From source
git clone https://github.com/sunholo/ailang.git
cd ailang
make install

# Verify installation
ailang --version
```

For detailed installation instructions, see the [Getting Started Guide](docs/guides/getting-started.md).

### Hello World (Module Execution)

AILANG v0.2.0 now executes module files with effects:

```ailang
-- examples/demos/hello_io.ail
module examples/demos/hello_io

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello from AILANG v0.2.0!")
}
```

```bash
ailang run --caps IO examples/demos/hello_io.ail
# Output: Hello from AILANG v0.2.0!
```

**Important**: Flags must come BEFORE the filename:
```bash
# ‚úÖ CORRECT:
ailang run --caps IO --entry main file.ail

# ‚ùå WRONG:
ailang run file.ail --caps IO --entry main
```

More examples:
```bash
ailang run examples/arithmetic.ail                        # Arithmetic
ailang run examples/simple.ail                            # Let bindings
ailang run --caps IO --entry main examples/micro_block_seq.ail  # Block expressions
ailang run --caps IO --entry greet examples/test_io_builtins.ail  # IO effects
ailang run --caps Clock,IO --entry main examples/micro_clock_measure.ail  # Clock effect ‚ú® NEW
ailang run --caps Net,IO --entry main examples/demo_ai_api.ail  # Net effect (API calls) ‚ú® NEW
ailang run --entry greet examples/test_invocation.ail     # Cross-function calls
```

**‚ú® NEW: Clock & Net Effects** (v0.3.0-alpha4)
```ailang
-- Clock effect: Monotonic time (immune to NTP/DST)
import std/clock (now, sleep)

func benchmark() -> int ! {Clock, IO} {
  let start = now();
  sleep(100);  -- Sleep 100ms
  let elapsed = now() - start;
  elapsed
}
```

```ailang
-- Net effect: HTTP GET/POST with security hardening
import std/net (httpGet, httpPost)
import std/io (println)

func callAPI() -> () ! {Net, IO} {
  let response = httpGet("https://api.example.com/data");
  println(response)
}
```

**Net Security Features**:
- ‚úÖ HTTPS enforced (http:// requires `--net-allow-http`)
- ‚úÖ DNS rebinding prevention
- ‚úÖ IP blocking (localhost, private IPs, link-local)
- ‚úÖ Protocol blocking (file://, ftp://, data://)
- ‚úÖ Redirect validation (max 5 redirects)
- ‚úÖ Body size limits (5MB default)
- ‚úÖ Domain allowlist with wildcard support

**‚ú® Block Expressions** (v0.3.0)
```ailang
-- Blocks allow sequencing multiple expressions
{
  println("first");
  println("second");
  42  -- Value of block is the last expression
}

-- Perfect for recursive functions with logging:
func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}
```

See [examples/STATUS.md](examples/STATUS.md) for complete example inventory (48/66 passing).

### Interactive REPL (Fully Functional)

The REPL is the **most complete** part of AILANG v0.1.0, featuring full type inference and type classes:

```bash
ailang repl

Œª> 1 + 2
3 :: Int

Œª> "Hello " ++ "World"
Hello World :: String

Œª> let double = \x. x * 2 in double(21)
42 :: Int

Œª> :type \x. x + x
\x. x + x :: ‚àÄŒ±. Num Œ± ‚áí Œ± ‚Üí Œ±

Œª> let compose = \f. \g. \x. f(g(x)) in compose (\x. x * 2) (\x. x + 1) 5
12 :: Int

Œª> :quit
```

**REPL Commands**: `:help`, `:type <expr>`, `:instances`, `:import <module>`, `:history`, `:clear`

See [REPL Commands](docs/reference/repl-commands.md) for full reference.

## What Works in v0.1.0

### ‚úÖ Complete Type System

- **Hindley-Milner Type Inference** - Full polymorphic type inference with let-polymorphism
- **Type Classes** - `Num`, `Eq`, `Ord`, `Show` with dictionary-passing semantics
- **Constraint Solving** - Type class constraint generation and resolution
- **Defaulting** - Automatic defaulting for ambiguous numeric types (Int, Float)
- **Type Checking** - Module interface checking, export resolution, import validation

### ‚úÖ Lambda Calculus & Expressions

- **Lambda Expressions** - First-class functions with closures and currying
- **Function Composition** - Higher-order functions, partial application
- **Let Bindings** - Polymorphic let expressions (up to 3 nested levels)
- **Conditionals** - `if-then-else` expressions
- **Block Expressions** - `{ e1; e2; e3 }` for sequencing (desugars to let chains) ‚ú® NEW in v0.3.0
- **Operators** - Arithmetic (`+`, `-`, `*`, `/`), comparison (`==`, `<`, `>`, etc.), string concatenation (`++`)

### ‚úÖ Data Structures

- **Lists** - `[1, 2, 3]` with type inference
- **Records** - `{name: "Alice", age: 30}` with field access
- **Tuples** - `(1, "hello", true)` for heterogeneous data
- **Strings** - String literals with concatenation

### ‚úÖ Module System (Type-Checking Only)

- **Module Declarations** - `module path/to/module`
- **Import/Export** - `import stdlib/std/io (println)`, `export func main() ...`
- **Path Resolution** - Correct module path resolution and validation
- **Dependency Analysis** - Import graph construction, cycle detection
- **Interface Generation** - Module signatures with exported types/functions

**Note**: Modules parse and type-check correctly but cannot execute until v0.2.0. See [LIMITATIONS.md](docs/LIMITATIONS.md#critical-limitation-module-execution-gap).

### ‚úÖ Interactive Development

- **Professional REPL** - Arrow key history, tab completion, persistent history (`~/.ailang_history`)
- **Type Inspection** - `:type <expr>` shows qualified types with constraints
- **Instance Inspection** - `:instances` lists available type class instances
- **Debugging Tools** - `:dump-core`, `:dump-typed`, `:trace-defaulting`, `:dry-link`
- **Auto-imports** - `stdlib/std/prelude` loaded automatically

### ‚úÖ Error Reporting

- **Structured Errors** - JSON error output with schema versioning
- **Deterministic Diagnostics** - Stable error messages, line/column positions
- **Helpful Messages** - Type errors, parse errors, module loading errors

## What's Coming in v0.2.0

### üöÄ v0.2.0 Roadmap (Module Execution & Effects)

**M-R1: Module Execution Runtime** (~1,200 LOC, 1.5-2 weeks)
- Module instance creation and initialization
- Import resolution and linking at runtime
- Top-level function execution
- Exported function calls

**M-R2: Algebraic Effects Foundation** (~800 LOC, 1-1.5 weeks)
- Effect declarations and checking
- Effect handler syntax (`with`, `handle`)
- Capability-based effect system
- Basic effects: `IO`, `FS`, `Net`

**M-R3: Pattern Matching** (~600 LOC, 1 week)
- `match` expressions
- Pattern guards
- Exhaustiveness checking
- Constructor patterns for ADTs

**Total Timeline**: 3.5-4.5 weeks for v0.2.0

See [v0.2.0 Roadmap](design_docs/planned/v0_2_0_module_execution.md) for details.

### üìã Future Features (v0.3.0+)

- Typed quasiquotes (SQL, HTML, JSON, regex)
- CSP-based concurrency with channels
- Session types for protocol verification
- Property-based testing (`properties [...]`)
- AI training data export

<!-- EXAMPLES_STATUS_START -->
## Status

![Examples](https://img.shields.io/badge/examples-56%20passing%2022%20failing-red.svg)

### Example Verification Status

*Last updated: 2025-10-06 10:46:17 UTC*

**Summary:** 56 passed, 22 failed, 4 skipped (Total: 82)

| Example File | Status | Notes |
|--------------|--------|-------|
| `adt_option.ail` | ‚úÖ Pass |  |
| `adt_simple.ail` | ‚úÖ Pass |  |
| `arithmetic.ail` | ‚úÖ Pass |  |
| `block_demo.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `block_recursion.ail` | ‚úÖ Pass |  |
| `bug_float_comparison.ail` | ‚úÖ Pass |  |
| `bug_modulo_operator.ail` | ‚úÖ Pass |  |
| `demo_ai_api.ail` | ‚ùå Fail | Error: execution failed: effect 'Net' requires ... |
| `demo_openai_api.ail` | ‚ùå Fail | Error: execution failed: effect 'IO' requires c... |
| `demos/adt_pipeline.ail` | ‚úÖ Pass |  |
| `demos/effects_pure.ail` | ‚ùå Fail | Warning: import path 'stdlib/std/*' is deprecat... |
| `demos/hello_io.ail` | ‚úÖ Pass |  |
| `effects_basic.ail` | ‚úÖ Pass |  |
| `effects_pure.ail` | ‚úÖ Pass |  |
| `experimental/ai_agent_integration.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/concurrent_pipeline.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/factorial.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/quicksort.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/web_api.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `guards_basic.ail` | ‚úÖ Pass |  |
| `hello.ail` | ‚úÖ Pass |  |
| `lambda_expressions.ail` | ‚ùå Fail | Error: type error in examples/lambda_expression... |
| `list_patterns.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `micro_block_if.ail` | ‚úÖ Pass |  |
| `micro_block_seq.ail` | ‚úÖ Pass |  |
| `micro_clock_measure.ail` | ‚ùå Fail | Error: execution failed: effect 'Clock' require... |
| `micro_io_echo.ail` | ‚úÖ Pass |  |
| `micro_net_fetch.ail` | ‚ùå Fail | Error: execution failed: effect 'Net' requires ... |
| `micro_option_map.ail` | ‚úÖ Pass |  |
| `micro_record_person.ail` | ‚úÖ Pass |  |
| `option_demo.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `patterns.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `records.ail` | ‚ùå Fail | Error: type error in examples/records (decl 3):... |
| `recursion_error.ail` | ‚úÖ Pass |  |
| `recursion_factorial.ail` | ‚úÖ Pass |  |
| `recursion_fibonacci.ail` | ‚úÖ Pass |  |
| `recursion_mutual.ail` | ‚úÖ Pass |  |
| `recursion_quicksort.ail` | ‚úÖ Pass |  |
| `showcase/01_type_inference.ail` | ‚úÖ Pass |  |
| `showcase/02_lambdas.ail` | ‚úÖ Pass |  |
| `showcase/03_lists.ail` | ‚ùå Fail | Error: evaluation error: builtin concat_String ... |
| `showcase/03_type_classes.ail` | ‚úÖ Pass |  |
| `showcase/04_closures.ail` | ‚úÖ Pass |  |
| `simple.ail` | ‚úÖ Pass |  |
| `stdlib_demo.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `stdlib_demo_simple.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `test_effect_annotation.ail` | ‚úÖ Pass |  |
| `test_effect_capability.ail` | ‚úÖ Pass |  |
| `test_effect_fs.ail` | ‚úÖ Pass |  |
| `test_effect_io.ail` | ‚úÖ Pass |  |
| `test_effect_io_simple.ail` | ‚ùå Fail | Error: evaluation error: _io_println: no effect... |
| `test_exhaustive_bool_complete.ail` | ‚úÖ Pass |  |
| `test_exhaustive_bool_incomplete.ail` | ‚úÖ Pass |  |
| `test_exhaustive_wildcard.ail` | ‚úÖ Pass |  |
| `test_fizzbuzz.ail` | ‚úÖ Pass |  |
| `test_float_comparison.ail` | ‚úÖ Pass |  |
| `test_float_eq_works.ail` | ‚úÖ Pass |  |
| `test_float_modulo.ail` | ‚úÖ Pass |  |
| `test_guard_bool.ail` | ‚úÖ Pass |  |
| `test_guard_debug.ail` | ‚úÖ Pass |  |
| `test_guard_false.ail` | ‚úÖ Pass |  |
| `test_import_ctor.ail` | ‚úÖ Pass |  |
| `test_import_func.ail` | ‚úÖ Pass |  |
| `test_integral.ail` | ‚úÖ Pass |  |
| `test_invocation.ail` | ‚úÖ Pass |  |
| `test_io_builtins.ail` | ‚úÖ Pass |  |
| `test_m_r7_comprehensive.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `test_module_minimal.ail` | ‚úÖ Pass |  |
| `test_modulo_works.ail` | ‚úÖ Pass |  |
| `test_net_file_protocol.ail` | ‚ùå Fail | Error: execution failed: effect 'Net' requires ... |
| `test_net_localhost.ail` | ‚ùå Fail | Error: execution failed: effect 'Net' requires ... |
| `test_net_security.ail` | ‚ùå Fail | Error: execution failed: effect 'Net' requires ... |
| `test_no_import.ail` | ‚úÖ Pass |  |
| `test_record_subsumption.ail` | ‚úÖ Pass |  |
| `test_single_guard.ail` | ‚úÖ Pass |  |
| `test_use_constructor.ail` | ‚úÖ Pass |  |
| `test_with_import.ail` | ‚úÖ Pass |  |
| `type_classes_working_reference.ail` | ‚úÖ Pass |  |
| `typeclasses.ail` | ‚ùå Fail | Error: type error in examples/typeclasses (decl... |
| `v3_3/imports.ail` | ‚úÖ Pass |  |
| `v3_3/imports_basic.ail` | ‚úÖ Pass |  |
| `v3_3/math/gcd.ail` | ‚ùå Fail | Error: entrypoint 'main' not found in module |

<!-- EXAMPLES_STATUS_END -->

## Documentation

### User Documentation
- **[LIMITATIONS.md](docs/LIMITATIONS.md)** - ‚ö†Ô∏è Read this first! Current v0.1.0 limitations and workarounds
- **[Getting Started](docs/guides/getting-started.md)** - Installation and quick tutorial
- **[REPL Commands](docs/reference/repl-commands.md)** - Interactive REPL guide (fully functional)
- **[Language Syntax](docs/reference/language-syntax.md)** - Complete language reference
- **[Examples Status](examples/STATUS.md)** - Inventory of all 42 example files
- **[Examples README](examples/README.md)** - How to use and understand examples

### Development Documentation
- **[Implementation Status](docs/reference/implementation-status.md)** - Detailed component status with metrics
- **[Development Guide](docs/guides/development.md)** - Contributing and development workflow
- **[CLAUDE.md](CLAUDE.md)** - Instructions for AI assistants working on AILANG
- **[Changelog](CHANGELOG.md)** - Version history and release notes

### Design & Architecture
- **[AI-First Features](docs/ai-first-features.md)** - Why AILANG is designed for AI collaboration
- **[Design Documents](design_docs/)** - Architecture and design decisions
- **[v0.1.0 MVP Roadmap](design_docs/20250929/v0_1_0_mvp_roadmap.md)** - Current milestone plan
- **[Showcase Issues](docs/SHOWCASE_ISSUES.md)** - Known parser/execution limitations discovered during example creation

## Development

```bash
# Build and install
make install

# Run tests
make test

# Start REPL
make repl

# Run example
make run FILE=examples/hello.ail

# Auto-rebuild on changes
make watch-install

# Check coverage
make test-coverage-badge

# AI Evaluation & Design Generation (NEW! ‚ú®)
make eval-suite          # Run AI benchmarks (AILANG vs Python)
make eval-report         # Generate evaluation report
make eval-analyze        # Analyze failures, generate design docs (auto-dedup)
make eval-analyze-fresh  # Force new docs (disable dedup)
make eval-to-design      # Full workflow: evals ‚Üí analysis ‚Üí design docs
```

See the [Development Guide](docs/guides/development.md) for detailed instructions.

## Project Structure

```
ailang/
‚îú‚îÄ‚îÄ cmd/ailang/       # CLI entry point
‚îú‚îÄ‚îÄ internal/         # Core implementation
‚îÇ   ‚îú‚îÄ‚îÄ repl/         # Interactive REPL
‚îÇ   ‚îú‚îÄ‚îÄ lexer/        # Tokenizer
‚îÇ   ‚îú‚îÄ‚îÄ parser/       # Parser
‚îÇ   ‚îú‚îÄ‚îÄ types/        # Type system
‚îÇ   ‚îú‚îÄ‚îÄ eval/         # Evaluator
‚îÇ   ‚îî‚îÄ‚îÄ ...           # Other components
‚îú‚îÄ‚îÄ examples/         # Example programs
‚îú‚îÄ‚îÄ docs/             # Documentation
‚îú‚îÄ‚îÄ design_docs/      # Design documents
‚îî‚îÄ‚îÄ scripts/          # CI/CD scripts
```

## Contributing

AILANG is an experimental language in active development. Contributions are welcome! Please see the [Development Guide](docs/guides/development.md) for guidelines.

## License

Apache 2.0 - See [LICENSE](LICENSE) for details.

## Acknowledgments

AILANG draws inspiration from:
- Haskell (type system, purity)
- OCaml (module system, effects)
- Rust (capability-based security)
- Erlang/Go (CSP concurrency)

---

## FAQ

**Q: Can I use AILANG for production code?**
A: Not yet. v0.1.0 is an MVP focused on the type system. Module execution arrives in v0.2.0 (planned ~4 weeks).

**Q: What's the difference between REPL and file execution?**
A: The REPL is fully functional with type classes. File execution works for non-module files. Module files type-check but cannot execute until v0.2.0.

**Q: Which examples actually work?**
A: See [examples/STATUS.md](examples/STATUS.md). 12 examples execute successfully. The showcase examples in `examples/showcase/` demonstrate working features.

**Q: How can I help or contribute?**
A: See [Development Guide](docs/guides/development.md). We especially welcome testing, example creation, and documentation improvements.

**Q: What makes AILANG "AI-first"?**
A: Explicit effects, deterministic execution traces, structured errors, and typed metaprogramming make AILANG ideal for AI-assisted development and training data generation. See [AI-First Features](docs/ai-first-features.md).

---

*For AI agents: This is an experimental functional language with complete Hindley-Milner type inference, type classes (Num/Eq/Ord/Show), and lambda calculus. The REPL is fully functional. Non-module file execution works for expressions and let bindings. Module files type-check but cannot execute (runtime coming in v0.2.0). See [LIMITATIONS.md](docs/LIMITATIONS.md) and [Implementation Status](docs/reference/implementation-status.md) for exact capabilities.*
---

# CHANGELOG

# AILANG Changelog

## [Unreleased] - 2025-10-08

### Added - M-EVAL-LOOP Milestone 1: Self-Repair Foundation ‚úÖ COMPLETE

**Complete self-repair system for AI evaluation benchmarks with error taxonomy, retry logic, and CLI integration (~520 LOC in 3.5 hours).**

**Implementation** (`internal/eval_harness/`)
- **Error taxonomy** (`errors.go`, ~150 LOC)
  - 6 error codes: PAR_001, TC_REC_001, TC_INT_001, EQ_001, CAP_001, MOD_001
  - Regex-based error matching with repair hints
  - `CategorizeErrorCode()` matches stderr against patterns
  - `FormatRepairPrompt()` generates error-specific fix guidance
  - Structured RepairHint with Title/Why/How format
- **RepairRunner orchestration** (`repair.go`, ~140 LOC)
  - Single-shot self-repair loop: attempt ‚Üí error ‚Üí repair ‚Üí retry
  - `Run()` method handles first attempt + optional repair
  - `runSingleAttempt()` for code generation + execution cycles
  - `populateMetrics()` for comprehensive metrics tracking
  - Automatic error categorization and repair prompt injection
- **Extended metrics** (`metrics.go`, modified)
  - Self-repair tracking: FirstAttemptOk, RepairUsed, RepairOk
  - Error details: ErrCode, RepairTokensIn, RepairTokensOut
  - Prompt versioning: PromptVersion field (ready for A/B testing)
  - Reproducibility: BinaryHash, StdlibHash, Caps fields

**Tests** (`internal/eval_harness/errors_test.go`, ~200 LOC)
- 10 test cases covering all error codes
- Repair prompt formatting validation
- Rule completeness checks
- Regex pattern validation
- All tests passing ‚úÖ

**CLI Integration** (`cmd/ailang/eval.go`, modified)
- New `--self-repair` flag for single-shot repair
- RepairRunner integration replacing manual execution
- Enhanced output showing repair attempts and results
- Backward compatible (repair disabled by default)

**Usage:**
```bash
# Without self-repair (0-shot)
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5

# With self-repair (1-shot)
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5 --self-repair
```

**Files Modified:**
- `internal/eval_harness/errors.go` (+150 LOC)
- `internal/eval_harness/errors_test.go` (+200 LOC)
- `internal/eval_harness/repair.go` (+140 LOC)
- `internal/eval_harness/metrics.go` (+30 LOC)
- `cmd/ailang/eval.go` (refactored for RepairRunner)
- Total: ~520 LOC

**Key Design Decisions:**
1. Single-shot repair only (no infinite loops)
2. Error-specific repair hints (not generic "fix it")
3. Metrics track both first attempt and repair separately
4. RepairRunner owns orchestration (agent + runner coordination)
5. Backward compatible CLI (repair opt-in via flag)

**Velocity:** ~150 LOC/hour, ahead of schedule (estimated 6-8 hours, actual 3.5 hours)

---

## [v0.3.0] - 2025-10-05

Complete implementation of Clock & Net effects (M-R6) with full Phase 2 PM security hardening, plus critical type system fixes (M-R7) for modulo operator and float comparison.

### Added - M-R7 Type System Fixes ‚úÖ COMPLETE
- **Fixed modulo operator (`%`)**: Works correctly with type defaulting (`5 % 3` returns `2`)
- **Fixed float comparison (`==`)**: Resolves dictionary correctly (`0.0 == 0.0` returns `true`)
- **Regression tests**:
  - `examples/test_integral.ail` - Locks in modulo fix
  - `examples/test_float_comparison.ail` - Locks in float comparison fix
  - `examples/test_fizzbuzz.ail` - Exercises both `%` and `==` together
  - `benchmarks/numeric_modulo.yml` - Eval harness benchmark for `%`
  - `benchmarks/float_eq.yml` - Eval harness benchmark for `==`
  - All tests passing ‚úÖ

### Added - AI API Examples (with v0.4.0 roadmap)
- **`examples/demo_openai_api.ail`** - OpenAI API example with workaround for missing features
- **`design_docs/planned/v0_4_0_net_enhancements.md`** - Complete roadmap for Net enhancements:
  - Custom HTTP headers (`httpPostWithHeaders`)
  - Environment variable reading (`getEnv`, `hasEnv`)
  - JSON parsing (`parseJSON`, `getValue`)
  - Response status/headers

## [v0.3.0-alpha4] - 2025-10-05

### Added - M-R6 Phase 2: Clock & Net Effects ‚úÖ COMPLETE
- **Clock effect** (`internal/effects/clock.go`, 109 LOC)
  - `_clock_now()` returns current time in milliseconds since Unix epoch
  - `_clock_sleep(ms)` suspends execution for specified milliseconds
  - Monotonic time: immune to NTP/DST changes (uses `time.Since(start) + epoch`)
  - Virtual time: deterministic mode with `AILANG_SEED` (starts at epoch 0)
  - stdlib wrapper: `std/clock` module with `now()` and `sleep()` functions
- **Net effect** (`internal/effects/net.go`, 355 LOC - Phase 2 PM FULL)
  - `_net_httpGet(url)` fetches content from HTTP/HTTPS URLs
  - `_net_httpPost(url, body)` sends POST requests with JSON body
  - **DNS rebinding prevention**: resolve ‚Üí validate IPs ‚Üí dial validated IP directly
  - **Protocol security**: https always allowed, http requires `--net-allow-http`, file:// blocked
  - **IP blocking**: localhost (127.x, ::1), private IPs (10.x, 192.168.x, 172.16-31.x), link-local
  - **Redirect validation**: max 5 redirects, re-validate IP at each hop
  - **Body size limits**: 5MB default via `io.LimitReader`, configurable via `NetContext.MaxBytes`
  - **Domain allowlist**: optional wildcard matching (*.example.com)
  - stdlib wrapper: `std/net` module with `httpGet()` and `httpPost()` functions
- **NetContext security configuration** (`internal/effects/context.go`, +130 LOC)
  - `Timeout` (30s default), `MaxBytes` (5MB), `MaxRedirects` (5)
  - `AllowHTTP` (false), `AllowLocalhost` (false)
  - `AllowedDomains` (wildcard support), `UserAgent` ("ailang/0.3.0")
- **IP validation helpers** (`internal/effects/net_security.go`, 91 LOC)
  - `validateIP()` checks IP against security policy
  - `resolveAndValidateIP()` prevents DNS rebinding attacks
  - `isAllowedDomain()` and `matchDomain()` for allowlist checking
- **Comprehensive test suites**:
  - Clock: 9 tests with flaky-guard (100 iterations for determinism)
  - Net: 6 test suites covering capabilities, protocols, IPs, domains, POST, body limits
  - All tests passing with both real network and mocked scenarios
- **2 new example files**:
  - `examples/micro_clock_measure.ail` - Clock effect demonstration
  - `examples/demo_ai_api.ail` - Real API calling with httpbin.org
- **Stdlib modules**:
  - `stdlib/std/clock.ail` - Clock effect wrappers
  - `stdlib/std/net.ail` - Net effect wrappers with security docs

### Security
- **M-R6 Net effect implements full Phase 2 PM hardening**
  - DNS rebinding prevention protects against SSRF attacks
  - IP blocking prevents access to localhost, private networks, link-local
  - Protocol validation blocks file://, ftp://, data://, gopher://
  - Redirect validation with IP re-check at each hop
  - Body size limits prevent memory exhaustion
  - Domain allowlist enables fine-grained access control
  - All security features tested with comprehensive test suite

### Fixed
- Added capability checks to `netHttpGet()` and `netHttpPost()` (requires `--caps Net`)
- Updated `resolveAndValidateIP()` to accept `*EffContext` for `AllowLocalhost` flag
- Fixed `validateIP()` to check `ctx.Net.AllowLocalhost` before blocking localhost IPs

## [v0.3.0-alpha3] - 2025-10-05

### Added - M-R5: Records & Row Polymorphism ‚úÖ COMPLETE
- **Record subsumption** for flexible field access
  - Functions accepting `{id: int}` now work with `{id: int, name: string, email: string}`
  - Field access uses open records: `{x: Œ± | œÅ}` unifies with larger closed records
  - Enables polymorphic functions over records with common fields
- **TRecord2 with row polymorphism** (opt-in via `AILANG_RECORDS_V2=1`)
  - Proper row types with tail variables: `{x: int, y: bool | œÅ}`
  - Row unification with occurs check prevents infinite types
  - Order-independent field matching: `{x:int,y:bool}` ~ `{y:bool,x:int}`
  - Nested record openness: `{u:{id:int | œÅ}}` ~ `{u:{id:int,email:string}}`
- **TRecordOpen compatibility shim** for Day 1 subsumption
  - Bridges old TRecord and new TRecord2 systems
  - Enables subsumption without breaking existing code
- **Enhanced error messages** (TC_REC_001 - TC_REC_004)
  - TC_REC_001: Missing field with available field suggestions
  - TC_REC_002: Duplicate field in literal with positions
  - TC_REC_003: Row occurs check with infinite type prevention
  - TC_REC_004: Field type mismatch with clear expected vs actual
- **New helper functions** in `internal/types/unification.go`:
  - `RecordHasField()` - Check field existence across record types
  - `RecordFieldType()` - Get field type safely
  - `IsOpenRecord()` - Detect open vs closed records
  - `TRecordToTRecord2()`, `TRecord2ToTRecord()` - Bidirectional conversion
- **Row unifier with occurs check**
  - `unifyRows()` handles field-by-field unification
  - Prevents `œÅ ~ {x: œÑ | œÅ}` infinite types
  - Proper tail unification with commutativity
- **2 new example files**:
  - `examples/micro_record_person.ail` - Simple field access and aliasing
  - `examples/test_record_subsumption.ail` - Demonstrates subsumption in action
- **16 new unit tests** covering:
  - TRecord2 ~ TRecord2 unification (4 cases)
  - TRecord ‚Üî TRecord2 conversion (3 cases)
  - Row occurs check (1 case)
  - Open-closed interactions (6 cases)
  - Order independence, nested openness, field mismatches

### Changed
- **Typechecker emits TRecord2** when `AILANG_RECORDS_V2=1` is set
  - `inferRecordLiteral()` creates TRecord2 for record literals
  - Default still uses TRecord for backwards compatibility
  - Plan: Enable by default in v0.3.1, remove TRecord in v0.4.0
- **Field access uses TRecordOpen** for subsumption
  - `inferRecordAccess()` emits open records instead of closed
  - Allows functions to work with record subsets

### Fixed
- **Record field access** now works with nested records
  - Before: `{ceo: {name: "Jane"}}.ceo.name` ‚Üí type error
  - After: Correctly types and evaluates to "Jane" ‚úÖ
- **Subsumption** enables polymorphic record functions
  - Before: Functions required exact field matches
  - After: Functions work with any record containing required fields ‚úÖ

### Impact
- **Lines of code**: ~670 total
  - Day 1: ~198 LOC (TRecordOpen, subsumption, helpers)
  - Day 2: ~280 LOC (TRecord2 unification, row unifier, conversion, occurs check, tests)
  - Day 3: ~192 LOC (flag support, error codes, examples, tests)
- **Examples**: 48/66 passing (72.7%, up from 40)
  - +9 fixed from subsumption (Day 1)
  - +2 new examples (Day 3)
- **Tests**: 16 new unit tests, all passing
- **Files modified**: 8 files
  - `internal/types/types.go` - TRecordOpen type
  - `internal/types/typechecker_core.go` - useRecordsV2 flag, inferRecordLiteral
  - `internal/types/unification.go` - Subsumption, TRecord2, unifyRows, helpers
  - `internal/types/errors.go` - TC_REC_001-004 error codes
  - `internal/types/record_unification_test.go` - 16 unit tests (NEW)
  - `examples/micro_record_person.ail` - (NEW)
  - `examples/test_record_subsumption.ail` - (NEW)
  - `examples/STATUS.md` - Updated counts

### Migration Guide
**Opt-in to TRecord2**:
```bash
export AILANG_RECORDS_V2=1
ailang run examples/micro_record_person.ail
```

**Using subsumption**:
```ailang
-- Define function with minimal fields
func printId(entity: {id: int}) -> () ! {IO} {
  println(show(entity.id))
}

-- Works with any record containing 'id'!
printId({id: 42})                           -- ‚úÖ
printId({id: 100, name: "Alice"})          -- ‚úÖ
printId({id: 200, name: "Bob", age: 30})   -- ‚úÖ
```

## [v0.3.0-alpha2] - 2025-10-05

### Added - M-R8: Block Expressions ‚úÖ COMPLETE
- **Block expression syntax** `{ e1; e2; e3 }` for sequencing multiple expressions
  - Last expression's value is the block's value
  - Non-last expressions evaluated for side effects
  - Desugars to let chains: `let _ = e1 in let _ = e2 in e3`
- **Bug fix** in `internal/elaborate/scc.go` (~10 LOC)
  - Added missing `*ast.Block` case to `findReferences()` function
  - Fixed recursion detection for functions using block syntax
  - Self-recursive and mutual recursion now work correctly with blocks
- **3 new example files**:
  - `examples/micro_block_seq.ail` - Basic block sequencing
  - `examples/micro_block_if.ail` - Blocks in if-then-else branches
  - `examples/block_recursion.ail` - Recursive functions with blocks
- **AI compatibility unlocked** ‚ú®
  - AI-generated code with blocks now works out of the box
  - No manual rewriting required
  - Compatible with Claude Sonnet 4.5, GPT-4, etc.

### Fixed
- **Recursion + Blocks Bug**: Functions with recursive calls inside blocks now correctly detected as recursive
  - Before: `func fact(n) { ... fact(n-1) }` ‚Üí "undefined variable: fact"
  - After: Correctly creates LetRec, recursion works ‚úÖ
- **SCC Detection**: `findReferences()` now traverses all expression types including blocks

### Impact
- Lines of code: 10 (5-line case statement)
- Examples: 3 new files
- Test status: All existing tests pass + new examples verified
- Developer experience: Major improvement for AI-assisted development

## [v0.3.0-alpha1] - 2025-10-05

### Added - M-R4: Recursion Support ‚úÖ COMPLETE
- **Full recursion support** via RefCell indirection (OCaml/Haskell-style semantics)
  - Self-referential closures with proper capture semantics
  - Mutually recursive functions (pre-bind all names before evaluation)
  - Function-first semantics: lambdas safe immediately, non-lambdas evaluated strictly
- **Stack overflow protection** with `--max-recursion-depth` CLI flag (default: 10,000)
  - Configurable depth limit for both module and non-module execution
  - Clear RT_REC_003 error messages with actionable guidance
- **Cycle detection** for recursive values (RT_REC_001 error)
  - Prevents infinite loops in non-function bindings
  - Example: `let rec x = x + 1 in x` properly detected and rejected
- **New runtime infrastructure** in `internal/eval/`
  - `RefCell` type for mutable indirection cells (value.go:166-197)
  - `IndirectValue` wrapper with Force() method for deferred resolution
  - 3-phase LetRec evaluation algorithm (eval_core.go:363-426)
  - Recursion depth tracking in CoreEvaluator (eval_core.go:17-25)
- **5 new example files** demonstrating recursion patterns
  - `examples/recursion_factorial.ail` - Simple & tail-recursive factorial
  - `examples/recursion_fibonacci.ail` - Tree recursion with 2 recursive calls
  - `examples/recursion_mutual.ail` - Mutually recursive isEven/isOdd
  - `examples/recursion_quicksort.ail` - Conceptual recursive structure
  - `examples/recursion_error.ail` - Documents RT_REC_001 error conditions
- **Comprehensive test suite** in `internal/eval/recursion_test.go`
  - 6 unit tests covering all recursion patterns
  - Tests for factorial, fibonacci, mutual recursion, stack overflow, deep recursion
  - All tests passing with experimental binop shim

### Changed
- **Example baseline improved**: 43 passing (up from 32), 14 failed, 4 skipped (Total: 61)
  - 11 additional examples now passing due to recursion infrastructure
- **CoreEvaluator** now tracks recursion depth for stack overflow detection
- **Module runtime** applies max recursion depth limit via `rt.GetEvaluator().SetMaxRecursionDepth()`

### Technical Details
- **Lines of code**: ~1,200 (core implementation) + ~380 (tests) + ~200 (examples)
- **Semantic model**: Proper Œª-calculus closure semantics matching textbook small-step operational semantics
- **Performance**: O(1) lookup via pointer indirection, negligible overhead
- **Error taxonomy**:
  - RT_REC_001: Recursive value used before initialization (non-function RHS)
  - RT_REC_002: Uninitialized recursive binding (internal ordering bug)
  - RT_REC_003: Stack overflow with depth limit exceeded

### Language Milestone
**AILANG is now Turing-complete** with deterministic semantics:
- ‚úÖ Œª-abstraction (first-class functions)
- ‚úÖ Application (function calls)
- ‚úÖ Conditionals (if-then-else)
- ‚úÖ Recursion (self & mutual)
- ‚úÖ Side-effects (IO/FS with capability security)

This milestone enables expressing every partial recursive function under deterministic semantics.

## [v0.2.1] - 2025-10-03

### Fixed
- **Windows Build Compatibility**: Fixed two Windows-specific test failures
  - Fixed `TestFSWriteFile_Success` using invalid `*` wildcard in filename (not allowed on Windows)
  - Fixed `TestNewModuleRuntime` path separator mismatch (Windows uses `\` vs Unix `/`)
  - All tests now pass on Windows, Linux, and macOS

### Changed
- Tests are now OS-agnostic, using `filepath.Clean()` for cross-platform compatibility
- Improved CI/CD reliability across all supported platforms

### üîÑ RECURSION & REAL-WORLD PROGRAMS (Target: 50+ examples)

**Status**: üöß IN PLANNING - See [design_docs/20251004/v0_3_0_implementation_plan.md](design_docs/20251004/v0_3_0_implementation_plan.md)

**Planned Features**:

#### M-R4: Recursion Support ‚úÖ COMPLETE (v0.3.0-alpha1)
- ‚úÖ **DONE**: LetRec support in runtime evaluator (RefCell indirection)
- ‚úÖ **DONE**: Self-referential closures (3-phase algorithm)
- ‚úÖ **DONE**: Recursive function examples (factorial, fibonacci, quicksort, mutual, error)
- ‚úÖ **DONE**: Stack overflow protection (--max-recursion-depth flag)
- **Impact**: AILANG now Turing-complete with deterministic semantics

#### M-R8: Block Expressions (HIGH PRIORITY, ~300 LOC) ‚Üê **NEW**
- ‚úÖ **TODO**: Block syntax `{ e1; e2; e3 }` as syntactic sugar
- ‚úÖ **TODO**: Desugar to let-sequencing: `let _ = e1 in let _ = e2 in e3`
- ‚úÖ **TODO**: Parser support (recognize `{ }` in expression position)
- ‚úÖ **TODO**: Empty block error with clear message
- ‚úÖ **TODO**: 3 integration examples (seq, if-then-else, recursion)
- **Impact**: **Critical for AI compatibility** - unblocks Claude Sonnet 4.5 generated code with blocks
- **Why**: AI models naturally generate blocks, currently fails to parse
- **Risk**: LOW (pure syntactic sugar, no type system or runtime changes)

#### M-R5: Records & Row Polymorphism (HIGH PRIORITY, ~500 LOC)
- ‚úÖ **TODO**: Complete TRecord unification
- ‚úÖ **TODO**: Row variables for polymorphic records
- ‚úÖ **TODO**: Field access type checking improvements
- **Impact**: Enables proper data modeling

#### M-R6: Extended Effects - Clock & Net (MEDIUM PRIORITY, ~700 LOC)
- ‚úÖ **TODO**: std/clock effect (now, sleep, timeout)
- ‚úÖ **TODO**: std/net effect (httpGet, httpPost)
- ‚úÖ **TODO**: Capability enforcement and security sandbox
- **Impact**: Real-world program connectivity

#### M-R7: Modulo Operator Fix (MEDIUM PRIORITY, ~200 LOC)
- ‚úÖ **TODO**: Integral type class (div, mod)
- ‚úÖ **TODO**: Fix % operator type inference
- **Impact**: Removes arithmetic operator blocker

#### M-UX2: User Experience (LOW PRIORITY, ~300 LOC)
- ‚úÖ **TODO**: Better recursion error messages
- ‚úÖ **TODO**: Audit script Clock/Net detection
- ‚úÖ **TODO**: 4-6 new micro examples

**Target Success Metrics**:
- **Passing Examples**: 42 ‚Üí 50+ (83%+)
- **Recursion**: Broken ‚Üí Working
- **Records**: Partial ‚Üí Working with row polymorphism
- **Effects**: IO/FS ‚Üí + Clock/Net (4 total)
- **Modulo (%)**: Broken ‚Üí Working via Integral

**Timeline**: October 17-21, 2025 (2 weeks)

---

## [v0.2.0] - 2025-10-03

### üéâ AUTO-ENTRY & EXAMPLE EXPLOSION: 42/53 Passing (79%) ‚úÖ

**Achieved Target**: Exceeded v0.2.0 goal of ‚â•35 passing examples, reaching **42/53 (79.2%)**

**Implementation**: ~200 LOC across 3 strategic improvements
1. **Auto-Entry Fallback** (`cmd/ailang/main.go`, ~50 LOC)
   - Intelligent entrypoint selection when `main` not found
   - Auto-selects single zero-arg function, or tries `test()`
   - Eliminated "entrypoint not found" errors for 10+ examples

2. **Audit Script Enhancement** (`tools/audit-examples.sh`, ~20 LOC)
   - Automatic capability detection (`! {IO}`, `! {FS}`)
   - Runs examples with appropriate `--caps` flags
   - Enabled testing of all IO/FS effect examples

3. **TRecord Unification Support** (`internal/types/unification.go`, ~40 LOC)
   - Added handler for legacy `*TRecord` type in unification
   - Fixed "unhandled type in unification" errors
   - Improved record type checking with field-by-field unification

4. **Micro Examples** (2 new passing examples)
   - `examples/micro_option_map.ail` - Pure ADT operations
   - `examples/micro_io_echo.ail` - IO effect demonstration

**Results**: +14 examples in single session
- Before: 28/51 passing (55%)
- After: 42/53 passing (79%)
- **Progress**: +50% more working examples

**Newly Passing Examples** (+14):
- `demos/hello_io.ail` - IO effect with println
- `effects_basic.ail` - Basic effect annotations
- `stdlib_demo.ail` - Standard library usage
- `stdlib_demo_simple.ail` - Simplified stdlib demo
- `test_effect_annotation.ail` - Effect syntax
- `test_effect_capability.ail` - Capability requirements
- `test_effect_fs.ail` - FS effect testing
- `test_effect_io.ail` - IO effect testing
- `test_invocation.ail` - Function invocation
- `test_io_builtins.ail` - IO builtin functions
- `test_module_minimal.ail` - Minimal module
- `test_no_import.ail` - No imports required
- `micro_io_echo.ail` - NEW micro example
- `micro_option_map.ail` - NEW micro example

**Key Insight**: Auto-entry was the MVP - single feature unlocked 10+ examples by making testing frictionless.

**Impact on v0.2.0 Goals**:
- ‚úÖ Target met: ‚â•35 examples (achieved 42)
- ‚úÖ Effect system validated: IO/FS working across examples
- ‚úÖ Module execution proven: Cross-module imports stable
- ‚úÖ User experience improved: Reduced friction for running examples

---

## [v0.2.0-rc1] - 2025-10-02

### üéØ M-EVAL: AI Evaluation Framework (~600 LOC) ‚úÖ

**AI Teachability Benchmarking System** - October 2, 2025

Added comprehensive framework for measuring AILANG's "AI teachability" - how easily AI models can learn to write correct AILANG code.

**Infrastructure**:
- `internal/eval_harness/` - Benchmark execution framework (~600 LOC)
  - `spec.go` - YAML benchmark loader with prompt file support
  - `runner.go` - Python & AILANG code execution with module path handling
  - `ai_agent.go` - LLM API wrapper with model resolution
  - `api_anthropic.go` - Claude API implementation (tested: 230 tokens)
  - `api_openai.go` - GPT API implementation (tested: 319 tokens)
  - `api_google.go` - Gemini/Vertex AI implementation (tested: 278 tokens)
  - `metrics.go` - JSON metrics logging with cost calculation
  - `models.go` - Centralized model configuration system

**Prompt System**:
- `prompts/v0.2.0.md` - Versioned AI teaching prompt for v0.2.0-rc1
- Documents working features: modules, effects, pattern matching, ADTs
- Includes common mistakes and correct patterns

**Benchmarks**:
- 5 benchmarks covering difficulty spectrum
- Supports prompt file loading via `prompt_file` YAML field
- Module path validation and stdlib resolution

**CLI**:
```bash
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5 --seed 42
./tools/run_benchmark_suite.sh  # Run all benchmarks with all 3 models
```

**Documentation**:
- `docs/guides/ai-prompt-guide.md` - AI teaching guide with v0.2.0 syntax
- `docs/guides/evaluation/` - Evaluation framework documentation
  - `baseline-tests.md` - Running first baseline tests
  - `model-configuration.md` - Model management
  - `README.md` - Framework overview

**Test Results**: All 3 models tested successfully
- ‚úÖ Claude Sonnet 4.5 (Anthropic): 230 tokens generated
- ‚úÖ GPT-5 (OpenAI): 319 tokens generated
- ‚úÖ Gemini 2.5 Pro (Vertex AI): 278 tokens generated

**KPI**: Establishes baseline for "AI teachability" metric (target: 80%+ success rate on simple benchmarks)

### üêõ Critical Fixes: Type Inference & Builtins (+22 LOC) ‚úÖ

**Fixed Arithmetic Operators** (`internal/runtime/builtins.go`, +13 LOC)
- Added `registerArithmeticBuiltins()` to register all arithmetic operators in module runtime
- Modulo operator `%` now works: `export func main() -> int { 5 % 3 }  -- Returns: 2`
- All arithmetic operators (`+`, `-`, `*`, `/`, `%`, `**`) available in module execution
- Delegates to existing `eval.Builtins` implementations via wrapper

**Fixed Comparison Operators** (`internal/types/typechecker_core.go`, +9 LOC)
- Modified `pickDefault()` to default `Ord`, `Eq`, `Show` constraints to `int`
- Comparison operators (`>`, `<`, `>=`, `<=`, `==`, `!=`) now work in modules
- No more "ambiguous type variable Œ± with classes [Ord]" errors
- Example: `export func compare(x: int, y: int) -> bool { x > y }  -- Works!`

**Impact**: AI-generated code now compiles correctly. Basic arithmetic and comparisons work as expected.

### ‚ö†Ô∏è Known Limitations (Discovered During M-EVAL Testing)

**Critical Issues Requiring v0.2.1 Patch**:

1. **Recursive Functions in Modules** - HIGH PRIORITY
   - Functions cannot call themselves: `factorial(n-1)` fails with "undefined variable"
   - Blocks common patterns (loops via recursion, FizzBuzz, tree traversal)
   - Root cause: Function bindings not in own scope during evaluation
   - Estimated fix: ~200-300 LOC, 2-3 days

2. **Capability Passing to Runtime** - CRITICAL
   - `--caps IO,FS` flag not propagating to effect context
   - All effect-based code fails even with capabilities granted
   - Blocks all IO/FS demos and examples
   - Estimated fix: ~100-200 LOC, 1-2 days

**See**: `design_docs/20251002/v0_2_0_implementation_plan.md` (Known Limitations section) for full details and next sprint recommendations.

---

## [Unreleased v0.2.0-rc1] - 2025-10-02 (Original Features)

### üöÄ Major Features: M-R1, M-R2, M-R3 ALL COMPLETE ‚úÖ

**Milestone Achievement**:
- Module execution runtime (M-R1, ~1,874 LOC) ‚úÖ
- Effect system runtime (M-R2, ~1,550 LOC) ‚úÖ
- Pattern matching polish (M-R3, ~700 LOC) ‚úÖ
  - Phase 1: Guards (~55 LOC)
  - Phase 2: Exhaustiveness checking (~255 LOC)
  - Phase 3: Decision trees (~390 LOC)
- Critical bug fixes

This release delivers core runtime milestones with working capability enforcement AND comprehensive pattern matching enhancements. AILANG now has:
- Fully executable module system with capability-based effect operations
- Pattern matching with conditional guards
- Exhaustiveness warnings for incomplete matches
- Decision tree optimization for pattern matching (available, disabled by default)
- Effects like IO and FS work with explicit permission grants via `--caps` flag

**üîß CRITICAL BUG FIXES (Oct 2)**: Removed legacy builtin path that bypassed effect system. Capability checking now works correctly. Fixed stdlib import resolution and integration test loader paths.

#### Added - M-R3 Phase 1: Guards (~55 LOC)

**Guard Support** (55 LOC)
- **Guard Elaboration** (`internal/elaborate/elaborate.go:1062-1069`)
  - Elaborates guard expressions during match compilation
  - Guards are normalized to Core ANF
  - Error handling for malformed guards
- **Guard Evaluation** (`internal/eval/eval_core.go:586-613`)
  - Evaluates guards with pattern bindings in scope
  - Enforces Bool type requirement for guards
  - False guards cause fallthrough to next arm
- **Tests**: 6 unit tests passing (`guards_simple_test.go`)
  - Basic true/false guards
  - Multiple sequential guards
  - Guard accessing pattern bindings
  - Non-Bool guard error handling
  - All guards failing ‚Üí non-exhaustive error
- **Examples**:
  - `test_guard_bool.ail` - Guard with true
  - `test_guard_false.ail` - Guard causing fallthrough

#### Added - M-R3 Phase 2: Exhaustiveness Checking (~255 LOC)

**Exhaustiveness Analysis** (255 LOC)
- **Pattern Universe Builder** (`internal/elaborate/exhaustiveness.go`)
  - Constructs complete pattern sets for types (Bool ‚Üí {true, false})
  - Pattern expansion and subtraction algorithms
  - Conservative handling of guards (don't count as coverage)
- **Integration** (`internal/elaborate/elaborate.go`, `internal/pipeline/pipeline.go`)
  - Exhaustiveness checker added to Elaborator
  - Warnings collected during elaboration
  - Result struct includes warnings array
- **CLI Display** (`cmd/ailang/main.go`)
  - Yellow-colored warnings displayed to stderr
  - Shows missing patterns for non-exhaustive matches
- **Tests**: 7 unit tests passing (`exhaustiveness_test.go`)
  - Complete Bool match (exhaustive)
  - Incomplete Bool match (non-exhaustive)
  - Wildcard coverage
  - Variable pattern coverage
  - Guard-aware checking
  - Infinite type handling (Int/Float/String)
- **Examples**:
  - `test_exhaustive_bool_complete.ail` - No warning
  - `test_exhaustive_bool_incomplete.ail` - Warning: missing false
  - `test_exhaustive_wildcard.ail` - Wildcard makes exhaustive

**Limitations**:
- Only Bool type fully supported (finite pattern universe)
- Int/Float/String require wildcard (infinite types)
- No ADT support yet (requires type environment integration)
- Guards conservatively treated as non-covering

#### Added - M-R3 Phase 3: Decision Trees (~390 LOC)

**Decision Tree Compilation** (390 LOC)
- **Tree Structure** (`internal/dtree/decision_tree.go`)
  - LeafNode, FailNode, SwitchNode representations
  - Pattern matrix compilation algorithm
  - Pattern specialization and row reduction
  - Heuristic for when to use decision trees (2+ literal/constructor patterns)
- **Tree Evaluation** (`internal/eval/decision_tree.go`)
  - Tree walking with scrutinee dispatch
  - Path-based value extraction for nested patterns
  - Guard checking in leaf nodes
  - Fallback to linear evaluation if tree compilation not beneficial
- **Integration** (`internal/eval/eval_core.go`)
  - Optional decision tree compilation (disabled by default)
  - Seamless fallback to linear pattern matching
  - Future: can be enabled via flag or heuristic
- **Tests**: 4 unit tests passing (`decision_tree_test.go`)
  - Simple Bool match compilation
  - Wildcard default handling
  - All-wildcards optimization
  - Heuristic validation

**Implementation Notes**:
- Decision trees available but disabled by default (runtime optimization)
- Reduces redundant pattern tests via switch-based dispatch
- Preserves exact semantics of linear pattern matching
- Can be enabled in future with flag/heuristic

#### Added - Phase 5: Function Invocation & Builtins (~280 LOC)

**Function Invocation** (60 LOC)
- **CallEntrypoint()** (`internal/runtime/entrypoint.go`)
  - Calls exported entrypoint functions from modules
  - Validates arity and function type
  - Sets up cross-module resolver
- **CallFunction()** (`internal/eval/eval_core.go`)
  - Public method to invoke FunctionValues
  - Manages environment binding and restoration
  - Supports 0-arg and multi-arg functions
- **CLI Integration** (`cmd/ailang/main.go`)
  - Argument decoding from `--args-json`
  - Result printing (silent for Unit types)
  - Helpful error messages for multi-arg functions

**Builtin Registry** (120 LOC)
- **BuiltinRegistry** (`internal/runtime/builtins.go`)
  - Native Go implementations of stdlib functions
  - IO builtins: `_io_print`, `_io_println`, `_io_readLine`
  - Integrated into ModuleRuntime initialization
- **Resolver Integration** (`internal/runtime/resolver.go`)
  - Checks builtins before local/import lookup
  - Supports `$builtin` module and `_` prefix names
- **Lit Expression Handling** (`internal/runtime/runtime.go`)
  - `extractBindings()` now handles Lit expressions at module level
  - Enables stdlib modules to load correctly

**Examples**
- `examples/test_invocation.ail` - 0-arg and 1-arg function examples
- `examples/test_io_builtins.ail` - Builtin IO function demonstration

#### Test Results - Phase 5

- **Unit Tests**: ‚úÖ 16/16 passing (all runtime non-integration tests)
- **Integration Tests**: ‚ö†Ô∏è 2/7 passing (5 fail due to known loader path issues)
- **End-to-End Examples**: ‚úÖ 2/2 new examples working
- **Total**: ~280 LOC added

---

#### üîß Fixed - Critical Bug Fixes (Oct 2, ~50 LOC changes)

**Bug #1: Legacy Builtin Path Bypassed Effect System** üö®
- **Issue**: Special case in `evalCoreApp()` called `CallBuiltin()` directly, bypassing capability checking
- **Location**: `internal/eval/eval_core.go:404-416` (deleted)
- **Fix**: Removed 13 LOC special case; all builtins now route through resolver
- **Impact**: Capability checking NOW WORKS correctly
- **Test**: `ailang run effects_basic.ail` ‚Üí denies without `--caps IO`, allows with it
- **Added**: Deprecation comment on old `CallBuiltin()` function

**Bug #2: Stdlib Imports Not Found** üîß
- **Issue**: `import std/io` failed with "module not found"
- **Location**: `internal/loader/loader.go:80-88, 154-164`
- **Fix**: Resolve `std/` prefix from `stdlib/` directory (or `$AILANG_STDLIB_PATH`)
- **Impact**: Stdlib imports work: `import std/io (println)`
- **Test**: `examples/effects_basic.ail` now loads and runs

**Bug #3: Integration Tests Failed on Module Loading** ‚ö†Ô∏è
- **Issue**: Loader used relative paths, tests couldn't find modules
- **Location**: `internal/loader/loader.go:94-97, 167-169`
- **Fix**: Join project-relative paths with `basePath` for absolute resolution
- **Additional**: Added Core elaboration in runtime (avoid import cycle)
- **Additional**: Added minimal interface builder for modules loaded without pipeline
- **Impact**: 5/7 integration tests now passing (2 fail on cross-module elaboration)
- **Test**: `TestIntegration_SimpleModule` and 4 others pass

**Test Coverage After Fixes**:
- ‚úÖ All eval tests passing (no regressions)
- ‚úÖ 39/39 effect tests passing
- ‚úÖ 5/7 integration tests passing
- ‚úÖ End-to-end capability enforcement verified

---

### ‚ö° Major Feature: Effect System Runtime (M-R2 COMPLETE ‚úÖ)

**Milestone Achievement**: Capability-based effect system (~1,550 LOC total).

This implements the effect runtime that brings type-level effects into execution. Effects require explicit capability grants via `--caps` flag. Includes IO and FS operations with sandbox support.

**Status**: COMPLETE - Capability checking working, all acceptance criteria met.

#### Added - Effect System Infrastructure (~1,550 LOC)

**Core Effect System** (650 LOC)
- **Capability** (`internal/effects/capability.go`, 50 LOC)
  - Grant tokens for effect permissions (e.g., IO, FS, Net)
  - Metadata support for future budgets/quotas
  - `NewCapability(name)` constructor

- **EffContext** (`internal/effects/context.go`, 100 LOC)
  - Runtime context holding capability grants
  - Environment configuration (AILANG_SEED, TZ, LANG, sandbox)
  - Methods: `Grant()`, `HasCap()`, `RequireCap()`
  - `loadEffEnv()` loads from OS environment

- **Effect Operations Registry** (`internal/effects/ops.go`, 100 LOC)
  - `EffOp` type: `func(ctx, args) (Value, error)`
  - Registry: effect name ‚Üí operation name ‚Üí EffOp
  - `Call()` performs capability check + execution
  - `RegisterOp()` for operation registration

**IO Effect** (150 LOC)
- **IO Operations** (`internal/effects/io.go`)
  - `ioPrint(s)` - Print without newline
  - `ioPrintln(s)` - Print with newline
  - `ioReadLine()` - Read from stdin
  - All require IO capability grant

**FS Effect** (200 LOC)
- **FS Operations** (`internal/effects/fs.go`)
  - `fsReadFile(path)` - Read file to string
  - `fsWriteFile(path, content)` - Write string to file
  - `fsExists(path)` - Check file/directory existence
  - Sandbox support via `AILANG_FS_SANDBOX` env var
  - All require FS capability grant

**Error Handling** (50 LOC)
- **CapabilityError** (`internal/effects/errors.go`)
  - Clear error messages for missing capabilities
  - Helpful hints: "Run with --caps IO"

**Integration** (150 LOC)
- **CLI Flag** (`cmd/ailang/main.go`)
  - `--caps IO,FS,Net` flag for granting capabilities
  - Comma-separated capability list
  - Creates EffContext with grants before execution

- **Evaluator Support** (`internal/eval/eval_core.go`)
  - `SetEffContext(ctx)` / `GetEffContext()` methods
  - EffContext field added to CoreEvaluator

- **Runtime Integration** (`internal/runtime/`)
  - Builtins route to effect system via `effects.Call()`
  - `GetEvaluator()` method for EffContext access

**Stdlib** (20 LOC)
- **stdlib/std/fs.ail** - FS module with readFile, writeFile, exists

#### Testing - Effect System (750 LOC)

**Unit Tests** (550 LOC):
- `internal/effects/context_test.go` (150 LOC) - 12 tests for capabilities
- `internal/effects/io_test.go` (250 LOC) - 15 tests for IO operations
- `internal/effects/fs_test.go` (250 LOC) - 12 tests for FS operations
- ‚úÖ **39/39 tests passing**
- ‚úÖ **100% coverage** for new packages

**Integration Tests** (200 LOC):
- `internal/effects/integration_cli_test.go` - Full flow testing
- Capability grant/denial scenarios
- Sandbox enforcement verification

**Examples**:
- `examples/test_effect_io.ail` - IO operations demo
- `examples/test_effect_fs.ail` - FS operations placeholder

#### Usage Examples

**IO with capability grant**:
```bash
ailang run app.ail --caps IO
```

**FS with sandbox**:
```bash
AILANG_FS_SANDBOX=/tmp ailang run app.ail --caps FS
```

**Multiple capabilities**:
```bash
ailang run app.ail --caps IO,FS,Net
```

#### Known Limitations - Effect System

‚ö†Ô∏è **Legacy Builtin Path**: The old `CallBuiltin()` in `internal/eval/builtins.go:410` bypasses capability checks. Effect operations work but enforcement is incomplete.

**Impact**: Architecture complete, runtime checks bypassed by legacy code
**Fix Planned**: v0.2.1 - Remove legacy builtin special case

#### Metrics - M-R2

| Metric | Value |
|--------|-------|
| Total LOC | 1,550 |
| Core Code | 650 |
| Tests | 750 |
| Integration | 150 |
| Test Coverage | 100% (new packages) |
| Unit Tests | 39 passing |

---

## [v0.1.1] - 2025-10-02

### üöÄ Major Feature: Module Execution Runtime (M-R1 Phases 1-4)

**Milestone Achievement**: Core infrastructure for module execution complete (~1,594 LOC).

This release delivers the foundation for executable modules. Function invocation was completed in v0.2.0-rc1.

#### Added - Module Runtime Infrastructure (~1,594 LOC)

**Phase 1: Scaffolding** (692 LOC)
- **ModuleInstance** (`internal/runtime/module.go`, 164 LOC)
  - Runtime representation of modules with evaluated bindings
  - Thread-safe initialization using `sync.Once`
  - Export filtering and access control
  - Methods: `GetExport()`, `HasExport()`, `GetBinding()`, `ListExports()`, `IsEvaluated()`

- **ModuleRuntime** (`internal/runtime/runtime.go`, 149 LOC)
  - Orchestrates module loading, caching, and evaluation
  - Circular import detection with clear error messages ("A ‚Üí B ‚Üí C ‚Üí A")
  - Topological dependency evaluation
  - Methods: `LoadAndEvaluate()`, `GetInstance()`, `PreloadModule()`

- **Unit Tests** (379 LOC)
  - `internal/runtime/module_test.go` - 7 tests for ModuleInstance
  - `internal/runtime/runtime_test.go` - 5 tests for ModuleRuntime
  - 12/12 tests passing ‚úÖ

**Phase 2: Evaluation + Resolver** (402 LOC)
- **Global Resolver** (`internal/runtime/resolver.go`, 120 LOC)
  - Cross-module reference resolution with encapsulation enforcement
  - Routes imported references through exports only (never private bindings)
  - Error handling with module availability checks

- **Module Evaluation** (~70 LOC in `runtime.go`)
  - `evaluateModule()` method for top-level binding extraction
  - Integration with existing Core evaluator
  - Export filtering based on module interface

- **Resolver Tests** (`internal/runtime/resolver_test.go`, 212 LOC)
  - 6 tests for local/import resolution, encapsulation, error cases
  - 18/18 total tests passing ‚úÖ

**Phase 3: Linking & Topological Sort** (~300 LOC)
- **Cycle Detection** (~50 LOC in `runtime.go`)
  - DFS-based circular import detection
  - Clear error messages with import path: "circular import detected: A ‚Üí B ‚Üí C ‚Üí A"
  - State tracking with `visiting` map and `pathStack`

- **Integration Tests** (`internal/runtime/integration_test.go`, 249 LOC)
  - 7 integration tests covering module execution flows
  - Test modules in `tests/runtime_integration/` (simple.ail, dep.ail, with_import.ail)
  - 2/7 passing (5 have known loader path issues, non-blocking)

**Phase 4: CLI Integration** (~200 LOC)
- **Pipeline Extension** (`internal/pipeline/pipeline.go`, ~60 LOC)
  - Added `Modules map[string]*loader.LoadedModule` to Result struct
  - Converts CompileUnits to LoadedModules after elaboration
  - Preserves Core AST, Iface, and imports for runtime use

- **Loader Preloading** (`internal/loader/loader.go`, ~15 LOC)
  - Added `Preload(path, loaded)` method to inject elaborated modules
  - Avoids redundant loading and elaboration

- **Recursive Binding Extraction** (`internal/runtime/runtime.go`, ~55 LOC)
  - `extractBindings()` helper for nested Let/LetRec declarations
  - Handles module elaboration structure: `let f1 = ... in (let f2 = ... in Var(...))`
  - Properly terminates at Var expressions

- **CLI Integration** (`cmd/ailang/main.go`, ~30 LOC)
  - Module runtime replaces "not yet supported" error
  - Pre-loads modules from pipeline result
  - Entrypoint validation with arity checking
  - Error messages show available exports

- **Entrypoint Helpers** (`internal/runtime/entrypoint.go`, 37 LOC)
  - `GetArity(val)` - Returns function parameter count
  - `GetExportNames(inst)` - Lists module exports for error messages

#### Architecture Highlights

**Key Design Decisions**:
1. **Pipeline Integration**: Runtime receives pre-elaborated modules from pipeline (no duplicate work)
2. **Recursive Extraction**: `extractBindings()` traverses nested Let structures from elaboration
3. **Preloading Pattern**: Modules injected into loader cache via `PreloadModule()`
4. **Thread-Safe Init**: `sync.Once` ensures each module evaluates exactly once
5. **Encapsulation**: Only exported bindings accessible across modules

**Data Flow**:
```
Parse ‚Üí Type-check ‚Üí Elaborate ‚Üí Pipeline
                                    ‚Üì
                              Convert to LoadedModules
                                    ‚Üì
                              Runtime.PreloadModule()
                                    ‚Üì
                              Runtime.LoadAndEvaluate()
                                    ‚Üì
                              Extract bindings recursively
                                    ‚Üì
                              Filter exports
                                    ‚Üì
                              Validate entrypoint ‚úÖ
```

#### Test Results

**Unit Tests**: ‚úÖ 18/18 passing
- Module instance creation and export access (7 tests)
- Runtime caching and management (5 tests)
- Global resolver with encapsulation (6 tests)

**Integration Tests**: ‚ö†Ô∏è 2/7 passing
- CircularImport detection ‚úÖ
- NonExistentModule error ‚úÖ
- SimpleModule, ModuleWithImport, etc. ‚ö†Ô∏è (loader path resolution issues, non-blocking)

**End-to-End Validation**: ‚úÖ Working
```bash
$ ailang --entry main run examples/test_runtime_simple.ail
‚úì: Module execution ready
  Entrypoint:  main
  Arity:       0
  Module:      examples/test_runtime_simple

Note: Function invocation coming soon (Phase 5 completion)
```

#### Known Limitations

1. **Function Invocation Not Implemented**
   - Entrypoints validated but not yet executed
   - Arity checking works ‚úÖ
   - Export resolution works ‚úÖ
   - Actual function calling deferred to Phase 5

2. **stdlib Modules Fail**
   - stdlib uses builtin stubs (`_io_print`, etc.)
   - Requires special handling for Lit expressions
   - Planned for Phase 5

3. **CLI Flag Order**
   - `--entry` must come before `run` command
   - Use: `ailang --entry <name> run <file>`
   - Known CLI parsing quirk, low priority fix

#### Files Changed

**New Files**:
- `internal/runtime/module.go` (164 LOC) - ModuleInstance
- `internal/runtime/runtime.go` (210 LOC) - ModuleRuntime with cycle detection
- `internal/runtime/resolver.go` (120 LOC) - Global resolver
- `internal/runtime/entrypoint.go` (37 LOC) - Helper functions
- `internal/runtime/module_test.go` (239 LOC) - Module tests
- `internal/runtime/runtime_test.go` (140 LOC) - Runtime tests
- `internal/runtime/resolver_test.go` (212 LOC) - Resolver tests
- `internal/runtime/integration_test.go` (249 LOC) - Integration tests
- `tests/runtime_integration/*.ail` (3 test modules)

**Modified Files**:
- `internal/pipeline/pipeline.go` (+60 LOC) - Added Modules map to Result
- `internal/loader/loader.go` (+15 LOC) - Added Preload() method
- `cmd/ailang/main.go` (+30 LOC) - CLI integration

#### Technical Metrics

- **Total LOC**: ~1,594 (implementation + tests)
- **Test Coverage**: 18/18 unit tests passing
- **Integration Tests**: 2/7 passing (loader issues non-blocking)
- **Timeline**: On schedule (Phases 1-4 complete)

#### Next Steps (Phase 5 - Pending)

1. **Function Invocation** - Connect to evaluator API, call entrypoints, print results
2. **stdlib Support** - Handle builtin functions and Lit expressions
3. **Example Verification** - Test all examples, update README
4. **Documentation** - Update CLAUDE.md, create execution guide

---

## [v0.1.0] - 2025-10-02

### üéØ MVP Release: Type System Complete

**Major Achievement**: First complete type system MVP with 27,610 LOC of Go implementation.

#### Added - Documentation & Polish (~2,500 lines)

**Documentation Suite**:
- **README.md**: Complete restructure for v0.1.0 with honest status, "What Works" section, FAQ
- **docs/LIMITATIONS.md**: NEW - 400+ lines comprehensive limitations guide
- **docs/METRICS.md**: NEW - 300+ lines project statistics and metrics
- **RELEASE_NOTES_v0.1.0.md**: NEW - 500+ lines comprehensive release notes
- **docs/SHOWCASE_ISSUES.md**: NEW - 350+ lines parser/execution limitations
- **examples/STATUS.md**: NEW - Complete inventory of 42 example files
- **examples/README.md**: NEW - User guide for examples
- **CLAUDE.md**: UPDATED - Current v0.1.0 status, accurate component breakdown

**Showcase Examples** (4 new files):
- `examples/showcase/01_type_inference.ail` - Type inference demonstration
- `examples/showcase/02_lambdas.ail` - Lambda composition
- `examples/showcase/03_type_classes.ail` - Type class polymorphism
- `examples/showcase/04_closures.ail` - Closures and captured environments

**Development Tools**:
- `tools/audit-examples.sh`: Automated example testing and categorization

**Warning Headers**: Added to 3 module examples that type-check but can't execute

#### Status Summary

**‚úÖ Complete (27,610 LOC)**:
- Hindley-Milner type inference (7,291 LOC)
- Type classes with dictionary-passing (linked system, ~3,000 LOC)
- Lambda calculus & closures (3,712 LOC)
- Professional REPL with debugging (1,351 LOC)
- Module type-checking (1,030 LOC module + 503 LOC loader)
- Parser with operator precedence (2,656 LOC)
- Structured error reporting with JSON schemas (657 LOC)

**‚ö†Ô∏è Known Limitation**:
- Module files type-check ‚úÖ but cannot execute ‚ùå (runtime in v0.2.0)
- Non-module `.ail` files execute successfully ‚úÖ
- REPL fully functional ‚úÖ

**Examples**:
- 12 working (25.5%)
- 3 type-check only (6.4%)
- 27 broken (57.4%)
- 6 skipped (test/demo files)

**Test Coverage**: 24.8% (10,559 LOC of tests)

#### Changed

- README.md version badge: v0.0.12 ‚Üí v0.1.0
- Implementation status: Updated to "Type System Complete"
- Test coverage badge: 31.3% ‚Üí 24.8% (accurate count)

#### Fixed

- Documentation now accurately reflects v0.1.0 capabilities
- Example status now honestly documented
- Module execution limitation clearly communicated

### v0.2.0 Roadmap (3.5-4.5 weeks)

**M-R1**: Module Execution Runtime (~1,200 LOC, 1.5-2 weeks)
**M-R2**: Algebraic Effects Foundation (~800 LOC, 1-1.5 weeks)
**M-R3**: Pattern Matching (~600 LOC, 1 week)

---

## [v0.0.12] - 2025-10-02

### Added - M-S1 Complete: Stdlib Foundation (~200 LOC)

**‚úÖ M-S1 MILESTONE ACHIEVED: All 5 stdlib modules type-check successfully**

#### Equation-Form Export Syntax (~30 LOC)
**Parser enhancement for thin wrapper functions:**

**New Syntax** (`internal/parser/parser.go`, lines 655-683):
- Added equation-form function syntax: `export func f(x: T) -> R = expr`
- Alternative to block-form: `export func f(x: T) -> R { expr }`
- Wraps expression in Block for uniform AST handling

**Implementation**:
```go
if p.peekTokenIs(lexer.ASSIGN) {
    p.nextToken() // move to ASSIGN
    p.nextToken() // move past ASSIGN
    body := p.parseExpression(LOWEST)
    fn.Body = &ast.Block{Exprs: []ast.Expr{body}, Pos: body.Position()}
}
```

**Use Case**: Thin wrappers around builtins (std/io module)
```ailang
export func println(s: string) -> () ! {IO} = _io_println(s)
export func print(s: string) -> () ! {IO} = _io_print(s)
export func readLine() -> string ! {IO} = _io_readLine()
```

---

#### Polymorphic ++ Operator (~170 LOC)
**Type checker enhancement for list and string concatenation:**

**Typing Rule**: `xs:[Œ±] ‚àß ys:[Œ±] ‚áí xs++ys:[Œ±]`

**Implementation** (`internal/types/typechecker_core.go`, lines 1155-1250):
- Decision tree for polymorphic concatenation:
  1. If at least one operand is a concrete list ‚Üí list concat
  2. If at least one operand is a concrete string ‚Üí string concat
  3. If both are type variables ‚Üí default to list concat (more polymorphic)
  4. Otherwise ‚Üí fallback to string concat

**Type Unification** (`internal/types/unification.go`, lines 125-143):
- Added TCon compatibility for both `TCon("String")` and `TCon("string")` (case variations)
- Proper unification when one operand is concrete type, other is type variable

**Examples Working**:
```ailang
"hello" ++ " world"        -- String concat
[1, 2] ++ [3, 4]           -- List concat: [Int]
[] ++ []                   -- Polymorphic: [Œ±]
concat xs ys = xs ++ ys    -- Infers: [Œ±] -> [Œ±] -> [Œ±]
```

---

#### Stdlib Modules Complete (All 5 type-check)

**stdlib/std/io.ail** (3 exports):
- `print(s: string) -> () ! {IO}` - Print without newline
- `println(s: string) -> () ! {IO}` - Print with newline
- `readLine() -> string ! {IO}` - Read from stdin
- Uses equation-form syntax for thin wrappers

**stdlib/std/list.ail** (10 exports):
- `map, filter, foldl, foldr, length, head, tail, reverse, concat, zip`
- ++ operator now works correctly for list concatenation

**stdlib/std/option.ail** (6 exports):
- `map, flatMap, getOrElse, isSome, isNone, filter`

**stdlib/std/result.ail** (6 exports):
- `map, mapErr, flatMap, isOk, isErr, unwrap`

**stdlib/std/string.ail** (7 exports):
- `length, substring, toUpper, toLower, trim, compare, find`

---

### Changed

**Parser Function Declaration**:
- Extended to support both block-form and equation-form syntax
- Equation-form used for simple wrapper functions
- Block-form used for multi-statement functions

**Type Checker**:
- Enhanced ++ operator to work polymorphically for both lists and strings
- Improved type variable unification for binary operators

---

### Fixed

**List Concatenation**: ++ operator now properly type-checks with polymorphic element types
**String Concatenation**: Works when one operand is a type variable
**Type Unification**: TCon case variations ("String" vs "string") now handled correctly

---

### Technical Details

**Files Modified**:
- `internal/parser/parser.go` (+30 LOC): Equation-form export syntax
- `internal/types/typechecker_core.go` (+95 LOC): Polymorphic ++ operator
- `internal/types/unification.go` (+18 LOC): TCon compatibility
- `stdlib/std/io.ail` (rewritten): 3 equation-form exports

**Test Results**:
- ‚úÖ All 5 stdlib modules type-check without errors
- ‚úÖ All existing tests pass (no regressions)
- ‚úÖ Examples type-check successfully (option_demo, block_demo, stdlib_demo)

**Known Limitations**:
- ‚ö†Ô∏è Example execution: Runner doesn't call `main()` in module files (type-checking works)
- ‚ö†Ô∏è No `_io_debug` builtin yet (deferred)

**Metrics**:
- Total new code: ~200 LOC (130 implementation + 70 stdlib)
- Stdlib modules: 5/5 complete (100%)
- M-S1 Status: ‚úÖ **COMPLETE**

---

#### Minimal Viable Runner (MVF) - Partial Implementation (~250 LOC)
**Entrypoint resolution and argument decoding foundation for v0.2.0:**

**‚úÖ What Works**:
1. **Argument Decoder Package** (`internal/runtime/argdecode/argdecode.go`, ~200 LOC)
   - Type-directed JSON‚ÜíValue conversion
   - Supports: null‚Üí(), number‚Üíint/float, string, bool, array‚Üílist, object‚Üírecord
   - Handles type variables with simple inference
   - Structured errors: `DecodeError` with Expected/Got/Reason

2. **CLI Flags** (3 new flags in `cmd/ailang/main.go`):
   - `--entry <name>` - Entrypoint function name (default: "main")
   - `--args-json '<json>'` - JSON arguments to pass (default: "null")
   - `--print` - Print return value even for unit (default: true)

3. **Entrypoint Resolution Logic**:
   - Looks up function in `result.Interface.Exports`
   - Validates it's a function type (`TFunc2`)
   - Supports 0 or 1 parameters (v0.1.0 constraint)
   - Rejects multi-arg functions with clear error
   - Lists available exports if entrypoint not found

4. **Demo Files** (3 examples in `examples/demos/`):
   - `hello_io.ail` - IO effects demo
   - `adt_pipeline.ail` - ADT/Option usage
   - `effects_pure.ail` - Pure list operations

**‚ùå What's NOT Implemented**:
- Module-level evaluation (no function values extracted)
- Actual entrypoint execution (blocked on module evaluation)
- Effect handlers (IO, etc.)
- Demo output and golden files (blocked on execution)

**Reason**: Module execution requires evaluating all bindings in dependency order, building runtime environments with closures, and handling effects. This is a significant feature planned for v0.2.0.

**Current Behavior**:
```bash
$ ailang run examples/demos/hello_io.ail

Note: Module evaluation not yet supported
  Entrypoint:  main
  Type:        () -> Œ±3 ! {...Œµ4}
  Parameters:  0
  Decoded arg: ()

What IS working:
  ‚úì Interface extraction and freezing
  ‚úì Entrypoint resolution
  ‚úì Argument type checking and JSON decoding
```

**Usage Examples**:
```bash
ailang run file.ail                                    # Zero-arg main()
ailang --entry=demo run file.ail                       # Zero-arg demo()
ailang --entry=process --args-json='42' run file.ail   # Single-arg
```

**Files Modified**:
- `internal/runtime/argdecode/argdecode.go` (+200 LOC): New package
- `cmd/ailang/main.go` (+60 LOC): CLI flags + entrypoint resolution
- `examples/demos/*.ail` (+3 files): Demo examples

**Value Delivered**:
- Foundation for v0.2.0 module execution
- Type-safe argument handling ready
- Clear UX messaging about what's working vs. coming
- Demo files ready for when evaluation lands

---

## [v0.0.11] - 2025-10-02

### Fixed - M-S1 Blockers: Cross-Module Constructors & Multi-Statement Functions (~224 LOC)

**CRITICAL FIXES unblocking realistic stdlib examples:**

#### Blocker 1: Cross-Module Constructor Resolution (~74 LOC)
**Problem**: Imported constructors like `Some` from `std/option` couldn't be used because the type checker didn't know their signatures.

**Root Cause**: Constructor factory functions were added to `globalRefs` for elaboration but NOT to `externalTypes` for type checking.

**Solution** (`internal/pipeline/pipeline.go`):
- Lines 452-497: When importing constructors, build factory function type and add to `externalTypes`
- Factory type: `TFunc2{Params: FieldTypes, Return: ResultType}` with `EffectRow: nil` (pure)
- Lines 700-739: Added `extractTypeVarsFromType()` helper to extract type variables for polymorphism
- Example: `Some: a -> Option[a]`, `None: Option[a]`

**Test Results**:
- ‚úÖ `examples/option_demo.ail` now type-checks (was: undefined make_Option_Some)
- ‚úÖ `stdlib/std/list.ail` constructor imports work
- ‚úÖ All existing tests pass

**Note**: `extractTypeVarsFromType()` handles both old (TApp/TVar) and new (TFunc2/TVar2) types for defensive compatibility. Should be cleaned up to use only TVar2 consistently.

---

#### Blocker 2: Multi-Statement Function Bodies (~150 LOC)
**Problem**: Parser only supported single-expression function bodies. Couldn't write realistic functions with multiple statements:
```ailang
func main() {
  let x = 1;      -- ‚ùå Parse error: unexpected ;
  let y = 2;
  x + y
}
```

**Root Cause**: Function bodies parsed as single expression via `parseExpression(LOWEST)`. No support for semicolon-separated statements.

**Solution**:
1. **AST** (`internal/ast/ast.go`, lines 228-243): Added `Block` node for sequential expressions
2. **Parser** (`internal/parser/parser.go`):
   - Line 663: Changed to call `parseFunctionBody()` instead of `parseExpression()`
   - Lines 673-721: New `parseFunctionBody()` parses semicolon-separated expressions
   - Lines 856-956: Modified `parseRecordLiteral()` to distinguish blocks from record literals
3. **Elaboration** (`internal/elaborate/elaborate.go`):
   - Lines 524-525: Added `Block` case to `normalize()`
   - Lines 786-831: New `normalizeBlock()` converts blocks to nested `Let` expressions
   - Transformation: `{ e1; e2; e3 }` ‚Üí `let _block_0 = e1 in let _block_1 = e2 in e3`

**Test Results**:
- ‚úÖ Single expression bodies still work
- ‚úÖ Multi-statement blocks with semicolons work
- ‚úÖ Blocks without trailing semicolon work
- ‚úÖ Empty blocks work: `{}`
- ‚úÖ Mixed let statements and expressions work
- ‚ö†Ô∏è Module files with blocks have elaboration issue (separate bug, non-blocking)

**Examples**:
- `examples/block_demo.ail` demonstrates multi-statement functions

**Known Issue**: Files with `module` declarations + blocks fail with "normalization received nil expression". Works fine without module declaration. Needs investigation but doesn't block core functionality.

---

**Combined Impact**: Both blockers resolved! Stdlib modules can now:
- Import and use constructors from other modules
- Write realistic functions with multiple statements and side effects
- Use pattern matching with imported types

**Files Changed**:
- `internal/pipeline/pipeline.go` (+74 LOC): Constructor type resolution
- `internal/ast/ast.go` (+16 LOC): Block AST node
- `internal/parser/parser.go` (+130 LOC): Block parsing
- `internal/elaborate/elaborate.go` (+48 LOC): Block elaboration
- `examples/block_demo.ail` (+17 LOC): Multi-statement example

**Total**: ~224 new LOC, ~5 hours work (Blocker 1: 2 hours, Blocker 2: 3 hours)

---

### Added - M-S1 Parts A & B: Import System & Builtin Visibility (~700 LOC)

#### Part A: Export System for Types and Constructors (~400 LOC)
**Complete end-to-end import resolution for types, constructors, and functions:**

**Loader Enhancement** (`internal/loader/loader.go`)
- Added `Types map[string]*ast.TypeDecl` to `LoadedModule` for exported type declarations
- Added `Constructors map[string]string` for constructor name ‚Üí type name mapping
- Created `buildTypes()` function to extract type declarations from AST (checks both `Decls` and `Statements`)
- Updated `GetExport()` to return `(nil, nil)` for types and constructors (not errors, just non-functions)
- Enhanced error reporting to list available types and constructors with labels

**Elaborator Updates** (`internal/elaborate/elaborate.go`)
- Added `AddBuiltinsToGlobalEnv()` method to inject all builtin functions into elaborator's global scope
- Modified import resolution in `ElaborateFile()` to skip types/constructors (handled later in pipeline)
- Builtins now available during elaboration, not just linking

**Interface Builder** (`internal/iface/iface.go`, `internal/iface/builder.go`)
- Added `Types map[string]*TypeExport` to `Iface` struct
- Created `TypeExport` struct with `Name` and `Arity` fields
- Enhanced `BuildInterfaceWithTypesAndConstructors()` to extract types from AST file
- Constructors extracted from `AlgebraicType.Constructors` (not `Variants`)
- Helper methods: `AddType()`, `GetType()`

**Pipeline Integration** (`internal/pipeline/pipeline.go`)
- Updated import resolution to check `GetType()` and `GetConstructor()` in addition to `GetExport()`
- Constructors map to `$adt.make_{TypeName}_{CtorName}` factory functions
- Added automatic injection of `$builtin` module exports into all modules' `externalTypes`
- Builtins now available globally without explicit imports
- Added `AddBuiltinsToGlobalEnv()` calls for both REPL and module compilation paths

**Module Linker** (`internal/link/module_linker.go`)
- Enhanced `BuildGlobalEnv()` to handle three symbol types: functions, types, constructors
- Types: Skip adding to environment (handled by type checker)
- Constructors: Add with `$adt` module reference for factory functions
- Functions: Add with original module reference
- Improved error reporting with separate listings for types and constructors
- Added `continue` statements to skip further processing for types/constructors

**Working Examples:**
```ailang
// Type and constructor imports work
import stdlib/std/option (Option, Some, None)

// Constructor usage (pending $adt runtime)
let x = Some(42)
match x {
  Some(n) => n,
  None => 0
}
```

**Test Results:**
- ‚úÖ Constructor imports: `import stdlib/std/option (Some)` type-checks
- ‚úÖ Type imports: `import stdlib/std/option (Option)` type-checks
- ‚úÖ Function imports: `import stdlib/std/option (getOrElse)` works
- ‚úÖ All existing tests pass (no regressions)
- ‚è≥ Constructor evaluation pending `$adt` runtime implementation

---

#### Part B: Builtin Type Visibility (~300 LOC)
**Made string and IO primitives available to all modules:**

**Builtin Module Enhancement** (`internal/link/builtin_module.go`)
- Added `handleStringPrimitive()` function for 7 string builtins:
  - `_str_len: String -> Int` (UTF-8 rune count)
  - `_str_slice: String -> Int -> Int -> String` (rune-based substring)
  - `_str_compare: String -> String -> Int` (lexicographic, returns -1/0/1)
  - `_str_find: String -> String -> Int` (first occurrence, rune index)
  - `_str_upper: String -> String` (Unicode-aware uppercase)
  - `_str_lower: String -> String` (Unicode-aware lowercase)
  - `_str_trim: String -> String` (Unicode whitespace)
- Added `handleIOBuiltin()` function for 3 IO builtins:
  - `_io_print: String -> Unit ! {IO}` (no newline)
  - `_io_println: String -> Unit ! {IO}` (with newline)
  - `_io_readLine: Unit -> String ! {IO}` (read from stdin)
- Proper effect row representation: `&types.Row{Kind: types.EffectRow, Labels: {"IO": ...}}`
- All builtins registered in `$builtin` module interface

**Pipeline Integration** (`internal/pipeline/pipeline.go`)
- Automatic injection of `$builtin` module into every module's compilation context
- Builtins available in `externalTypes` for type checking
- Builtins available in `globalRefs` for elaboration
- No explicit imports required - builtins are globally visible

**Test Results:**
- ‚úÖ `stdlib/std/string.ail` type-checks successfully (7 exports)
- ‚è≥ `stdlib/std/io.ail` has parse errors (inline function syntax limitation)
- ‚úÖ String primitives: length, substring, toUpper, toLower, trim, compare, find
- ‚úÖ Effect tracking: IO functions properly annotated with `! {IO}`

**Example Working:**
```ailang
module stdlib/std/string

export pure func length(s: string) -> int { _str_len(s) }
export pure func toUpper(s: string) -> string { _str_upper(s) }
// ... all 7 functions type-check correctly
```

---

### Added - Parser Fix + Stdlib Foundation (~300 LOC)

#### Generic Type Parameter Fix (`internal/parser/parser.go`)
**1-line fix unblocks generic functions in modules:**

**Issue Discovered**: Generic function syntax failed during stdlib implementation
```ailang
export func map[a, b](f: (a) -> b, xs: [a]) -> [b]  -- ‚ùå Parser error
```

**Root Cause**: After `parseTypeParams()` parsed `[a, b]`, parser was positioned AT `(` but code called `expectPeek(LPAREN)` expecting to PEEK at next token.

**Fix Applied** (lines 554-582):
- Check `hasTypeParams` flag to determine token positioning
- If generic: `curTokenIs(LPAREN)` (already at opening paren)
- If non-generic: `expectPeek(LPAREN)` (need to advance)
- Handles all cases: `func[T]()`, `func[T](x)`, `func()`, `func(x)`

**Impact**: ‚úÖ Generic function declarations now parse correctly in module files

---

#### String & IO Builtins Implementation (~150 LOC)

**7 String Primitives** (`internal/eval/builtins.go`):
- `_str_len(s: string) -> int` - UTF-8 aware length (rune count, not bytes)
- `_str_slice(s: string, start: int, end: int) -> string` - Substring with rune indices
- `_str_compare(a: string, b: string) -> int` - Lexicographic comparison (-1, 0, 1)
- `_str_find(s: string, sub: string) -> int` - First occurrence index (rune-based)
- `_str_upper(s: string) -> string` - Unicode-aware uppercase
- `_str_lower(s: string) -> string` - Unicode-aware lowercase
- `_str_trim(s: string) -> string` - Unicode whitespace trimming

**3 IO Primitives** (effectful: `IsPure: false`):
- `_io_print(s: string) -> ()` - Print without newline
- `_io_println(s: string) -> ()` - Print with newline
- `_io_readLine() -> string` - Read line from stdin (stub for v0.1.0)

**Design Principles**:
- UTF-8 safe: All string operations use rune indices, not byte indices
- Deterministic: No locale-dependent behavior
- Pure primitives: String functions are pure (IsPure: true)
- Effectful IO: IO functions marked impure (IsPure: false) for future effect tracking

**Updated CallBuiltin()** to handle:
- 0-argument functions: `_io_readLine()`
- 3-argument functions: `_str_slice(s, start, end)`
- New type signatures: `String -> Int`, `String -> String`, `String -> Unit`

---

#### Stdlib Modules Prepared (Ready for Deployment)

**5 Stdlib Modules Written** (~360 LOC AILANG code):
- `std_list.ail` (~180 LOC): map, filter, foldl, foldr, length, head, tail, reverse, concat, zip
- `std_option.ail` (~50 LOC): Option[a], map, flatMap, getOrElse, isSome, filter
- `std_result.ail` (~70 LOC): Result[a,e], map, mapErr, flatMap, isOk, unwrap
- `std_string.ail` (~40 LOC): length, concat, substring, join, toUpper, toLower, trim
- `std_io.ail` (~20 LOC): print, println, readLine, debug with `! {IO}` effects

**Status**: ‚ö†Ô∏è BLOCKED - Parser doesn't support pattern matching inside function bodies

**Blocker Details**:
- ‚úÖ Pattern matching works at top-level: `match Some(42) { ... }` (proven)
- ‚ùå Pattern matching fails inside functions: `export func f() { match x { ... } }` (broken)
- Error: "expected =>, got ] instead" when parsing list patterns `[]`, `[x, ...rest]`
- Affects: ALL stdlib modules (they use pattern matching extensively)

**Next Steps**: Fix pattern matching in function bodies (~1-2 days parser work)

---

### Fixed

**Parser Token Positioning** (`internal/parser/parser.go:554-582`)
- Generic type parameters now work in function declarations
- Correctly handles: `func name[T]()`, `func name[T](x: T)`, `func name()`, `func name(x: int)`
- Test case verified: `export func getOrElse[a](opt: Option[a], d: a) -> a` parses

---

### Changed

**CallBuiltin Signature Support** (`internal/eval/builtins.go`)
- Added 0-argument builtin handling (for `_io_readLine`)
- Added 3-argument builtin handling (for `_str_slice`)
- Extended type signatures: `String -> Int`, `String -> String`, `String -> Unit`

---

### Technical Details

**Files Modified**:
- `internal/parser/parser.go` (~30 LOC): Generic function fix
- `internal/eval/builtins.go` (~150 LOC): String and IO primitives
- Total: ~180 LOC implementation

**Stdlib Modules Created** (not yet deployable):
- 5 modules (~360 LOC) written and ready
- Blocked pending pattern matching parser fix

**Test Coverage**: Generic function test case passes, builtins compile and register

**Metrics**:
- Builtins: 10 new primitives (7 string + 3 IO)
- Parser fix: Unblocks generic functions in modules
- Stdlib: Ready to deploy once parser fixed

---

## [v0.0.10] - 2025-10-01

### Added - M-P4: Effect System (Type-Level) (~1,060 LOC)

#### Complete Type-Level Effect Tracking
**Full pipeline integration from parsing through type checking:**

**Effect Syntax Parsing** (`internal/parser/parser.go`, `internal/parser/effects_test.go`)
- Function declarations: `func f() -> int ! {IO, FS}`
- Lambda expressions: `\x. body ! {IO}`
- Type annotations: `(int) -> string ! {FS}`
- Comprehensive validation against 8 canonical effects: IO, FS, Net, Clock, Rand, DB, Trace, Async
- Error codes: PAR_EFF001_DUP (duplicates), PAR_EFF002_UNKNOWN (unknown effect with suggestions)
- Fixed BANG operator precedence to allow `! {Effects}` syntax
- 17 parser tests passing ‚úÖ

**Effect Elaboration Helpers** (`internal/types/effects.go`, `internal/types/effects_test.go`)
- `ElaborateEffectRow()`: Converts AST effect strings to normalized `*Row` with deterministic alphabetical sorting
- `UnionEffectRows()`: Merges two effect rows (e.g., `{IO} ‚à™ {FS} = {FS, IO}`)
- `SubsumeEffectRows()`: Checks effect subsumption (a ‚äÜ b) for capability checking
- `EffectRowDifference()`: Computes missing effects for error messages
- `FormatEffectRow()`: Pretty-prints effect rows as `! {IO, FS}`
- `IsKnownEffect()`: Validates effect names against canonical set
- Purity sentinel: `nil` effect row = pure function (not empty-but-non-nil)
- Closed rows only: `Tail = nil` always (no row polymorphism in v0.1.0)
- 29 elaboration tests passing ‚úÖ

**Type Checking Integration** (`internal/elaborate/elaborate.go`, `internal/types/typechecker_core.go`)
- Effect annotations stored in `Elaborator.effectAnnots` map (Core node ID ‚Üí effect names)
- Validation during elaboration using `ElaborateEffectRow()`
- Effect annotations thread to `CoreTypeChecker.effectAnnots`
- Modified `inferLambda()` to use explicit effect annotations when present
- Falls back to body effect inference when no annotation provided
- Annotations flow: AST ‚Üí Elaboration ‚Üí Type Checking ‚Üí TFunc2.EffectRow
- Existing effect infrastructure leveraged (effects already propagate through `inferApp`, `inferIf`, etc.)

**Files Modified:**
- `internal/parser/parser.go` (+150 LOC): Effect annotation parsing with validation
- `internal/parser/effects_test.go` (+360 LOC new file): 17 test cases
- `internal/types/effects.go` (+170 LOC new file): Effect row elaboration helpers
- `internal/types/effects_test.go` (+280 LOC new file): 29 test cases
- `internal/elaborate/elaborate.go` (+30 LOC): Effect annotation storage
- `internal/types/typechecker_core.go` (+40 LOC): Effect annotation integration
- Total: ~1,060 LOC (700 LOC core + 360 LOC tests)

**Key Design Decisions:**
1. **Purity Sentinel**: `nil` effect row = pure, never empty-but-non-nil
2. **Deterministic Normalization**: All effect labels sorted alphabetically
3. **Closed Rows**: No row polymorphism in v0.1.0 (Tail = nil always)
4. **Canonical Effects**: IO, FS, Net, Clock, Rand, DB, Trace, Async (8 total)
5. **Type-Level Only**: No runtime effect enforcement (deferred to v0.2.0)
6. **Effects in Type System**: Stored in TFunc2.EffectRow, not Core Lambda AST

**Test Results:**
- ‚úÖ 17 parser tests passing (effect syntax, validation, error messages)
- ‚úÖ 29 elaboration tests passing (ElaborateEffectRow, unions, subsumption)
- ‚úÖ All existing type checker tests passing
- ‚úÖ Full test suite passing (parser, elaboration, types)

**Outcome:** M-P4 effect system foundation is COMPLETE and ready for use! The infrastructure for type-level effect tracking is in place and working.

**Deferred to v0.2.0:**
- Runtime effect handlers and capability passing
- Effect polymorphism (row polymorphism: `! {IO | r}`)
- Pure function verification at compile time

---

### Added - M-P3: Pattern Matching Foundation with ADT Runtime

#### Minimal ADT Runtime Implementation (~600 LOC)
**Complete algebraic data type support with pattern matching:**

**TaggedValue Runtime** (`internal/eval/value.go`, `internal/eval/eval_core.go`)
- Runtime representation for ADT constructors with `TypeName`, `CtorName`, `Fields`
- Pretty-printing: `None`, `Some(42)`, `Ok(Some(99))`
- Helper functions: `isTag()` for constructor matching, `getField()` for field extraction
- Full test coverage: 16 test cases across 3 test suites

**$adt Synthetic Module** (`internal/link/builtin_module.go`)
- Factory function synthesis: `make_<TypeName>_<CtorName>` pattern
- Deterministic ordering (sorted by type name, then constructor name)
- Automatic registration from all loaded module interfaces
- Example: `make_Option_Some`, `make_Option_None`

**Type Declaration Elaboration** (`internal/elaborate/elaborate.go`)
- `normalizeTypeDecl()` converts AST type declarations to runtime constructors
- Tracks type parameters, field types, and arity
- Distinguishes local vs imported constructors
- Constructor tracking in elaborator with `constructors` map

**Constructor Expression Support**
- Non-nullary: `Some(42)` ‚Üí `VarGlobal("$adt", "make_Option_Some")(42)`
- Nullary: `None` ‚Üí `VarGlobal("$adt", "make_Option_None")` (direct value, not function call)
- Automatic elaboration in `normalizeFuncCall()` and identifier normalization
- Factory resolution with arity-aware handling (nullary returns value, others return function)

**Constructor Pattern Matching** (`internal/eval/eval_core.go`)
- Extended `matchPattern()` to handle `ConstructorPattern`
- Recursive field pattern matching with variable binding
- Constructor name and arity validation
- Full destructuring support: `Some(x)`, `Ok(Some(y))`, `None`

**Pipeline Integration** (`internal/pipeline/pipeline.go`)
- Constructors extracted from elaborator and added to module interfaces
- Factory types registered in `externalTypes` before type checking
- Used TFunc2/TVar2 (new type system) for unification compatibility
- Monomorphic result types (e.g., `Option` not `Option[Int]`) due to TApp limitation

**Interface Builder Enhancement** (`internal/iface/builder.go`)
- `BuildInterfaceWithConstructors()` accepts constructor information
- Constructors included in module interface for imports
- Constructor schemes with field types and result types

**Working Examples**:
```ailang
type Option[a] = Some(a) | None

match Some(42) {
  Some(n) => n,
  None => 0
}
-- Output: 42 ‚úÖ

match None {
  Some(n) => n,
  None => 999
}
-- Output: 999 ‚úÖ
```

#### Key Technical Decisions
1. **No new Core IR nodes**: Constructor calls use `VarGlobal("$adt", "make_*")` pattern
2. **Runtime factory functions**: $adt module populated at link time from interfaces
3. **Direct evaluation**: Match expressions evaluate without lowering pass
4. **Deterministic**: Factory names sorted, stable digest computation
5. **Nullary handling**: Returns TaggedValue directly (not wrapped in function)
6. **Type system hybrid**: TCon (old) + TFunc2/TVar2 (new) for unification compatibility

#### Files Changed
- `internal/eval/value.go`: Added TaggedValue type (~25 LOC)
- `internal/eval/eval_core.go`: Added isTag, getField helpers, constructor pattern matching (~180 LOC)
- `internal/link/builtin_module.go`: Added RegisterAdtModule (~120 LOC)
- `internal/link/module_linker.go`: Added GetLoadedModules method
- `internal/elaborate/elaborate.go`: Added normalizeTypeDecl, constructor tracking, nullary handling (~150 LOC)
- `internal/pipeline/compile_unit.go`: Added ConstructorInfo, Constructors field (~25 LOC)
- `internal/iface/builder.go`: Added BuildInterfaceWithConstructors (~60 LOC)
- `internal/pipeline/pipeline.go`: Added constructor pipeline wiring, TFunc2/TVar2 factory types (~120 LOC)
- `internal/link/resolver.go`: Enhanced resolveAdtFactory with arity lookup (~60 LOC)

#### Test Coverage
- 16 test cases: TaggedValue, isTag, getField functions
- End-to-end examples: `examples/adt_simple.ail`
- Both nullary and non-nullary constructors verified

### Known Limitations (Future Work)
- ‚ö†Ô∏è Let bindings with constructors have elaboration bug ("normalization received nil expression")
- ‚ö†Ô∏è Result types are monomorphic (`Option` vs `Option[Int]`) - TApp not supported in unifier yet
- ‚ö†Ô∏è No exhaustiveness checking for pattern matches
- ‚ö†Ô∏è No guard evaluation (guards are parsed but not evaluated)
- ‚ö†Ô∏è Type system migration incomplete: Mix of old (TFunc, TVar) and new (TFunc2, TVar2) types

### Technical Details
- Total implementation: ~600 LOC (3 days, as estimated)
- Pattern matching: Tuples, literals, variables, wildcards, constructors all work
- Type checking: Polymorphic factory types with proper unification
- Runtime: TaggedValue representation with arity-aware factory resolution
- Deterministic: All constructor names sorted, stable module digests

### Migration Notes
- ADT runtime is fully backward compatible
- Type declarations now elaborate to runtime constructors automatically
- Constructor expressions work in pattern contexts and regular code
- $adt module is synthetic and doesn't require explicit imports

## [v0.0.9] - 2025-09-30

### Changed - Upgraded to Go 1.22

**Security & Performance Upgrade:**
- Upgraded from Go 1.19 ‚Üí Go 1.22.12 (Go 1.19 EOL since Sept 2023)
- Updated `golang.org/x/text` from v0.20.0 ‚Üí v0.21.0
- Updated CI workflow to use Go 1.22
- All tests and linting pass with new version

**Benefits:**
- Security patches for 2+ years of vulnerabilities
- 1-3% CPU performance improvement
- ~1% memory reduction
- For-loop variable scoping fix (prevents common bugs)
- Enhanced HTTP routing, better generics support

**Files Changed:**
- `go.mod`: go 1.22, golang.org/x/text v0.21.0
- `.github/workflows/ci.yml`: go-version: '1.22'
- `.github/workflows/build.yml`: go-version: '1.22' (fixes Windows builds)
- `.github/workflows/release.yml`: go-version: '1.22'
- `go.sum`: Updated checksums

### Fixed - Windows Golden File Tests

**Cross-platform Test Compatibility:**
- Fixed Windows test failures in `TestLiterals` subtests
- Issue: Golden files checked out with CRLF line endings on Windows but comparison used raw bytes
- Solution: Normalize line endings (CRLF ‚Üí LF) in both `want` and `got` strings before comparison
- Updated `goldenCompare()` function in `internal/parser/testutil.go`
- All platforms (Linux, macOS, Windows) now pass golden file tests consistently

### Added - M-P2 Lock-In: Type System Hardening

#### Coverage Regression Protection
- Per-package coverage gates in Makefile (`cover-parser`, `gate-parser`, `cover-lexer`, `gate-lexer`)
- Parser baseline: 70% coverage (up from 69%)
- Lexer baseline: 57% coverage
- CI workflow enforces coverage thresholds on every push
- Golden drift protection: CI fails if golden files change without `ALLOW_GOLDEN_UPDATES=1`
- New make target: `check-golden-drift` validates golden file stability

#### Type Alias vs Sum Type Disambiguation
- Fixed bug: `type Names = [string]` now correctly parses as TypeAlias, not AlgebraicType
- Added `TypeAlias` AST node in `internal/ast/ast.go`
- Implemented `hasTopLevelPipe()` helper to detect sum types by presence of `|` operator
- Updated `parseTypeDeclBody()` to distinguish:
  - Type aliases: `type UserId = int`, `type Names = [string]`
  - Sum types: `type Color = Red | Green | Blue`
- Regenerated all type golden files with correct TypeAlias representation

#### Nested Record Types
- Record types now work in type positions: `type User = { addr: { street: string } }`
- Added `typeNode()`, `String()`, `Position()` methods to RecordType
- Created `parseRecordTypeExpr()` function for `{...}` in type expressions
- Added test case `TestRecordTypes/nested_record` with golden file
- RecordType now implements both TypeDef and Type interfaces

#### Export Metadata Tracking
- Added `Exported bool` field to TypeDecl AST node
- Updated `parseTypeDeclaration(exported bool)` to track export status
- AST printer includes `"exported": true` in JSON output for exported types
- Tests validate: `export type PublicColor = Red | Green` vs `type PrivateData = { value: int }`
- Regenerated export golden files with metadata

#### REPL/File Type Parity
- New test suite: `TestREPLFileParityTypes` with 10 type declaration test cases
- Validates identical parsing for: aliases, lists, records (simple & nested), sum types, generics, exports
- All type declarations parse identically in REPL (`<repl>`) vs file (`test.ail`) contexts
- Parser coverage increased to 70.8%

#### Metrics
- Parser coverage: 69% ‚Üí 70.8%
- New tests: 11 (1 nested record + 10 parity tests)
- All existing parser tests pass (544ms test suite)
- Golden files: 3 regenerated (export_alias, export_record, export_sum)
- Code changes: 7 files (ast.go, parser.go, print.go, repl_parity_test.go, type_test.go, Makefile, ci.yml)

### Added - M-P1: Parser Baseline (2025-09-30)

#### Comprehensive Test Infrastructure
- Created deterministic AST printer in `internal/ast/print.go` (445 lines)
- Created test utilities in `internal/parser/testutil.go` (241 lines)
- Established golden file testing framework with 116 snapshots
- Added Makefile targets: `test-parser`, `test-parser-update`, `fuzz-parser`

#### Test Coverage Across All Parser Features
- **Expression tests** (`expr_test.go`, 385 lines): 85 test cases covering literals, operators, collections, lambdas
- **Precedence tests** (`precedence_test.go`, 283 lines): 53 test cases validating operator precedence
- **Module tests** (`module_test.go`, 142 lines): 17 test cases for module/import declarations
- **Function tests** (`func_test.go`, 252 lines): 22 test cases for function declarations and signatures
- **Error recovery tests** (`error_recovery_test.go`, 312 lines): 38 test cases for graceful error handling
- **Invariant tests** (`invariants_test.go`, 320 lines): UTF-8 normalization, CRLF handling, BOM stripping
- **REPL parity tests** (`repl_parity_test.go`, 220 lines): Ensures REPL and file parsing consistency
- **Fuzz tests** (`fuzz_test.go`, 181 lines): 4 fuzz functions with 47 seed cases

#### Baseline Metrics
- **506 test cases** total across all parser features
- **70.2% line coverage** (baseline frozen)
- **Zero panics** in 52k+ fuzz executions
- **2,233 lines** of test code
- All tests pass in ~550ms

## [v0.0.7] - 2025-09-29

### Added - Milestone A2: Structured Error Reporting

#### Unified Error Report System (`internal/errors/report.go`)
- Canonical `errors.Report` type with schema `ailang.error/v1`
- `ReportError` wrapper preserves structured errors through error chains
- `AsReport()` function for type-safe error unwrapping using `errors.As()`
- `WrapReport()` ensures Reports survive through error propagation
- JSON-serializable with deterministic field ordering
- Structured `Data` map with sorted arrays for reproducibility
- `Fix` suggestions with confidence scores
- ~120 lines of core error infrastructure

#### Standardized Error Codes
- **IMP010** - Symbol not exported by module
  - Data: `symbol`, `module_id`, `available_exports[]`, `search_trace[]`
  - Suggests checking available exports in target module
- **IMP011** - Import conflict (multiple providers for same symbol)
  - Data: `symbol`, `module_id`, `providers[{export, module_id}]`
  - Suggests using selective imports to resolve conflict
- **IMP012** - Unsupported import form (namespace imports)
  - Data: `module_id`, `import_syntax`
  - Suggests using selective import syntax
- **LDR001** - Module not found during load
  - Data: `module_id`, `search_trace[]`, `similar[]`
  - Provides resolution trace and similar module suggestions
- **MOD006** - Cannot export underscore-prefixed (private) names
  - Parser validation prevents accidental private exports

#### Error Flow Hardening
- Removed `fmt.Errorf()` wrappers in `internal/elaborate/elaborate.go:112`
- Removed `fmt.Errorf()` wrappers in `internal/pipeline/pipeline.go:434`
- All error builders return `*errors.Report` instead of generic errors
- Link phase wraps reports with `errors.WrapReport()` in `internal/link/module_linker.go`
- Loader phase wraps reports with `errors.WrapReport()` in `internal/loader/loader.go`
- Errors flow end-to-end as first-class types, not string wrappers

#### CLI JSON Output (`cmd/ailang/main.go`)
- `--json` flag enables structured JSON error output
- `--compact` flag for token-efficient JSON serialization
- `handleStructuredError()` extracts Reports using `errors.As()`
- Generic error fallback for non-structured errors
- Exit code 1 for all error conditions

#### Golden File Testing Infrastructure
- **Test files** (`tests/errors/`):
  - `lnk_unresolved_symbol.ail` - Tests IMP010 (symbol not exported)
  - `lnk_unresolved_module.ail` - Tests LDR001 (module not found)
  - `import_conflict.ail` - Tests IMP011 (import conflict)
  - `export_private.ail` - Tests MOD_EXPORT_PRIVATE (private export)
- **Golden files** (`goldens/`):
  - `lnk_unresolved_symbol.json` - Expected IMP010 output
  - `lnk_unresolved_module.json` - Expected LDR001 output
  - `import_conflict.json` - Expected IMP011 output
  - `imports_basic_success.json` - Expected success output (value: 6)
- Golden files ensure byte-for-byte reproducibility of error output

#### Makefile Test Targets
- `make test-imports-success` - Verifies successful imports work
- `make test-import-errors` - Validates golden file matching with `diff -u`
- `make regen-import-error-goldens` - Regenerates golden files (use with caution)
- `make test-imports` - Combined import testing (success + errors)
- `make test-parity` - REPL/file parity test (manual, requires interactive REPL)

#### CI Integration (`.github/workflows/ci.yml`)
- Split import testing into explicit steps:
  - "Test import system (success cases)" - Runs `make test-imports-success`
  - "Test import errors (golden file verification)" - Runs `make test-import-errors`
- CI gates prevent regression in error reporting determinism
- Integrated into `ci-strict` target with operator lowering and builtin freeze tests

### Changed
- `internal/link/report.go` - All builders return `*errors.Report`
- `internal/link/env.go` - Renamed old `LinkReport` to `LinkDiagnostics` to avoid confusion
- `internal/loader/loader.go` - Search trace collection during module resolution
- `internal/parser/parser.go` - Added MOD_EXPORT_PRIVATE validation

### Fixed
- Structured errors were being stringified by `fmt.Errorf("%w")` wrappers
- Error type information now survives through error chains using `errors.As()`
- Flag ordering: Flags must come BEFORE subcommand (`ailang --json --compact run file.ail`)

### Technical Details
- Total new code: ~680 lines (implementation + test files + golden files)
- Test coverage: Golden files ensure deterministic error output
- Determinism: All arrays sorted, canonical module IDs, stable JSON field ordering
- No breaking changes to existing functionality
- Schema versioning allows future enhancements without breaking compatibility

### Migration Notes
- Existing error handling continues to work unchanged
- JSON output is opt-in via `--json` flag
- Structured errors available via `errors.AsReport()` for tools integration
- Golden file tests serve as documentation of expected error formats

## [v0.0.6] - 2025-09-29

### Added

#### Error Code Taxonomy (`internal/errors/codes.go`)
- Comprehensive error code system with structured taxonomy
- Error codes organized by phase: PAR (Parser), MOD (Module), LDR (Loader), TC (Type Check), etc.
- Error registry with phase and category metadata
- Helper functions: `IsParserError()`, `IsModuleError()`, `IsLoaderError()`, etc.
- ~278 lines of structured error definitions

#### Manifest System (`internal/manifest/`)
- Example manifest format for tracking example status (working/broken/experimental)
- Validation ensures consistency between documentation and implementation
- Statistics calculation with coverage metrics
- README generation support for automatic documentation updates
- Environment defaults for reproducible execution
- ~390 lines with full validation logic

#### Module Loader (`internal/module/loader.go`)
- Complete module loading system with dependency resolution
- Circular dependency detection using cycle detection algorithm
- Topological sorting using Kahn's algorithm for build order
- Module caching with thread-safe concurrent access
- Support for stdlib modules and relative imports
- Structured error reporting with resolution traces
- ~607 lines of robust module management

#### Path Resolver (`internal/module/resolver.go`)
- Cross-platform path normalization and resolution
- Support for relative imports (`./`, `../`)
- Standard library path resolution (`std/`)
- Project root detection and search path management
- Case-sensitive and case-insensitive filesystem handling
- Module identity derivation from file paths
- ~405 lines of platform-aware path handling

#### Example Files
- Basic module with function declarations
- Recursive functions with inline tests
- Module imports and composition
- Standard library usage patterns
- Property-based testing examples

### Changed
- Test coverage improved from 29.9% to 31.3%
- Module tests now include comprehensive cycle detection validation
- Topological sort correctly handles dependency ordering

### Fixed
- CI/CD script compilation errors by refactoring shared types into `scripts/internal/reporttypes`
- Test suite now correctly excludes `scripts/` directory containing standalone executables
- Makefile and CI workflow updated to use `go list ./... | grep -v /scripts` for testing

## [v0.0.5] - 2025-09-29

### Added

#### Schema Registry (`internal/schema/`)
- Frozen schema versioning system with forward compatibility
- Schema constants: `ErrorV1` (ailang.error/v1), `TestV1` (ailang.test/v1), `EffectsV1` (ailang.effects/v1)
- `Accepts()` method for prefix matching against newer schema versions
- `MarshalDeterministic()` for stable JSON output with sorted keys
- `CompactMode` flag support for token-efficient JSON serialization
- Registry pattern for managing versioned schemas across components
- ~145 lines of core implementation

#### Error JSON Encoder (`internal/errors/`)
- Structured error taxonomy with stable error codes (TC###, ELB###, LNK###, RT###)
- Always includes `fix` field with actionable suggestion and confidence score
- SID (Stable Node ID) discipline with "unknown" fallback for safety
- Builder pattern API: `WithFix()`, `WithSourceSpan()`, `WithMeta()`
- Schema-compliant JSON output using ailang.error/v1
- Safe encoding that never panics on malformed data
- ~190 lines with comprehensive error handling

#### Test Reporter (`internal/test/`)
- Structured test reporting in JSON format using ailang.test/v1 schema
- Complete test counts shape: passed/failed/errored/skipped/total
- Platform information capture for reproducibility tracking
- Deterministic sorting by suite name and test name
- Valid JSON output even with zero tests
- Test runner integration with SID generation
- ~206 lines with full test lifecycle support

#### REPL Effects Inspector (`internal/repl/effects.go`)
- `:effects <expr>` command for type and effect introspection
- Returns type signature and effect requirements without evaluation
- Supports both human-readable and JSON output modes
- Placeholder implementation (full version pending effect system)
- Schema-compliant output using ailang.effects/v1
- ~41 lines with extensible architecture

#### CLI Compact Mode Support
- `--compact` flag added to main CLI for global compact JSON mode
- Integrates with schema registry's `CompactMode` setting
- Affects all JSON output including errors, tests, and effects
- Token-efficient output for AI agent integration

#### Golden Test Framework Enhancements
- Platform-specific salt generation for reproducibility
- `UPDATE_GOLDENS` environment variable support
- JSON diff utilities for test validation
- Deterministic fixture generation and validation
- ~309 lines of comprehensive test infrastructure

### Added - Test Coverage & Quality
- 100% test coverage for schema registry (unit + integration)
- 100% test coverage for error encoder with edge cases
- 100% test coverage for test reporter with platform variations
- Golden test fixtures for all schema-compliant JSON outputs
- Integration tests validating cross-component schema compliance
- ~470 lines of test code ensuring reliability

### Changed
- All JSON output now uses deterministic field ordering
- Error messages consistently include actionable fix suggestions
- Test reporting standardized across all components
- Platform information consistently captured for reproducibility

### Technical Details
- Total new code: ~1,630 lines (implementation + tests)
- Dependencies: No new external dependencies
- Schema versioning: Forward-compatible design
- JSON output: Deterministic and stable across platforms
- Test coverage: 100% for all new packages

### Migration Notes
- All existing functionality preserved
- New features are opt-in via CLI flags and REPL commands
- JSON output format enhanced but remains backward compatible
- Schema versioning allows gradual migration to newer formats

## [v0.0.4] - 2025-09-28

### Added

#### Example Verification System (`scripts/`)
- `verify_examples.go` - Tests all examples, categorizes as passed/failed/skipped
- Outputs in JSON, Markdown, and plain text formats
- Captures error messages for failed examples
- Skips test/demo files automatically
- ~200 lines of Go code

#### README Auto-Update System
- `update_readme.go` - Updates README with verification status
- Auto-generates status table between markers
- Creates badges for CI, coverage, and example status
- Maintains timestamp of last update
- ~150 lines of Go code

#### CI GitHub Actions (`.github/workflows/ci.yml`)
- Automated testing on push/PR to main/dev branches
- Example verification with failure on broken examples
- Test coverage reporting to Codecov
- Auto-commits README updates on dev branch
- Build artifact generation
- Parallel linting and testing jobs

#### Make Targets
- `make verify-examples` - Run example verification
- `make update-readme` - Update README with status
- `make flag-broken` - Add warning headers to broken examples
- `make test-coverage-badge` - Generate coverage metrics
- `make ci` - Full CI pipeline

### Added - Documentation
- CI status badges in README (CI, Coverage, Examples)
- Auto-generated example status table
- Example verification report showing 13 working, 13 failing, 14 skipped
- Warning headers for broken examples (via `flag_broken_examples.go`)
- `.gitignore` entries for CI-generated files

### Changed
- REPL now displays version from git tags dynamically (via ldflags)
- All v3.x version references updated to semantic versioning (v0.0.x)
- Example files renamed to match version scheme (v0_0_3_features_demo.ail)
- Design docs restructured to match version scheme

### Technical Details
- Total new code: ~500 lines
- Test coverage: Verification scripts fully tested
- No external dependencies added
- Apache 2.0 license badge added

## [v0.0.3] - 2025-09-26

### Added

#### Schema Registry (`internal/schema/`)
- Versioned JSON schemas with forward compatibility
- `Accepts()` for schema version negotiation
- `MarshalDeterministic()` for stable JSON output
- `CompactMode` support for token-efficient output
- Schema constants: `ErrorV1`, `TestV1`, `DecisionsV1`, `PlanV1`, `EffectsV1`

#### Error JSON Encoder (`internal/errors/`)
- Structured error taxonomy with codes (TC###, ELB###, LNK###, RT###)
- Always includes `fix` field with suggestion and confidence score
- SID (Stable Node ID) discipline with fallback to "unknown"
- Builder pattern: `WithFix()`, `WithSourceSpan()`, `WithMeta()`
- Safe encoding that never panics

#### Test Reporter (`internal/test/`)
- Structured test reporting in JSON format
- Full counts shape (passed/failed/errored/skipped/total)
- Platform information for reproducibility
- Deterministic sorting by suite and name
- Valid JSON output even with 0 tests
- Test runner with SID generation

#### Effects Inspector
- `:effects <expr>` command for type/effect introspection
- Returns type and effects without evaluation
- Supports compact JSON mode
- Placeholder implementation (full version pending effect system)

#### Golden Test Framework (`testutil/`)
- Platform salt for reproducibility tracking
- `UPDATE_GOLDENS` environment variable support
- JSON diff utilities
- Deterministic test fixtures

#### REPL Enhancements
- `:test [--json]` - Run tests with optional JSON output
- `:effects <expr>` - Inspect type and effects
- `:compact on/off` - Toggle JSON compact mode
- Updated help with new commands

### Added - Examples & Documentation
- `examples/v3_2_features_demo.ail` - Demonstrates new v3.2 features
- `examples/repl_commands_demo.md` - REPL command documentation
- `examples/ai_agent_integration.ail` - Comprehensive AI agent guide
- `examples/working_v3_2_demo.ail` - Working examples for current state
- `design_docs/implemented/v3_2/` - Implementation report with metrics
- Comprehensive test suites for all new packages
- 100% test coverage for schema registry
- 100% test coverage for error encoder
- 100% test coverage for test reporter

### Changed
- `types.CanonKey()` alias added for consistent dictionary key generation
- REPL help updated with new AI-first commands

### Fixed
- Multi-line REPL input for `let...in` expressions
- Added continuation prompt (`...`) for incomplete expressions

### Technical Details
- Total new code: ~1,500 lines
- Test coverage: All new packages fully tested
- Dependencies: No new external dependencies

### Migration Notes
- No breaking changes
- New features are opt-in via REPL commands
- Existing code continues to work unchanged

## [v0.0.2] - Previous Release
- Type class resolution with dictionary-passing
- REPL improvements with history and tab completion
- Core type system implementation

## [v0.0.1] - Initial Release
- Basic lexer and parser
- AST implementation
- Initial REPL

---

# CLAUDE.md (Project Instructions)

# Claude Instructions for AILANG Development

## Project Overview
AILANG is an AI-first programming language designed for AI-assisted development. It features:
- Pure functional programming with algebraic effects (planned)
- Typed quasiquotes for safe metaprogramming (planned)
- CSP-based concurrency with session types (planned)
- Deterministic execution for AI training data generation (planned)
- File extension: `.ail`

## Current Status: v0.3.0-alpha3 (Records & Row Polymorphism COMPLETE ‚úÖ)

**‚úÖ COMPLETE (v0.3.0-alpha3):**
- ‚úÖ **M-R5: Records & Row Polymorphism** (~670 LOC) - COMPLETE
  - Record subsumption for flexible field access
  - TRecordOpen compatibility shim for Day 1 wins
  - TRecord2 with full row polymorphism (opt-in via `AILANG_RECORDS_V2=1`)
  - Row unification with occurs check
  - Helper functions and error codes (TC_REC_001-004)
  - 16 new unit tests, all passing ‚úÖ
  - Fixed 11 examples (9 from subsumption + 2 new) ‚úÖ

**‚úÖ COMPLETE (v0.3.0-alpha2):**
- ‚úÖ **M-R4: Recursion Support** (~1,780 LOC)
  - RefCell-based recursion (OCaml/Haskell style)
  - Self-recursive and mutual recursion
  - Depth guard (configurable limit)
  - Works in module runtime ‚úÖ

- ‚úÖ **M-R8: Block Expressions** (~10 LOC fix)
  - Block syntax `{ e1; e2; e3 }` for sequencing
  - Desugars to let chains
  - Works with recursion ‚úÖ
  - AI-generated code compatible ‚úÖ

**‚úÖ COMPLETE (v0.2.0):**
- ‚úÖ **M-R1: Module Execution Runtime** (~1,874 LOC)
  - Module instance creation and evaluation
  - Cross-module imports at runtime
  - Entrypoint execution (`--entry`, `--args-json`)
  - Function invocation with argument decoding
  - Builtin registry (IO, FS primitives)
  - **Cross-function references within modules**

- ‚úÖ **M-R2: Effect System Runtime** (~1,550 LOC)
  - Capability-based security (`--caps IO,FS`)
  - IO effect: `print`, `println`, `readLine`
  - FS effect: `readFile`, `writeFile`, `exists`
  - Secure by default (no caps unless explicitly granted)
  - Sandbox support (`AILANG_FS_SANDBOX`)

**üìä Test Status:**
- Unit tests: 80+ passing (runtime + effects + records)
- Example files: 48/66 passing (72.7%)
- All record subsumption examples working ‚úÖ
- All effect system examples working ‚úÖ
- All type class examples working ‚úÖ
- All recursion examples working ‚úÖ
- All block expression examples working ‚úÖ

**‚úÖ COMPLETE (v0.1.0):**
- Hindley-Milner type inference with let-polymorphism
- Type classes (Num, Eq, Ord, Show) with dictionary-passing
- Lambda calculus (first-class functions, closures, currying)
- Interactive REPL with full type checking
- Pattern matching (constructors, tuples, lists, wildcards)
- Algebraic data types (ADTs) with runtime
- Structured error reporting with JSON schemas
- AI Evaluation Framework (M-EVAL) with multi-model support
- Pattern matching guards and exhaustiveness warnings (M-R3, optional)

**‚ùå NOT YET IMPLEMENTED:**

- Typed quasiquotes (v0.3.0+)
- CSP concurrency (v0.3.0+)
- AI training data export (v0.3.0+)

**üéâ MAJOR MILESTONE:** Module files now execute! Use `ailang run --caps IO,FS --entry main module.ail` to run module code with effects.

**‚ö†Ô∏è Important**: Flags must come BEFORE the filename when using `ailang run`.

## Key Design Principles
1. **Explicit Effects**: All side effects must be declared in function signatures
2. **Everything is an Expression**: No statements, only expressions that return values
3. **Type Safety**: Static typing with Hindley-Milner inference + row polymorphism
4. **Deterministic**: All non-determinism must be explicit (seeds, virtual time)
5. **AI-Friendly**: Generate structured execution traces for training

## Project Structure (v0.2.0-rc1)
```
ailang/
‚îú‚îÄ‚îÄ cmd/ailang/         # CLI entry point ‚úÖ COMPLETE
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ ast/            # AST definitions ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ lexer/          # Tokenizer ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ parser/         # Parser ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ types/          # Type system ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ typeclass/      # Type classes ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ eval/           # Evaluator ‚úÖ COMPLETE (Core + module support)
‚îÇ   ‚îú‚îÄ‚îÄ repl/           # Interactive REPL ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ runtime/        # Module execution runtime ‚úÖ COMPLETE (v0.2.0)
‚îÇ   ‚îú‚îÄ‚îÄ effects/        # Effect system runtime ‚úÖ COMPLETE (v0.2.0)
‚îÇ   ‚îú‚îÄ‚îÄ loader/         # Module loader ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ errors/         # Error reporting ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ schema/         # JSON schemas ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ eval_harness/   # AI evaluation framework ‚úÖ COMPLETE (M-EVAL)
‚îÇ   ‚îú‚îÄ‚îÄ channels/       # CSP implementation ‚ùå TODO (v0.3.0+)
‚îÇ   ‚îî‚îÄ‚îÄ session/        # Session types ‚ùå TODO (v0.3.0+)
‚îú‚îÄ‚îÄ stdlib/             # Standard library ‚úÖ COMPLETE (std/io, std/fs, std/prelude)
‚îú‚îÄ‚îÄ tools/              # Development tools ‚úÖ (benchmarking, example verification)
‚îú‚îÄ‚îÄ benchmarks/         # AI code generation benchmarks ‚úÖ
‚îú‚îÄ‚îÄ examples/           # Example .ail programs (~40 files)
‚îú‚îÄ‚îÄ tests/              # Test suite ‚úÖ
‚îî‚îÄ‚îÄ docs/               # Documentation ‚úÖ COMPLETE
```

## Development Workflow

### Building and Testing
```bash
make build          # Build the interpreter to bin/
make install        # Install ailang to system (makes it available everywhere)
make test           # Run all tests
make run FILE=...   # Run an AILANG file
make repl           # Start interactive REPL
```

### Code Quality & Coverage
```bash
make test-coverage-badge  # Quick coverage check (shows: "Coverage: 29.9%")
make test-coverage        # Run tests with coverage, generates HTML report
make lint                 # Run golangci-lint
make fmt                  # Format all Go code
make fmt-check            # Check if code is formatted
make vet                  # Run go vet
```

### Example Management
```bash
make verify-examples      # Verify all example files work/fail
make update-readme        # Update README with example status
make flag-broken          # Add warning headers to broken examples
```

### Development Helpers
```bash
make deps                 # Install all dependencies
make clean                # Remove build artifacts and coverage files
make ci                   # Run full CI verification locally
make help                 # Show all available make targets
```

#### Keeping `ailang` Up to Date

**Option 1: Manual Update**
After making code changes, run:
```bash
make quick-install  # Fast reinstall
# OR
make install        # Full reinstall with version info
```

### IMPORTANT: Keeping Documentation Updated

**Required documentation updates for every change:**

#### 1. README.md
- Update implementation status when adding new features
- Update current capabilities when functionality changes
- Update examples when they're fixed or new ones added
- Keep line counts and completion status accurate
- Document new builtin functions and operators
- Update the roadmap as items are completed

#### 2. CHANGELOG.md
**Must be updated for every feature or bug fix:**
- Follow semantic versioning (vMAJOR.MINOR.PATCH)
- Group changes by category: Added, Changed, Fixed, Deprecated, Removed
- Include code locations for new features (e.g., `internal/schema/`)
- Note breaking changes clearly
- Add migration notes if needed
- Include metrics (lines of code, test coverage)

Example entry:
```markdown
## [v3.2.0] - 2024-09-28

### Added
- Schema Registry (`internal/schema/`) - Versioned JSON schemas
- Error JSON Encoder (`internal/errors/`) - Structured error reporting
- Test coverage: 100% for new packages
- Total new code: ~1,500 lines
```

#### 3. Design Documentation
- **Before starting**: Create design doc in `design_docs/planned/`
- **After completing**: Move to `design_docs/implemented/vX_Y/`
- Include implementation report with metrics and limitations

**CRITICAL: Example Files Required**
**Every new language feature MUST have a corresponding example file:**
- Create `examples/feature_name.ail` for each new feature
- Include comprehensive examples showing all capabilities
- Add comments explaining the behavior and expected output
- ‚ö†Ô∏è **Test that examples actually work with current implementation**
- ‚ö†Ô∏è **Add warning headers to examples that don't work**
- These examples will be used in documentation and tutorials
- Always test examples before documenting them as working

### Common Tasks

#### Adding a New Language Feature
1. Update token definitions in `internal/lexer/token.go`
2. Modify lexer in `internal/lexer/lexer.go` to recognize tokens
3. Add AST nodes in `internal/ast/ast.go`
4. Update parser in `internal/parser/parser.go`
5. Add type rules in `internal/types/`
6. Implement evaluation in `internal/eval/` (when created)
7. Write tests in corresponding `*_test.go` files
8. Add examples in `examples/`

## Language Syntax Reference

**üìñ When Writing AILANG Code:**
If you (Claude or other AI) are writing AILANG code during development, refer to the **AI Teaching Prompt** for comprehensive syntax guidance:
- **Current version**: [prompts/v0.3.0.md](prompts/v0.3.0.md) (v0.3.0-alpha3 features)
- This is the same prompt used in eval benchmarks and validated through multi-model testing
- Covers syntax, limitations, common pitfalls, and working examples

### ‚úÖ Working Syntax (v0.3.0-alpha3)

**Basic Expressions:**
```ailang
-- Comments use double dash
let x = 5 in x * 2                     -- Let binding (works up to 3 nested)
\x. x * 2                               -- Lambda function
if x > 0 then "pos" else "neg"         -- Conditional expression
{ e1; e2; e3 }                          -- Block expression (NEW! ‚ú®)
[1, 2, 3]                               -- List literal
{ name: "Alice", age: 30 }             -- Record literal
(1, "hello", true)                      -- Tuple literal
1 + 2 * 3                               -- Arithmetic with precedence
"Hello " ++ "World"                     -- String concatenation
```

**REPL Features:**
```ailang
Œª> :type \x. x + x
\x. x + x :: ‚àÄŒ±. Num Œ± ‚áí Œ± ‚Üí Œ±

Œª> let double = \x. x * 2 in double(21)
42 :: Int

Œª> :instances
Available instances: Num[Int], Num[Float], Eq[Int], Eq[Float], Ord[Int], Ord[Float]
```

**Module Syntax (NOW EXECUTES! ‚úÖ):**
```ailang
module examples/demo

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello from module!")
}
```

**Running modules:**
```bash
ailang run --caps IO --entry main examples/demo.ail
# Output: Hello from module!
```

**Pattern Matching:**
```ailang
type Option[a] = Some(a) | None

match Some(42) {
  Some(x) => x * 2,
  None => 0
}
-- Result: 84
```

**Effects (v0.2.0):**
```ailang
import std/io (println)
import std/fs (readFile)

export func main() -> () ! {IO, FS} {
  let content = readFile("data.txt");
  println(content)
}
```

**Running with capabilities:**
```bash
ailang run --caps IO,FS --entry main app.ail
```

**Block Expressions (v0.3.0-alpha2, NEW! ‚ú®):**
```ailang
-- Blocks allow sequencing with automatic let-chain desugaring
{
  println("Computing...");
  println("Result:");
  42
}

-- Perfect for recursive functions with side effects:
func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}
```

**Pattern Guards (M-R3, optional):**
```ailang
match value {
  Some(x) if x > 0 => x * 2,  -- ‚ùå Guards not yet supported
  Some(x) => x,
  None => 0
}
```

### ‚ùå Planned Syntax (Not Yet Implemented)

**Error Propagation (future):**
```ailang
func readAndPrint() -> () ! {IO, FS} {
  let content = readFile("data.txt")?  -- ‚ùå ? operator not implemented
  print(content)
}
```

**Quasiquotes (v0.3.0+):**
```ailang
let query = sql"""SELECT * FROM users WHERE age > ${minAge: int}"""
```

**Concurrency (v0.3.0+):**
```ailang
func worker(ch: Channel[Task]) ! {Async} {
  loop {
    let task <- ch
    ch <- process(task)
  }
}
```

## What Works & What Doesn't (v0.2.0-rc1)

### ‚úÖ Working Features
- ‚úÖ **Module execution** - `ailang run --entry main module.ail`
- ‚úÖ **Effect system** - IO and FS effects with capability security
- ‚úÖ **Pattern matching** - Constructors, tuples, lists, wildcards
- ‚úÖ **ADTs** - Algebraic data types with runtime support
- ‚úÖ **Type classes** - Num, Eq, Ord, Show with dictionary-passing
- ‚úÖ **Imports** - Cross-module imports work at runtime
- ‚úÖ **REPL** - Fully functional with all type system features
- ‚úÖ **Builtins** - String primitives, IO, FS operations

### ‚úÖ Working Examples
```bash
# Module with IO
ailang run --caps IO --entry main examples/test_io_builtins.ail

# Pattern matching with ADTs
ailang run --entry main examples/adt_simple.ail

# Cross-module imports
ailang run --caps IO --entry main examples/effects_basic.ail
```

See [examples/STATUS.md](examples/STATUS.md) for complete example inventory.

### ‚ö†Ô∏è Known Limitations (v0.3.0-alpha2)

**Still TODO:**
1. ‚ö†Ô∏è Pattern matching guards - `if condition` in match arms not evaluated
2. ‚ö†Ô∏è Exhaustiveness checking - No warnings for non-exhaustive patterns
3. ‚ö†Ô∏è Let expressions limited to 3 nesting levels (4+ fails)
4. ‚ùå `tests [...]` and `properties [...]` syntax not implemented
5. ‚ùå Error propagation operator `?` not implemented

**Execution Modes:**
AILANG supports two execution modes:

1. **Simple scripts** (no module declaration):
   - Cannot use `func`, `type`, `import`, `export` keywords
   - Just write expressions: `let x = 5 in x * 2`
   - Run with: `ailang run script.ail`
   - Example: [examples/simple.ail](examples/simple.ail)

2. **Module files** (with `module` declaration):
   - Must start with `module path/name`
   - Can use `func`, `type`, `import`, `export` keywords
   - Can import from stdlib and use effects
   - Run with: `ailang run --caps IO --entry main module.ail`
   - Example: [examples/effects_basic.ail](examples/effects_basic.ail)

**Execution Limitations:**
1. ‚ö†Ô∏è REPL and file execution use different code paths (intentional)
2. ‚ö†Ô∏è Type classes work in REPL and module files, not in simple scripts
3. ‚ö†Ô∏è Record field access has unification bugs in some cases
4. ‚ö†Ô∏è List operations have limited runtime support

See [docs/LIMITATIONS.md](docs/LIMITATIONS.md) for comprehensive details and workarounds.

### üöÄ v0.2.0 Roadmap (3.5-4.5 weeks)

**Status**: Design complete, ready for implementation

**M-R1: Module Execution Runtime** (~1,000-1,300 LOC, 1.5-2 weeks)
- Module instance creation and evaluation
- Cross-module imports at runtime
- Entrypoint execution (`--entry`, `--args-json`)
- `--runner=fallback` to preserve v0.1.0 wrapper

**M-R2: Minimal Effect Runtime** (~700-900 LOC, 1-1.5 weeks)
- Capability-based security (`--caps IO,FS`)
- IO effect: `print`, `println`, `readLine`
- FS effect: `readFile`, `writeFile`, `exists`
- Secure by default (no caps unless explicitly granted)

**M-R3: Pattern Matching Polish** (~450-650 LOC, 1 week) [STRETCH]
- Guards: `pattern if condition => body`
- Exhaustiveness warnings with suggested missing cases
- Decision tree compilation for performance

**See**: [v0.2.0 Implementation Plan](design_docs/planned/v0_2_0_implementation_plan.md)

### üìã Future (v0.3.0+)
1. Effect composition DSL, budgets, async effects
2. Typed quasiquotes (SQL, HTML, JSON)
3. CSP concurrency with channels
4. Session types
5. Property-based testing
6. AI training data export

## REPL Usage (v2.3)

The AILANG REPL now features professional-grade interactive development with full type class support:

### Interactive Features
- **Arrow Key History**: Navigate command history with ‚Üë/‚Üì arrows
- **Persistent History**: Commands saved in `~/.ailang_history`
- **Tab Completion**: Auto-complete REPL commands with Tab key
- **Auto-imports**: `std/prelude` loaded automatically on startup
- **Clean Exit**: `:quit` command properly exits the REPL

### Basic Usage
```bash
ailang repl
```

The REPL auto-imports `std/prelude` on startup, providing:
- Numeric defaults: `Num ‚Üí Int`, `Fractional ‚Üí Float`  
- Type class instances for `Num`, `Eq`, `Ord`, `Show`
- String concatenation with `++` operator
- Record literals and field access

### Key Commands
- `:help, :h` - Show all available commands
- `:quit, :q` - Exit the REPL (also works: Ctrl+D)
- `:type <expr>` - Show qualified type with constraints
- `:import <module>` - Import type class instances
- `:instances` - List available instances with superclass provisions
- `:dump-core` - Toggle Core AST display for debugging
- `:dump-typed` - Toggle Typed AST display
- `:dry-link` - Show required dictionary instances without evaluating
- `:trace-defaulting on/off` - Enable/disable defaulting trace
- `:history` - Show command history
- `:clear` - Clear the screen
- `:reset` - Reset environment (auto-reimports prelude)

### Example REPL Session

```ailang
Œª> 1 + 2
3 :: Int

Œª> 3.14 * 2.0
6.28 :: Float

Œª> "Hello " ++ "AILANG!"
Hello AILANG! :: String

Œª> true && false
false :: Bool

Œª> [1, 2, 3]
[1, 2, 3] :: [Int]

Œª> {name: "Alice", age: 30}
{name: Alice, age: 30} :: {name: String, age: Int}

Œª> :type \x. x + x
\x. x + x :: ‚àÄŒ±. Num Œ± ‚áí Œ± ‚Üí Œ±

Œª> let double = \x. x * 2 in double(21)
42 :: Int
```

### Type Class Pipeline
The REPL executes the full pipeline:
1. **Parse** - Surface syntax to AST
2. **Elaborate** - AST to Core (ANF)
3. **TypeCheck** - Infer types with constraints
4. **Dictionary Elaboration** - Transform operators to dictionary calls
5. **ANF Verification** - Ensure well-formed Core
6. **Link** - Resolve dictionary references
7. **Evaluate** - Execute with runtime dictionaries

### Example Session
```
Œª> 1 + 2 * 3
:: Int
7

Œª> :type 42 == 42
42 == 42 :: Bool

Œª> :instances
Available instances:
  Num:
    ‚Ä¢ Num[Int], Num[Float]
  Eq:
    ‚Ä¢ Eq[Int], Eq[Float]
  Ord:
    ‚Ä¢ Ord[Int] (provides Eq[Int])
    ‚Ä¢ Ord[Float] (provides Eq[Float])
```

### Architecture Notes
- **Type-level instances** (`instEnv`) - Used during type checking and defaulting
- **Runtime dictionaries** (`instances`) - Used during evaluation
- Both must be kept in sync when importing modules
- Method names are standardized: `eq`/`neq`, `lt`/`lte`/`gt`/`gte`

## Testing Guidelines

### Unit Tests
- Each module should have a corresponding `*_test.go` file
- Test both success and error cases
- Use table-driven tests for multiple inputs

### Integration Tests
- Test complete programs in `examples/`
- Verify type checking catches errors
- Test effect propagation
- Ensure deterministic execution

### Property-Based Tests
AILANG supports inline property tests:
```ailang
property "sort preserves length" {
  forall(list: [int]) =>
    length(sort(list)) == length(list)
}
```

## Code Style Guidelines

1. **Go Code**:
   - Follow standard Go conventions
   - Use descriptive names
   - Add comments for complex logic
   - Keep functions under 50 lines

2. **AILANG Code**:
   - Use 2-space indentation
   - Prefer pure functions
   - Make effects explicit
   - Include tests with functions
   - Use type annotations when helpful

## Error Handling

### In Go Implementation
- Return explicit errors, don't panic
- Include position information in parse errors
- Provide helpful error messages with suggestions

### In AILANG
- Use Result type for fallible operations
- Propagate errors with `?` operator
- Provide structured error context

## Performance Considerations
- Parser uses Pratt parsing for efficient operator precedence
- Type inference should cache resolved types
- Lazy evaluation for better performance (future)
- String interning for identifiers

## Debug Commands
```bash
# Parse and print AST (when implemented)
ailang parse file.ail

# Type check without running
ailang check file.ail

# Show execution trace
ailang run --trace file.ail

# Export training data
ailang export-training
```

## Common Patterns

### Adding a Binary Operator
1. Add token in `token.go`
2. Add to lexer switch statement
3. Define precedence in parser
4. Add to `parseInfixExpression`
5. Add type rule
6. Implement evaluation

### Adding a Built-in Function
1. Define type signature
2. Add to prelude or appropriate module
3. Implement in Go
4. Add tests

## Resources
- Design doc: `design_docs/20250926/initial_design.md`
- Examples: `examples/` directory
- Go tests: `*_test.go` files

## Testing Policy
**ALWAYS remove out-of-date tests. No backward compatibility.**
- When architecture changes, delete old tests completely
- Don't maintain legacy test suites
- Write new tests for new implementations
- Keep test suite clean and current

## üö® CRITICAL: Linting & "Unused" Code Warnings

**‚ö†Ô∏è LESSON LEARNED: Never blindly delete "unused" functions without understanding WHY they're unused!**

### The Import System Disaster (September 2025)
In commit `eae08b6`, working import functions were deleted because linter said they were "unused".
**What actually happened:**
1. Function **calls** were renamed from `parseModuleDecl()` to `_parseModuleDecl()` (note underscore)
2. Function **definitions** kept original names (no underscore)
3. Calls were then **commented out**
4. Linter correctly said "hey, `parseModuleDecl` is never called!"
5. Functions were **blindly deleted**
6. Result: **Working import system completely broken** üí•

### Rules to Prevent This:
1. **NEVER delete functions just because linter says "unused"**
   - First understand WHY they're unused
   - Check git history - were they just commented out?
   - Search entire codebase for references (including comments)
   - Run `make test-imports` and `make test` BEFORE deleting anything

2. **If renaming function calls, rename definitions too**
   - Use IDE refactoring tools, not manual find/replace
   - If adding `_` prefix to mark as TODO, add to BOTH call and definition
   - Better: use TODO comments instead of renaming

3. **Test between each change**
   - Don't combine: rename + comment out + delete
   - Run tests after EACH step:
     - After rename ‚Üí `make test`
     - After commenting out ‚Üí `make test-imports`
     - After deleting ‚Üí `make test && make lint`

4. **When linter complains about unused code:**
   ```bash
   # Step 1: Check if it's really unused
   git log -p --all -S 'functionName' internal/
   grep -r "functionName" internal/

   # Step 2: Check recent changes
   git log --oneline internal/parser/parser.go | head -5
   git diff HEAD~1 internal/parser/parser.go | grep functionName

   # Step 3: If truly unused AND you know why, document it
   git commit -m "Remove unused parseOldFormat() - replaced by parseNewFormat() in commit abc123"
   ```

5. **Special warning for parser/module/import code**
   - These are **critical** for language functionality
   - If you break these, **nothing imports work**
   - Always run `make test-imports` before committing parser changes
   - Check that example files still work: `make verify-examples`

### Recovery Checklist (if this happens again):
1. Find last working commit: `git log --all --oneline | grep "import"`
2. Check what was deleted: `git diff working_commit broken_commit`
3. Restore deleted functions: `git show working_commit:file.go`
4. Test imports: `make test-imports`
5. Document in commit message what was broken and how it was fixed

### Development Commands

```bash
# Module runtime development
make test                          # Run all tests
go test ./internal/runtime/...     # Test module runtime
make verify-examples               # Verify examples work

# Effect runtime development
go test ./internal/effects/...     # Test effects
AILANG_FS_SANDBOX=/tmp make test  # Test with sandbox

# Pattern matching development
go test ./internal/elaborate/...   # Test exhaustiveness
go test ./internal/eval/...        # Test evaluation

# Full CI check
make ci                           # Run all checks locally
```

## Important Notes
1. The language is expression-based - everything returns a value
2. Effects are tracked in the type system - never ignore them
3. Pattern matching must be exhaustive
4. All imports must be explicit
5. Row polymorphism allows extensible records and effects
6. Session types ensure protocol correctness in channels

## Quick Debugging Checklist
- [ ] Check lexer is producing correct tokens
- [ ] Verify parser is building proper AST
- [ ] Ensure all keywords are in the keywords map
- [ ] Confirm precedence levels are correct
- [ ] Check that all AST nodes implement correct interfaces
- [ ] Verify type substitution is working correctly

## Contact & Support
This is an experimental language. For questions or issues:
- Check the design documents in @design_docs
- Look at example programs
- Run tests for expected behavior
- Refer to similar functional languages (Haskell, OCaml, F#)
---

# AI Prompt: python.md

# Python Programming Guidelines

You are an expert Python programmer. Write clean, idiomatic Python 3 code.

## Guidelines

- Use Python 3 syntax
- Follow PEP 8 style guidelines
- Write readable, maintainable code
- Use type hints when helpful
- Prefer built-in functions and standard library

## Code Structure

- Use functions to organize code
- Include a `main()` function when appropriate
- Use `if __name__ == "__main__":` for script entry points

## Common Patterns

- Use list comprehensions for simple transformations
- Use f-strings for string formatting
- Use context managers (`with`) for resource management
- Prefer `pathlib` for file paths
- Use exceptions for error handling

## Output

- Output only the code, no explanations
- Do not include markdown code fences unless specifically requested
- Ensure code is complete and runnable

---

# AI Prompt: v0.2.0.md

# AILANG AI Teaching Prompt (v0.2.0-rc1)

**CRITICAL: You MUST write code in AILANG syntax. This is NOT Python, NOT Rust, NOT JavaScript.**

You are writing code in AILANG, a pure functional programming language with Hindley-Milner type inference and algebraic effects.

**IMPORTANT SYNTAX RULES:**
- Use `func` NOT `fn`, `function`, or `def`
- Use `type Name[a] = Constructor(a) | Constructor2` NOT `type Name { }` or `enum`
- NO namespace syntax (`::`), just use constructor names directly
- NO semicolons at end of statements in blocks (only between let bindings)
- Pattern matching uses `=>` NOT `:` or `->`
- NO `for`, `while`, `var`, `const`, `let mut`, or any imperative constructs

## Current Version: v0.2.0-rc1 (Module Execution + Effects)

**‚úÖ WHAT WORKS:**
- ‚úÖ **Module declarations** - `module path/to/module`
- ‚úÖ **Function declarations** - `export func name(params) -> Type { body }`
- ‚úÖ **Import statements** - `import std/io (println)`
- ‚úÖ **Pattern matching** - Constructors, tuples, lists, wildcards
- ‚úÖ **Effect system** - `! {IO, FS}` for side effects
- ‚úÖ **ADTs** - Algebraic data types: `type Option[a] = Some(a) | None`

**‚ö†Ô∏è LIMITATIONS:**
- ‚ö†Ô∏è NO `for`/`while` loops - use recursion
- ‚ö†Ô∏è NO `var` - everything is immutable
- ‚ö†Ô∏è NO pattern guards in match (yet)
- ‚ö†Ô∏è Let expressions limited to 3 nesting levels

## Module Structure

Every AILANG program must be a module with exported functions:

```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello, World!")
}
```

**IMPORTANT**: Always use `module benchmark/solution` as the module name for benchmark programs.

## Functions

```ailang
-- Simple pure function
export func add(x: int, y: int) -> int {
  x + y
}

-- Function with effects (IO, FS)
export func greet(name: string) -> () ! {IO} {
  println("Hello, " ++ name)
}

-- Generic function
export func identity[a](x: a) -> a {
  x
}

-- Multi-statement body (use semicolons)
export func compute() -> int {
  let x = 10;
  let y = 20;
  x + y
}
```

## Algebraic Data Types (ADTs)

**‚úÖ CORRECT AILANG SYNTAX:**
```ailang
type Option[a] = Some(a) | None
type Result[a, e] = Ok(a) | Err(e)
type List[a] = Cons(a, List[a]) | Nil

export func getOrElse[a](opt: Option[a], default: a) -> a {
  match opt {
    Some(x) => x,
    None => default
  }
}
```

**‚ùå WRONG - This is Rust/other languages, NOT AILANG:**
```rust
type Option {        // ‚ùå Wrong - no { } braces
  Some(value)        // ‚ùå Wrong - not AILANG syntax
  None
}

Option::Some(42)     // ‚ùå Wrong - AILANG has no :: operator
fn divide(a, b) { }  // ‚ùå Wrong - use 'func' not 'fn'
```

**‚úÖ CORRECT - Use constructors directly:**
```ailang
Some(42)             // ‚úÖ Correct - no namespace needed
None                 // ‚úÖ Correct
```

## Available Imports

**std/io** - IO operations (requires `! {IO}` effect)
```ailang
import std/io (println, print, readLine)

export func main() -> () ! {IO} {
  println("text")
}
```

**std/fs** - File operations (requires `! {FS}` effect)
```ailang
import std/fs (readFile, writeFile, exists)

export func readData() -> string ! {FS} {
  readFile("data.txt")
}
```

**std/option** - Option type
```ailang
import std/option (Option, Some, None)
```

## Recursion (instead of loops)

```ailang
export func factorial(n: int) -> int {
  if n <= 1
  then 1
  else n * factorial(n - 1)
}

export func sum(xs: [int]) -> int {
  match xs {
    [] => 0,
    _ => head(xs) + sum(tail(xs))
  }
}
```

## Common Mistakes to Avoid

‚ùå **Don't use for/while loops:**
```ailang
for i in [1, 2, 3] { println(i) }  -- ‚ùå NOT supported
```

‚úÖ **Use recursion or pattern matching:**
```ailang
export func printAll(xs: [int]) -> () ! {IO} {
  match xs {
    [] => (),
    _ => {
      println(show(head(xs)));
      printAll(tail(xs))
    }
  }
}
```

‚ùå **Don't use mutable variables:**
```ailang
var x = 5
x = x + 1  -- ‚ùå NOT supported
```

‚úÖ **Use let bindings:**
```ailang
let x = 5;
let y = x + 1;
y
```

‚ùå **Don't forget module and export:**
```ailang
func main() {  -- ‚ùå Missing 'module' declaration and 'export'
  println("hello")
}
```

‚úÖ **Always use module and export:**
```ailang
module examples/hello
import std/io (println)

export func main() -> () ! {IO} {
  println("hello")
}
```

## Complete Working Examples

### Example 1: Safe Division with Option
```ailang
module benchmark/solution

import std/io (println)

type Option[a] = Some(a) | None

export func safeDivide(a: float, b: float) -> Option[float] {
  if b == 0.0
  then None
  else Some(a / b)
}

export func printResult(result: Option[float]) -> () ! {IO} {
  match result {
    Some(v) => println("Result: " ++ show(v)),
    None => println("Error: Division by zero")
  }
}

export func main() -> () ! {IO} {
  let r1 = safeDivide(10.0, 2.0);
  printResult(r1);
  let r2 = safeDivide(10.0, 0.0);
  printResult(r2)
}
```

### Example 2: Recursive Loop (FizzBuzz pattern)
```ailang
module benchmark/solution

import std/io (println)

export func loop(start: int, end: int, action: int -> () ! {IO}) -> () ! {IO} {
  if start > end
  then ()
  else {
    action(start);
    loop(start + 1, end, action)
  }
}

export func main() -> () ! {IO} {
  loop(1, 10, \i. println(show(i)))
}
```

### Example 3: List Processing (NO for loops!)
```ailang
module benchmark/solution

import std/io (println)

export func printEach(xs: [int]) -> () ! {IO} {
  match xs {
    [] => (),
    _ => {
      println(show(head(xs)));
      printEach(tail(xs))
    }
  }
}

export func main() -> () ! {IO} {
  printEach([1, 2, 3, 4, 5])
}
```

## Summary

**Structure:**
1. Start with `module benchmark/solution` (REQUIRED for benchmarks!)
2. Import what you need from stdlib (`import std/io (println)`)
3. Define exported functions with `export func name(params) -> ReturnType { }`
4. Declare effects with `! {IO, FS}` when using IO/FS operations
5. Use recursion instead of loops - AILANG has NO for/while loops!

**Remember:**
- ‚úÖ Use `func` NOT `fn`, `function`, or `def`
- ‚úÖ ADTs use `type Name[a] = Cons1(a) | Cons2` syntax
- ‚úÖ NO `::` operator - use constructors directly
- ‚úÖ NO for/while loops - use recursion
- ‚úÖ Everything is immutable (no `var` or mutation)
- ‚úÖ Pattern matching uses `=>` arrows
- ‚úÖ Functions need type signatures
- ‚úÖ Effects must be declared with `! {IO}` or `! {FS}` or `! {IO, FS}`
- ‚úÖ Program runs via: `ailang run file.ail --entry main --caps IO`

**If you're not sure, look at the examples above!** They show the exact AILANG syntax.

---

# AI Prompt: v0.3.0.md

# AILANG AI Teaching Prompt (v0.3.0)

**CRITICAL: You MUST write code in AILANG syntax. This is NOT Python, NOT Rust, NOT JavaScript.**

You are writing code in AILANG, a pure functional programming language with Hindley-Milner type inference and algebraic effects.

**IMPORTANT SYNTAX RULES:**
- Use `func` NOT `fn`, `function`, or `def`
- Use `type Name[a] = Constructor(a) | Constructor2` NOT `type Name { }` or `enum`
- NO namespace syntax (`::`), just use constructor names directly
- Semicolons REQUIRED between statements in blocks
- Pattern matching uses `=>` NOT `:` or `->`
- NO `for`, `while`, `var`, `const`, `let mut`, or any imperative constructs

## Current Version: v0.3.0 (October 2025)

**‚úÖ WHAT WORKS:**
- ‚úÖ **Module declarations** - `module path/to/module`
- ‚úÖ **Function declarations** - `export func name(params) -> Type { body }`
- ‚úÖ **Import statements** - `import std/io (println)`, `import std/clock (now, sleep)`, `import std/net (httpGet)`
- ‚úÖ **Pattern matching** - Constructors, tuples, lists, wildcards, **guards** (`if` conditions)
- ‚úÖ **Effect system** - `! {IO, FS, Clock, Net}` for side effects with capability security
- ‚úÖ **ADTs** - Algebraic data types: `type Option[a] = Some(a) | None`
- ‚úÖ **Recursion** - Self-recursive and mutually-recursive functions with stack overflow protection
- ‚úÖ **Block expressions** - `{ stmt1; stmt2; result }` for sequencing
- ‚úÖ **Records** - Record literals, field access, subsumption
- ‚úÖ **Type system fixes** - Modulo operator (`%`) and float comparison (`==`) both work correctly

**‚ö†Ô∏è LIMITATIONS:**
- ‚ö†Ô∏è NO `for`/`while` loops - use recursion
- ‚ö†Ô∏è NO `var` - everything is immutable
- ‚ö†Ô∏è NO record update syntax `{r | field: val}` (yet)
- ‚ö†Ô∏è NO error propagation operator `?` (yet)
- ‚ö†Ô∏è NO custom HTTP headers (OpenAI/Claude APIs blocked until v0.4.0)
- ‚ö†Ô∏è `show` is a builtin - do NOT import it

## Module Structure

Every AILANG program must be a module with exported functions:

```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello, World!")
}
```

**IMPORTANT**: Always use `module benchmark/solution` as the module name for benchmark programs.

## Functions

```ailang
-- Simple pure function
export func add(x: int, y: int) -> int {
  x + y
}

-- Function with effects (IO, FS)
export func greet(name: string) -> () ! {IO} {
  println("Hello, " ++ name)
}

-- Generic function
export func identity[a](x: a) -> a {
  x
}

-- Multi-statement body (SEMICOLONS REQUIRED!)
export func compute() -> int {
  let x = 10;
  let y = 20;
  x + y
}
```

## Block Expressions (NEW in v0.3.0!)

Blocks allow sequencing statements with semicolons:

```ailang
export func demo() -> () ! {IO} {
  {
    println("First");
    println("Second");
    println("Third")
  }
}

-- Blocks are expressions - the last value is returned
export func compute() -> int {
  {
    let x = 10;
    let y = 20;
    x + y
  }
}
```

**CRITICAL**: Semicolons REQUIRED between statements! Missing semicolons will cause parse errors.

## Records (NEW in v0.3.0!)

Records are structural types with named fields:

```ailang
-- Record literal
let person = {name: "Alice", age: 30, city: "NYC"}

-- Field access
person.name    -- "Alice"
person.age     -- 30

-- Use in functions
export func describe(p: {name: string, age: int}) -> string {
  p.name ++ " is " ++ show(p.age)
}
```

**‚ö†Ô∏è IMPORTANT**: Record update syntax `{r | field: val}` is NOT yet implemented.
To create a modified record, create a new record literal:

```ailang
-- ‚ùå NOT supported yet:
let older = {person | age: 31}

-- ‚úÖ Instead do this:
let older = {name: person.name, age: 31, city: person.city}
```

## Algebraic Data Types (ADTs)

**‚úÖ CORRECT AILANG SYNTAX:**
```ailang
type Option[a] = Some(a) | None
type Result[a, e] = Ok(a) | Err(e)
type List[a] = Cons(a, List[a]) | Nil

export func getOrElse[a](opt: Option[a], default: a) -> a {
  match opt {
    Some(x) => x,
    None => default
  }
}
```

**‚ùå WRONG - This is Rust/other languages, NOT AILANG:**
```rust
type Option {        // ‚ùå Wrong - no { } braces
  Some(value)        // ‚ùå Wrong - not AILANG syntax
  None
}

Option::Some(42)     // ‚ùå Wrong - AILANG has no :: operator
fn divide(a, b) { }  // ‚ùå Wrong - use 'func' not 'fn'
```

**‚úÖ CORRECT - Use constructors directly:**
```ailang
Some(42)             // ‚úÖ Correct - no namespace needed
None                 // ‚úÖ Correct
```

## Available Imports

**std/io** - IO operations (requires `! {IO}` effect)
```ailang
import std/io (println, print, readLine)

export func main() -> () ! {IO} {
  println("text")
}
```

**std/fs** - File operations (requires `! {FS}` effect)
```ailang
import std/fs (readFile, writeFile, exists)

export func readData() -> string ! {FS} {
  readFile("data.txt")
}
```

**std/clock** - Time operations (requires `! {Clock}` effect) **NEW in v0.3.0!**
```ailang
import std/clock (now, sleep)

export func measureTime() -> () ! {IO, Clock} {
  let start = now();
  sleep(1000);  -- Sleep for 1 second (milliseconds)
  let end = now();
  println("Elapsed: " ++ show(end - start) ++ "ms")
}
```

**std/net** - HTTP operations (requires `! {Net}` effect) **NEW in v0.3.0!**
```ailang
import std/net (httpGet, httpPost)

export func fetchData() -> () ! {IO, Net} {
  let response = httpGet("https://api.example.com/data");
  println(response)
}
```

**IMPORTANT:**
- `show` is a BUILTIN function - do NOT import it from std/io!
- Clock and Net have security restrictions (no localhost, private IPs, file:// URLs blocked)
- Run with capabilities: `ailang run --caps IO,FS,Clock,Net --entry main file.ail`

**std/option** - Option type
```ailang
import std/option (Option, Some, None)
```

## Recursion (instead of loops)

Recursion works perfectly in v0.3.0:

```ailang
export func factorial(n: int) -> int {
  if n <= 1
  then 1
  else n * factorial(n - 1)
}

-- Recursion with IO effects and blocks
export func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}
```

## Common Mistakes to Avoid

‚ùå **Don't use for/while loops:**
```ailang
for i in [1, 2, 3] { println(i) }  -- ‚ùå NOT supported
```

‚úÖ **Use recursion:**
```ailang
export func printAll(xs: [int]) -> () ! {IO} {
  match xs {
    [] => (),
    _ => {
      println(show(head(xs)));
      printAll(tail(xs))
    }
  }
}
```

‚ùå **Don't forget semicolons in blocks:**
```ailang
{
  println("First")
  println("Second")  -- ‚ùå Parse error! Missing semicolon
}
```

‚úÖ **Add semicolons between statements:**
```ailang
{
  println("First");
  println("Second")  -- ‚úÖ Last statement doesn't need semicolon
}
```

‚ùå **Don't import show:**
```ailang
import std/io (println, show)  -- ‚ùå show not in std/io
```

‚úÖ **show is a builtin:**
```ailang
import std/io (println)
-- show is available automatically
println(show(42))
```

‚ùå **Don't forget module and export:**
```ailang
func main() {  -- ‚ùå Missing 'module' declaration and 'export'
  println("hello")
}
```

‚úÖ **Always use module and export:**
```ailang
module benchmark/solution
import std/io (println)

export func main() -> () ! {IO} {
  println("hello")
}
```

## Complete Working Examples

### Example 1: Safe Division with Option
```ailang
module benchmark/solution

import std/io (println)

type Option[a] = Some(a) | None

export func safeDivide(a: float, b: float) -> Option[float] {
  if b == 0.0
  then None
  else Some(a / b)
}

export func printResult(result: Option[float]) -> () ! {IO} {
  match result {
    Some(v) => println("Result: " ++ show(v)),
    None => println("Error: Division by zero")
  }
}

export func main() -> () ! {IO} {
  let r1 = safeDivide(10.0, 2.0);
  printResult(r1);
  let r2 = safeDivide(10.0, 0.0);
  printResult(r2)
}
```

### Example 2: Countdown with Recursion and Blocks
```ailang
module benchmark/solution

import std/io (println)

export func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}

export func main() -> () ! {IO} {
  countdown(5)
}
```

### Example 3: Records with Field Access
```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  let alice = {name: "Alice", age: 30, city: "NYC"};
  let bob = {name: "Bob", age: 25, city: "SF"};

  println(alice.name ++ ", " ++ show(alice.age) ++ ", " ++ alice.city);
  println(bob.name ++ ", " ++ show(bob.age) ++ ", " ++ bob.city)
}
```

## Summary

**Structure:**
1. Start with `module benchmark/solution` (REQUIRED for benchmarks!)
2. Import what you need from stdlib (`import std/io (println)`)
3. Define exported functions with `export func name(params) -> ReturnType { }`
4. Declare effects with `! {IO, FS}` when using IO/FS operations
5. Use recursion instead of loops - AILANG has NO for/while loops!
6. Use semicolons between statements in blocks

**Remember:**
- ‚úÖ Use `func` NOT `fn`, `function`, or `def`
- ‚úÖ ADTs use `type Name[a] = Cons1(a) | Cons2` syntax
- ‚úÖ NO `::` operator - use constructors directly
- ‚úÖ NO for/while loops - use recursion
- ‚úÖ Everything is immutable (no `var` or mutation)
- ‚úÖ Pattern matching uses `=>` arrows, guards work (`if` conditions)
- ‚úÖ Semicolons REQUIRED between statements in blocks
- ‚úÖ `show` is builtin - do NOT import it
- ‚úÖ Records: use literals and field access, NO update syntax yet
- ‚úÖ Effects must be declared: `! {IO}`, `! {FS}`, `! {Clock}`, `! {Net}`, or combinations
- ‚úÖ Modulo operator `%` works: `5 % 3` returns `2`
- ‚úÖ Float comparison works: `0.0 == 0.0` returns `true`
- ‚úÖ Four effects available: IO (console), FS (files), Clock (time), Net (HTTP)

**If you're not sure, look at the examples above!** They show the exact AILANG syntax.

**v0.3.0 Release Notes (October 2025):**
- Added Clock effect (monotonic time, sleep, deterministic mode)
- Added Net effect (HTTP GET/POST with DNS rebinding prevention, IP blocking)
- Fixed modulo operator (`%`) type defaulting
- Fixed float comparison (`==`) dictionary resolution
- Pattern matching guards now work correctly
- 48+ working examples demonstrating all features

---

# Examples Status

## Example Status

### Working Examples ‚úÖ
- `adt_option.ail`
- `adt_simple.ail`
- `arithmetic.ail`
- `block_recursion.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha2)
- `demos/adt_pipeline.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `demos/hello_io.ail`
- `effects_basic.ail`
- `effects_pure.ail`
- `guards_basic.ail`
- `hello.ail`
- `micro_block_if.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha2)
- `micro_block_seq.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha2)
- `micro_io_echo.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `micro_option_map.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `micro_record_person.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha3 M-R5 Day 3)
- `recursion_error.ail`
- `recursion_factorial.ail`
- `recursion_fibonacci.ail`
- `recursion_mutual.ail`
- `recursion_quicksort.ail`
- `showcase/01_type_inference.ail`
- `showcase/02_lambdas.ail`
- `showcase/03_type_classes.ail`
- `showcase/04_closures.ail`
- `simple.ail`
- `test_effect_annotation.ail`
- `test_effect_capability.ail`
- `test_effect_fs.ail`
- `test_effect_io.ail`
- `test_exhaustive_bool_complete.ail`
- `test_exhaustive_bool_incomplete.ail`
- `test_exhaustive_wildcard.ail`
- `test_guard_bool.ail`
- `test_guard_debug.ail`
- `test_guard_false.ail`
- `test_import_ctor.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `test_import_func.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `test_invocation.ail`
- `test_io_builtins.ail`
- `test_module_minimal.ail`
- `test_no_import.ail`
- `test_record_subsumption.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha3 M-R5 Day 3)
- `test_single_guard.ail`
- `test_use_constructor.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `test_with_import.ail`
- `type_classes_working_reference.ail`
- `v3_3/imports.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `v3_3/imports_basic.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)

### Failing Examples ‚ùå
- `demos/effects_pure.ail`
- `experimental/ai_agent_integration.ail`
- `experimental/concurrent_pipeline.ail`
- `experimental/factorial.ail`
- `experimental/quicksort.ail`
- `experimental/web_api.ail`
- `lambda_expressions.ail`
- `list_patterns.ail`
- `patterns.ail`
- `records.ail`
- `showcase/03_lists.ail`
- `test_effect_io_simple.ail`
- `typeclasses.ail`
- `v3_3/math/gcd.ail`

### Skipped Examples ‚è≠Ô∏è
- `block_demo.ail`
- `option_demo.ail`
- `stdlib_demo.ail`
- `stdlib_demo_simple.ail`

**Summary:** 48 passed, 14 failed, 4 skipped (Total: 66)

**Recent improvements:**
- ‚úÖ **M-R5 (v0.3.0-alpha3)**: 11 examples fixed/added via records & row polymorphism!
  - Day 1: 9 examples fixed (demos/adt_pipeline, micro_io_echo, micro_option_map, test_import_ctor, test_import_func, test_use_constructor, v3_3/imports, v3_3/imports_basic)
  - Day 3: 2 new examples (micro_record_person, test_record_subsumption)
- ‚úÖ **M-R8 (v0.3.0-alpha2)**: `micro_block_*.ail`, `block_recursion.ail` (3 files) - Block expressions with recursion
- ‚úÖ **M-R4 (v0.3.0-alpha1)**: `recursion_*.ail` (5 files) - Recursion support with RefCell indirection

---

