# : 

**Discovered**: AI Eval Analysis - 2025-10-08
**Frequency**: 3 failures across 1 benchmark(s)
**Priority**: P3 (Low Priority)
**Estimated**: 790 LOC, 3.5 days
**Category**: 
**Impact**: low

## Problem Statement

Several AI-generated benchmark programs fail to run because AILANG currently requires explicit module declarations, exported entry points, and disallows top-level executable expressions. Concretely, many snippets assume a "script mode" where writing println("hi") at the file top level executes when the file is run, or define an unexported func main() and expect the CLI to discover and run it automatically. These expectations are common across AI-generated code and human-written quick scripts.

The failures occur without clear error output in the harness because files parse and load but do not execute any entry, or entry resolution silently falls back to no-op if --entry is not specified and no exported main is found. Users expect a just-works experience: running a .ail file should execute either a discovered main or the file’s top-level expressions, with effect capabilities enforced as usual. The absence of script mode and lenient entry discovery is at odds with these expectations.

## Evidence from AI Eval

**Affected Benchmarks**: 

**Models Affected**: 

**Failure Rate**: 3/34 (8.8%)

### Example Failures



## Root Cause Analysis

AILANG presently enforces a strict module-first compilation and runtime path: a valid file must declare a module, export a function explicitly, and the runtime must be directed via --entry to invoke that function. There is no concept of a "script unit" or implicit module, and entry resolution ignores non-exported functions. Additionally, top-level expressions are not modeled as an executable body.

What’s missing is (1) a parse-time and load-time representation for script files (files without a module header or with top-level executable expressions), and (2) a runtime entry discovery mechanism that can select a sensible default entry (e.g., main) even if not exported, falling back to a synthetic main wrapping top-level expressions. Without these, AI-generated code that omits ceremony or relies on implicit behavior fails.

## Proposed Solution

Introduce Script Mode with Implicit Module and Lenient Entry Discovery:
1) Script Mode: When a file has no module declaration, treat it as a ScriptUnit. Parse top-level declarations (let, func) and top-level expressions. During load, synthesize an implicit module whose name derives from the file path, and inject a synthetic function __script_main() that sequences all top-level expressions into a block expression, returning unit. This function’s effect row is inferred normally, ensuring capability checks remain intact.
2) Entry Discovery: If --entry is not provided, attempt to select an entry automatically:
   - Prefer an explicitly exported function named main.
   - Else, if a non-exported top-level function named main exists, use it (visibility waived only for entry invocation).
   - Else, if in Script Mode, use synthetic __script_main.
   - Else, error with a clear message listing candidate functions.
This preserves security (effects still enforced via capabilities), requires no changes to the type system, and minimally adjusts the loader/runtime to wire a synthetic entry when appropriate. It integrates cleanly with the existing module runtime, effect system, and block expressions.

### Implementation Approach

- Add a ScriptUnit AST node to represent a file without a module header. It contains:
  - top-level declarations (let/func)
  - top-level expressions (sequence)
- Extend parser to detect absence of a module declaration and parse a ScriptUnit. Preserve existing module parsing unchanged.
- Extend loader to convert ScriptUnit into a synthetic module:
  - Assign a module name (e.g., script::<relative_path_without_ext>)
  - Create a synthetic exported function __script_main that sequences top-level expressions into a block expression returning ()
  - Register top-level declarations as normal module members
- Implement lenient entry discovery in runtime/loader:
  - If --entry is provided, use it as is (must exist, exported or not; if non-exported, allow only for entry)
  - If not provided, resolve as described in SOLUTION
- Ensure effect inference of __script_main is standard by constructing it as normal AST and letting existing inference compute effects
- Update CLI run behavior:
  - If no --entry and candidate found, run it and print a friendly note at higher verbosity; default output unchanged
  - Preserve capability requirement behavior
- Add clear error messages for ambiguous main (multiple candidates) and for no candidate in non-script modules
- Tests: unit tests for parsing ScriptUnit and AST conversion; integration tests for script execution, entry discovery, and capability enforcement
- Documentation and examples: Add examples of script files and auto-entry modules

## Technical Design

### API Changes

- CLI: If --entry is omitted, the runtime auto-discovers an entry (exported main, private main, or synthetic __script_main for scripts). No breaking changes; explicit --entry continues to work and takes precedence.

### Type System Changes

None

### Runtime Changes

- Entry discovery allows invoking non-exported main strictly as an entry
- ScriptUnit synthesis of __script_main executed like any other function
- No changes to capability enforcement or effect handler runtime

## Implementation Plan


1. **1. AST: Add ScriptUnit and synthetic entry metadata (~60 LOC, 0.5 day) - internal/ast/*.go; define ScriptUnit, update module/file root types, constructors.** (~TBD LOC, TBD)
   

2. **2. Parser: Script mode parsing and top-level expression list (~120 LOC, 0.75 day) - internal/parser/parser.go; detect absence of "module", parse decls + expressions, reuse existing block parsing.** (~TBD LOC, TBD)
   

3. **3. Loader: ScriptUnit → Module synthesis (~180 LOC, 1 day) - internal/loader/loader.go; create implicit module name, build __script_main with block of exprs, register decls.** (~TBD LOC, TBD)
   

4. **4. Entry Discovery Rules (~90 LOC, 0.5 day) - internal/runtime/module_runtime.go or internal/runtime/entry.go; resolve exported main, private main, synthetic main; ambiguity handling.** (~TBD LOC, TBD)
   

5. **5. Export Waiver for Entry Invocation (~40 LOC, 0.25 day) - internal/runtime/module_runtime.go; allow invoking non-exported main only as entry; does not change visibility elsewhere.** (~TBD LOC, TBD)
   

6. **6. Effect Inference Wiring for Synthetic Main (~30 LOC, 0.25 day) - internal/types/infer.go; ensure constructing __script_main feeds normal inference path; no special-casing beyond AST shape.** (~TBD LOC, TBD)
   

7. **7. CLI: Default entry selection and messaging (~50 LOC, 0.25 day) - cmd/ailang/main.go; if --entry not set, use entry discovery; preserve flags-before-filename behavior.** (~TBD LOC, TBD)
   

8. **8. Errors: New error codes/messages (~40 LOC, 0.25 day) - internal/errors/errors.go; ERR_ENTRY_NOT_FOUND, ERR_ENTRY_AMBIGUOUS, HINT_SCRIPT_MODE.** (~TBD LOC, TBD)
   

9. **9. Unit Tests (~160 LOC, 0.75 day) - internal/parser/tests, internal/loader/tests, internal/runtime/tests; cover parsing and synthesis.** (~TBD LOC, TBD)
   

10. **10. Integration Tests and Examples (~180 LOC, 1 day) - tests/, examples/; script io, net, clock; non-exported main; ambiguous mains; missing main fallback.** (~TBD LOC, TBD)
   


## Testing Strategy

### Unit Tests



### Integration Tests

- ailang run script without module, with top-level println; requires --caps IO; prints expected output
- ailang run module with unexported func main; runs successfully without specifying --entry
- ailang run module with exported and non-exported main; exported preferred
- ailang run script using Net; requires --caps Net,IO; security validations still enforced
- ailang run script with no expressions and no main; exits with clear error
- ailang run module with multiple candidate mains; errors with list of candidates

### New Benchmarks

- scripts/hello_script.ail: top-level println
- scripts/http_script.ail: top-level httpGet + println with Net effect
- modules/private_main.ail: unexported main that prints
- modules/ambiguous_main.ail: main and Main, ensure error and guidance
- scripts/clock_script.ail: top-level now/sleep/println sequence

## Success Criteria


- [ ] Files without module headers run successfully via synthetic __script_main

- [ ] Non-exported func main is discoverable and runnable as default entry

- [ ] Effect capabilities are still required and enforced for synthetic main

- [ ] Clear, actionable errors for ambiguous or missing entry in non-script modules

- [ ] No regressions in existing module-based execution and imports

- [ ] All new unit and integration tests pass in CI

- [ ] Affected AI benchmarks transition from fail to pass without prompt changes


## References

- **Similar Features**: See design_docs/implemented/ for reference implementations
- **Design Docs**: CLAUDE.md, README.md, design_docs/planned/v0_4_0_net_enhancements.md
- **AILANG Architecture**: See CLAUDE.md, README.md

## Estimated Impact

**Before Fix**:
- AI success rate: 0% on affected patterns (script files and non-exported main usage)%
- Token efficiency: Higher boilerplate required (module header, export, explicit --entry) causing larger prompts and generated code

**After Fix** (projected):
- AI success rate: 90-100% on affected patterns (expected residual errors due to capability flags or security policies)%
- Token efficiency: Reduced boilerplate (no mandatory module header/export for simple scripts); shorter, more natural AI-generated snippets run directly
`;

---

*Generated by ailang eval-analyze on 2025-10-08 15:01:54*
*Model: gpt5*
