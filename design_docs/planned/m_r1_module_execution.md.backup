# M-R1: Module Execution Runtime

**Milestone**: M-R1 (Module Execution Runtime)
**Version**: v0.2.0
**Timeline**: 1.5-2 weeks
**Estimated LOC**: ~1,200 lines
**Priority**: CRITICAL (blocks all other v0.2.0 work)

---

## Executive Summary

M-R1 implements the **module execution runtime**, enabling module files to run after type-checking. This is the single most important feature for v0.2.0, transforming AILANG from a "type-checking toy" to a "functional programming language."

**Current State**: Modules parse ✅, type-check ✅, but cannot execute ❌
**Target State**: Modules execute successfully, producing runtime values ✅

---

## Problem Statement

### The Module Execution Gap (v0.1.0)

In v0.1.0, when you run a module file:

```bash
$ ailang run examples/demos/hello_io.ail
→ Type checking...
→ Effect checking...
✓ Running examples/demos/hello_io.ail

Note: Module evaluation not yet supported
  Entrypoint:  main
  Type:        () → () ! {IO}
  Parameters:  0
```

**What happens**:
1. ✅ File loads successfully
2. ✅ Parser creates AST
3. ✅ Type checker validates types
4. ✅ Entrypoint resolution finds `main`
5. ❌ **STOPS** - No runtime evaluation

**Why it fails**:
- `cmd/ailang/main.go` lines 283-299: Hardcoded error message
- No `ModuleInstance` concept
- No way to evaluate top-level declarations
- No cross-module import linking at runtime

### What Users Experience

**Non-Module Files (Work in v0.1.0)**:
```ailang
-- simple.ail (NO module declaration)
let x = 5 in
let y = 10 in
print("Result: " ++ show(x + y))
```

```bash
$ ailang run simple.ail
Result: 15  # ✅ Works!
```

**Module Files (Broken in v0.1.0)**:
```ailang
-- hello.ail (WITH module declaration)
module examples/hello

import stdlib/std/io (println)

export func main() -> () ! {IO} {
  println("Hello!")
}
```

```bash
$ ailang run hello.ail
Note: Module evaluation not yet supported  # ❌ Fails!
```

---

## Goals & Non-Goals

### Goals

1. **Module Execution**: Make module files runnable
2. **Cross-Module Imports**: Support `import` statements at runtime
3. **Export Resolution**: Bind exported functions to runtime values
4. **Entrypoint Calls**: Execute `main()` or other entrypoints
5. **Dependency Ordering**: Evaluate modules in topological order

### Non-Goals (Deferred to Later)

- ❌ Incremental compilation (v0.3.0+)
- ❌ Module caching across runs (v0.3.0+)
- ❌ Hot reloading (v0.4.0+)
- ❌ Separate compilation (v0.4.0+)
- ❌ Optimized module linking (v0.3.0+)

---

## Design

### Architecture Overview

```
┌──────────────┐
│ Source File  │
│ (.ail)       │
└──────┬───────┘
       │
       ▼
┌──────────────────┐
│ Parser           │  Existing (v0.1.0)
│ (AST)            │
└──────┬───────────┘
       │
       ▼
┌──────────────────┐
│ Type Checker     │  Existing (v0.1.0)
│ (Interfaces)     │
└──────┬───────────┘
       │
       ▼
┌──────────────────┐
│ Module Loader    │  Existing (v0.1.0)
│ (Dep Graph)      │  → LoadedModule with Iface
└──────┬───────────┘
       │
       ▼
┌──────────────────┐
│ ** NEW **        │
│ Runtime Builder  │  ← M-R1 Implementation
│ (ModuleInstance) │
└──────┬───────────┘
       │
       ▼
┌──────────────────┐
│ Module Evaluator │  ← M-R1 Implementation
│ (Eval Decls)     │
└──────┬───────────┘
       │
       ▼
┌──────────────────┐
│ Entrypoint Call  │  ← M-R1 Implementation
│ (Execute main)   │
└──────┬───────────┘
       │
       ▼
┌──────────────────┐
│ Result           │
│ (Output)         │
└──────────────────┘
```

### Key Data Structures

#### 1. ModuleInstance (NEW)

**File**: `internal/runtime/module.go`
**Size**: ~200 LOC

```go
// ModuleInstance represents a runtime module with evaluated bindings
type ModuleInstance struct {
    // Identity
    Path string // Module path (e.g., "stdlib/std/io")

    // Static Information (from type-checking)
    Iface *iface.Iface // Module interface (exports, types)
    Core  *core.Program // Compiled Core AST

    // Runtime State
    Bindings map[string]eval.Value // All top-level bindings
    Exports  map[string]eval.Value // Exported bindings only
    Imports  map[string]*ModuleInstance // Imported modules

    // Evaluation State
    Evaluated bool // Whether module has been evaluated
    Error     error // Evaluation error (if any)
}

// NewModuleInstance creates a new module instance from a loaded module
func NewModuleInstance(loaded *loader.LoadedModule) *ModuleInstance {
    return &ModuleInstance{
        Path:     loaded.Path,
        Iface:    loaded.Iface,
        Core:     loaded.Core,
        Bindings: make(map[string]eval.Value),
        Exports:  make(map[string]eval.Value),
        Imports:  make(map[string]*ModuleInstance),
        Evaluated: false,
    }
}

// GetExport retrieves an exported value
func (mi *ModuleInstance) GetExport(name string) (eval.Value, error) {
    if !mi.Evaluated {
        return nil, fmt.Errorf("module %s not yet evaluated", mi.Path)
    }

    val, ok := mi.Exports[name]
    if !ok {
        return nil, fmt.Errorf("export %s not found in module %s", name, mi.Path)
    }

    return val, nil
}
```

#### 2. ModuleRuntime (NEW)

**File**: `internal/runtime/runtime.go`
**Size**: ~300 LOC

```go
// ModuleRuntime manages module instances and evaluation
type ModuleRuntime struct {
    instances map[string]*ModuleInstance // Path → Instance
    loader    *loader.ModuleLoader       // For loading dependencies
    evaluator *eval.CoreEvaluator        // For evaluating Core AST
}

// NewModuleRuntime creates a new module runtime
func NewModuleRuntime(basePath string) *ModuleRuntime {
    return &ModuleRuntime{
        instances: make(map[string]*ModuleInstance),
        loader:    loader.NewModuleLoader(basePath),
        evaluator: eval.NewCoreEvaluator(),
    }
}

// LoadAndEvaluate loads a module and all its dependencies, then evaluates them
func (mr *ModuleRuntime) LoadAndEvaluate(modulePath string) (*ModuleInstance, error) {
    // 1. Check cache
    if inst, ok := mr.instances[modulePath]; ok {
        if inst.Evaluated {
            return inst, nil
        }
        if inst.Error != nil {
            return nil, inst.Error
        }
    }

    // 2. Load module (type-checks, builds interface)
    loaded, err := mr.loader.Load(modulePath)
    if err != nil {
        return nil, err
    }

    // 3. Create module instance
    inst := NewModuleInstance(loaded)
    mr.instances[modulePath] = inst

    // 4. Recursively load and evaluate dependencies
    for _, importPath := range loaded.Imports {
        depInst, err := mr.LoadAndEvaluate(importPath)
        if err != nil {
            inst.Error = err
            return nil, fmt.Errorf("failed to load dependency %s: %w", importPath, err)
        }
        inst.Imports[importPath] = depInst
    }

    // 5. Evaluate this module
    if err := mr.evaluateModule(inst); err != nil {
        inst.Error = err
        return nil, err
    }

    inst.Evaluated = true
    return inst, nil
}

// evaluateModule evaluates a module's Core AST to populate bindings
func (mr *ModuleRuntime) evaluateModule(inst *ModuleInstance) error {
    // Set up global resolver for cross-module references
    mr.evaluator.SetGlobalResolver(&moduleGlobalResolver{
        currentModule: inst,
        runtime:       mr,
    })

    // Evaluate top-level declarations in order
    for _, decl := range inst.Core.Decls {
        switch d := decl.(type) {
        case *core.LetRec:
            // Evaluate let rec bindings
            bindings, err := mr.evaluator.EvalLetRecBindings(d)
            if err != nil {
                return fmt.Errorf("failed to evaluate let rec: %w", err)
            }

            // Store bindings
            for name, val := range bindings {
                inst.Bindings[name] = val

                // If exported, add to exports
                if _, isExported := inst.Iface.Exports[name]; isExported {
                    inst.Exports[name] = val
                }
            }

        default:
            return fmt.Errorf("unsupported top-level declaration: %T", d)
        }
    }

    return nil
}
```

#### 3. GlobalResolver Implementation (NEW)

**File**: `internal/runtime/resolver.go`
**Size**: ~100 LOC

```go
// moduleGlobalResolver resolves global references for module evaluation
type moduleGlobalResolver struct {
    currentModule *ModuleInstance
    runtime       *ModuleRuntime
}

// ResolveValue resolves a global reference to a runtime value
func (r *moduleGlobalResolver) ResolveValue(ref core.GlobalRef) (eval.Value, error) {
    // Case 1: Reference to current module
    if ref.Module == r.currentModule.Path || ref.Module == "" {
        val, ok := r.currentModule.Bindings[ref.Name]
        if !ok {
            return nil, fmt.Errorf("undefined binding %s in module %s", ref.Name, r.currentModule.Path)
        }
        return val, nil
    }

    // Case 2: Reference to imported module
    importedModule, ok := r.currentModule.Imports[ref.Module]
    if !ok {
        return nil, fmt.Errorf("module %s not imported by %s", ref.Module, r.currentModule.Path)
    }

    // Get exported value from imported module
    val, err := importedModule.GetExport(ref.Name)
    if err != nil {
        return nil, fmt.Errorf("failed to resolve %s from module %s: %w", ref.Name, ref.Module, err)
    }

    return val, nil
}
```

### Execution Flow

#### Step-by-Step: Running a Module

**Input**: `ailang run examples/demo.ail`

**Step 1: Parsing & Type-Checking** (Existing, v0.1.0)
```
examples/demo.ail
    ↓
Parser (AST)
    ↓
Type Checker (Interfaces)
    ↓
Module Loader (LoadedModule with Core + Iface)
```

**Step 2: Runtime Initialization** (NEW, M-R1)
```go
// cmd/ailang/main.go (modified)
runtime := runtime.NewModuleRuntime(basePath)
```

**Step 3: Load and Evaluate** (NEW, M-R1)
```go
// Load module and all dependencies
inst, err := runtime.LoadAndEvaluate("examples/demo")
if err != nil {
    // Handle evaluation error
    return err
}
```

**Step 4: Entrypoint Execution** (NEW, M-R1)
```go
// Get entrypoint from exports
entrypoint, err := inst.GetExport("main")
if err != nil {
    // Entrypoint not found
    return err
}

// Call entrypoint (zero-arg or single-arg)
result, err := callEntrypoint(entrypoint, args)
if err != nil {
    // Execution error
    return err
}

// Print result
fmt.Println(result)
```

### Integration with Existing Code

#### Changes to `cmd/ailang/main.go`

**Current Code** (v0.1.0, lines 283-299):
```go
// LIMITATION: Module evaluation not yet supported
fmt.Fprintf(os.Stderr, "\n%s: Module evaluation not yet supported\n", yellow("Note"))
// ... error message ...
os.Exit(1)
```

**New Code** (M-R1):
```go
// Module execution with runtime
rt := runtime.NewModuleRuntime(filepath.Dir(filename))

// Load and evaluate module
inst, err := rt.LoadAndEvaluate(result.ModulePath)
if err != nil {
    fmt.Fprintf(os.Stderr, "%s: module evaluation failed: %v\n", red("Error"), err)
    os.Exit(1)
}

// Get entrypoint
entrypointVal, err := inst.GetExport(entry)
if err != nil {
    fmt.Fprintf(os.Stderr, "%s: entrypoint '%s' not found\n", red("Error"), entry)
    os.Exit(1)
}

// Call entrypoint
result, err := callEntrypoint(entrypointVal, arg)
if err != nil {
    fmt.Fprintf(os.Stderr, "%s: entrypoint execution failed: %v\n", red("Error"), err)
    os.Exit(1)
}

// Print result (if not Unit)
if _, isUnit := result.(*eval.UnitValue); !isUnit {
    fmt.Println(result)
}
```

---

## Implementation Plan

### Phase 1: Core Data Structures (Days 1-2)

**Goal**: Create `ModuleInstance` and `ModuleRuntime`

**Tasks**:
1. Create `internal/runtime/` package
2. Implement `ModuleInstance` struct (~100 LOC)
3. Implement `ModuleRuntime` struct (~150 LOC)
4. Write unit tests (~200 LOC)

**Deliverable**: Compiling code with tests

### Phase 2: Module Evaluation (Days 3-5)

**Goal**: Evaluate modules to populate bindings

**Tasks**:
1. Implement `evaluateModule()` (~200 LOC)
2. Implement `moduleGlobalResolver` (~100 LOC)
3. Handle top-level `LetRec` declarations
4. Write evaluation tests (~300 LOC)

**Deliverable**: Single module evaluation works

### Phase 3: Import Linking (Days 6-8)

**Goal**: Support cross-module imports

**Tasks**:
1. Implement `LoadAndEvaluate()` with dependency resolution (~150 LOC)
2. Link imported modules to instances
3. Test multi-module programs (~400 LOC tests)

**Deliverable**: Multi-module programs execute

### Phase 4: Entrypoint Execution (Days 9-10)

**Goal**: Call entrypoints and produce output

**Tasks**:
1. Implement `callEntrypoint()` (~100 LOC)
2. Modify `cmd/ailang/main.go` (~150 LOC)
3. Test all example files (~200 LOC tests)

**Deliverable**: Module examples execute successfully

### Phase 5: Testing & Polish (Days 11-14)

**Goal**: Robust, well-tested module runtime

**Tasks**:
1. Integration tests with real examples
2. Error message improvements
3. Performance testing and optimization
4. Documentation updates

**Deliverable**: Production-ready M-R1

---

## Testing Strategy

### Unit Tests (~1,000 LOC)

**Test Files**:
- `internal/runtime/module_test.go` (~300 LOC)
- `internal/runtime/runtime_test.go` (~400 LOC)
- `internal/runtime/resolver_test.go` (~300 LOC)

**Test Cases**:
1. **Module Instance Creation**
   - Create instance from LoadedModule
   - Export table population
   - Import table population

2. **Module Evaluation**
   - Single module with bindings
   - Exported vs non-exported bindings
   - Recursive bindings

3. **Cross-Module Imports**
   - Import single module
   - Import multiple modules
   - Transitive imports (A → B → C)
   - Circular imports (should error)

4. **Global Resolution**
   - Resolve local binding
   - Resolve imported binding
   - Error on undefined binding
   - Error on non-imported module

5. **Entrypoint Execution**
   - Zero-arg entrypoint
   - Single-arg entrypoint
   - Non-existent entrypoint (error)
   - Non-function entrypoint (error)

### Integration Tests (~500 LOC)

**Test Files**:
- `tests/integration/module_execution_test.go` (~500 LOC)

**Test Cases**:
1. **Simple Module Execution**
   ```ailang
   module test/simple
   export func main() -> int { 42 }
   ```
   Expected: `42`

2. **Module with Import**
   ```ailang
   module test/with_import
   import test/simple (main as simpleMain)
   export func main() -> int { simpleMain() + 1 }
   ```
   Expected: `43`

3. **Stdlib Import**
   ```ailang
   module test/stdlib
   import stdlib/std/io (println)
   export func main() -> () ! {IO} {
     println("Hello!")
   }
   ```
   Expected: `Hello!`

4. **Multi-Module Chain**
   ```
   A imports B imports C
   ```
   Expected: All modules evaluate in order, A calls B calls C

### Example Verification

**Target**: 27 broken examples should work after M-R1

**Priority Examples**:
1. `examples/demos/hello_io.ail` - Module with IO
2. `examples/option_demo.ail` - Module with ADT
3. `examples/stdlib_demo.ail` - Module with stdlib imports
4. `examples/v3_3/*.ail` - All v3.3 import tests

**Verification Command**:
```bash
make verify-examples
# Expected: 35+ passing (up from 12)
```

---

## Error Handling

### Error Cases & Messages

1. **Module Not Found**
   ```
   Error: module 'foo/bar' not found
     Searched:
       - /path/to/foo/bar.ail (does not exist)
       - stdlib/foo/bar.ail (does not exist)
     Did you mean:
       - foo/baz
   ```

2. **Circular Import**
   ```
   Error: circular import detected
     Import cycle: A → B → C → A
   ```

3. **Undefined Binding**
   ```
   Error: undefined binding 'foo' in module 'test/example'
     Available bindings: [bar, baz, qux]
   ```

4. **Import Not Found**
   ```
   Error: module 'test/example' does not import 'foo/bar'
     Available imports: [std/io, std/option]
   ```

5. **Export Not Found**
   ```
   Error: export 'main' not found in module 'test/example'
     Available exports: [helper, process]
   ```

---

## Performance Considerations

### Module Instance Caching

**Strategy**: Cache evaluated modules to avoid re-evaluation

```go
// Cache hit
if inst, ok := mr.instances[modulePath]; ok && inst.Evaluated {
    return inst, nil // ← Fast path, no re-evaluation
}
```

**Impact**: O(1) lookups for already-evaluated modules

### Dependency Ordering

**Strategy**: Topological sort ensures each module evaluated once

```go
// Evaluate dependencies first (depth-first)
for _, importPath := range loaded.Imports {
    depInst, err := mr.LoadAndEvaluate(importPath) // ← Cached on 2nd call
    if err != nil {
        return nil, err
    }
}
```

**Impact**: O(N) evaluation where N = number of unique modules

### Memory Usage

**Estimate**: ~1-10 MB per module instance
- Bindings: ~100 KB (average)
- Core AST: ~500 KB (average)
- Iface: ~50 KB (average)

**Strategy**: Lazy loading (load modules only when imported)

---

## Future Optimizations (Post-M-R1)

### v0.3.0: Incremental Compilation

- **Goal**: Only re-evaluate changed modules
- **Approach**: Track file timestamps, cache `.ailc` files
- **Impact**: 10-100x faster on large projects

### v0.4.0: Separate Compilation

- **Goal**: Compile modules independently
- **Approach**: Module bytecode, linker
- **Impact**: Parallel compilation, faster builds

### v0.5.0: Hot Reloading

- **Goal**: Reload modules without restarting
- **Approach**: Module versioning, state migration
- **Impact**: Interactive development

---

## Risks & Mitigation

### Risk 1: Circular Dependencies (HIGH)

**Risk**: Modules with circular imports cause infinite loops

**Mitigation**:
- Detect cycles during LoadAndEvaluate
- Fail early with clear error message
- Document that circular imports are forbidden

**Fallback**: For v0.2.0, simply error on cycles. Future versions may support restricted circular imports.

### Risk 2: Memory Leaks (MEDIUM)

**Risk**: Module instances not garbage collected

**Mitigation**:
- Profile memory usage with large programs
- Implement module unloading (if needed)
- Document expected memory usage

**Fallback**: Document memory requirements, add `--max-modules` flag

### Risk 3: Evaluation Errors (MEDIUM)

**Risk**: Runtime errors during module evaluation

**Mitigation**:
- Comprehensive error handling
- Clear error messages with context
- Test error cases extensively

**Fallback**: Add `--strict` flag to catch errors earlier

---

## Success Criteria

### Minimum Success

- ✅ Module instances created from LoadedModules
- ✅ Single module evaluation works
- ✅ Cross-module imports work
- ✅ Entrypoints callable
- ✅ 20+ examples passing (up from 12)

### Stretch Goals

- ✅ 30+ examples passing
- ✅ Module caching working
- ✅ Error messages excellent
- ✅ Performance competitive with Python

---

## Dependencies

### Upstream (Must Exist Before M-R1)

- ✅ Module loader (`internal/loader/`)
- ✅ Module interfaces (`internal/iface/`)
- ✅ Core evaluator (`internal/eval/eval_core.go`)
- ✅ Type checking infrastructure

### Downstream (Depend on M-R1)

- ❌ M-R2 (Effect System) - Needs module runtime
- ❌ M-R3 (Pattern Matching) - Benefits from module runtime
- ❌ stdlib implementation - Needs module execution

---

## Documentation

### User-Facing Documentation

1. **docs/guides/module-execution.md** (NEW)
   - How module execution works
   - Module instance lifecycle
   - Debugging module issues

2. **README.md** (UPDATE)
   - Remove "module execution gap" limitation
   - Add "module execution" to "What Works"

3. **examples/README.md** (UPDATE)
   - Update example status
   - Add module execution examples

### Developer Documentation

1. **CLAUDE.md** (UPDATE)
   - Add M-R1 implementation notes
   - Document ModuleInstance, ModuleRuntime

2. **internal/runtime/README.md** (NEW)
   - Architecture overview
   - API reference
   - Common patterns

---

**Status**: Design Complete
**Next Steps**: Begin Phase 1 implementation
**Estimated Completion**: 2 weeks from start

---

*Document Version*: v1.0
*Created*: 2025-10-02
*Last Updated*: 2025-10-02
*Author*: AILANG Development Team
