module std_list

export type Option[a] = Some(a) | None

export pure func map[a, b](f: (a) -> b, xs: [a]) -> [b] {
  match xs {
    [] => [],
    [x, ...rest] => [f(x), ...map(f, rest)]
  }
}

export pure func filter[a](p: (a) -> bool, xs: [a]) -> [a] {
  match xs {
    [] => [],
    [x, ...rest] =>
      if p(x) then [x, ...filter(p, rest)]
              else filter(p, rest)
  }
}

export pure func foldl[a, b](f: (b, a) -> b, acc: b, xs: [a]) -> b {
  match xs {
    [] => acc,
    [x, ...rest] => foldl(f, f(acc, x), rest)
  }
}

export pure func foldr[a, b](f: (a, b) -> b, acc: b, xs: [a]) -> b {
  match xs {
    [] => acc,
    [x, ...rest] => f(x, foldr(f, acc, rest))
  }
}

export pure func length[a](xs: [a]) -> int {
  foldl(\n. \_. n + 1, 0, xs)
}

export pure func head[a](xs: [a]) -> Option[a] {
  match xs {
    [] => None,
    [x, ..._] => Some(x)
  }
}

export pure func tail[a](xs: [a]) -> [a] {
  match xs {
    [] => [],
    [_ , ...rest] => rest
  }
}

export pure func reverse[a](xs: [a]) -> [a] {
  foldl(\acc. \x. [x, ...acc], [], xs)
}

export pure func concat[a](xs: [a], ys: [a]) -> [a] {
  match xs {
    [] => ys,
    [x, ...rest] => [x, ...concat(rest, ys)]
  }
}

export pure func zip[a, b](xs: [a], ys: [b]) -> [(a, b)] {
  match (xs, ys) {
    ([],     _)        => [],
    (_,      [])       => [],
    ([x,...xr], [y,...yr]) => [(x, y), ...zip(xr, yr)]
  }
}
