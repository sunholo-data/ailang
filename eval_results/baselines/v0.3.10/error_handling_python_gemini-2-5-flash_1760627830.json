{
  "id": "error_handling",
  "lang": "python",
  "model": "gemini-2-5-flash",
  "seed": 42,
  "input_tokens": 294,
  "output_tokens": 1039,
  "total_tokens": 1333,
  "cost_usd": 0.0026857,
  "compile_ok": true,
  "runtime_ok": true,
  "stdout_ok": true,
  "duration_ms": 52,
  "compile_ms": 0,
  "execute_ms": 0,
  "error_category": "none",
  "stdout": "Result: 5\nError: Division by zero\nError: Invalid integer\n",
  "expected_stdout": "Result: 5\nError: Division by zero\nError: Invalid integer\n",
  "timestamp": "2025-10-16T17:17:10.910646+02:00",
  "code": "from typing import TypeVar, Generic, Callable, Union\n\nT = TypeVar('T')  # Type for the success value\nE = TypeVar('E')  # Type for the error value\nU = TypeVar('U')  # Type for the success value after transformation\n\nclass Result(Generic[T, E]):\n    \"\"\"Base class for Ok and Err variants.\"\"\"\n    def is_ok(self) -\u003e bool:\n        return False\n\n    def is_err(self) -\u003e bool:\n        return False\n\n    def unwrap(self) -\u003e T:\n        raise NotImplementedError\n\n    def unwrap_err(self) -\u003e E:\n        raise NotImplementedError\n    \n    def and_then(self, func: Callable[[T], 'Result[U, E]']) -\u003e 'Result[U, E]':\n        raise NotImplementedError\n\n\nclass Ok(Result[T, E]):\n    \"\"\"Represents a successful result with a value.\"\"\"\n    def __init__(self, value: T):\n        self._value = value\n\n    def is_ok(self) -\u003e bool:\n        return True\n\n    def unwrap(self) -\u003e T:\n        return self._value\n\n    def unwrap_err(self) -\u003e E:\n        raise RuntimeError(\"Called unwrap_err on an Ok value.\")\n\n    def __repr__(self) -\u003e str:\n        return f\"Ok({self._value!r})\"\n    \n    def and_then(self, func: Callable[[T], 'Result[U, E]']) -\u003e 'Result[U, E]':\n        return func(self._value)\n\n\nclass Err(Result[T, E]):\n    \"\"\"Represents a failed result with an error message.\"\"\"\n    def __init__(self, message: E):\n        self._message = message\n\n    def is_err(self) -\u003e bool:\n        return True\n\n    def unwrap(self) -\u003e T:\n        raise RuntimeError(f\"Called unwrap on an Err value: {self._message!r}\")\n\n    def unwrap_err(self) -\u003e E:\n        return self._message\n\n    def __repr__(self) -\u003e str:\n        return f\"Err({self._message!r})\"\n\n    def and_then(self, func: Callable[[T], 'Result[U, E]']) -\u003e 'Result[U, E]':\n        # If the current state is Err, short-circuit and return this error.\n        # We need to return an Err of type Result[U, E], preserving the error message.\n        return Err(self._message) # type: ignore[return-value]\n\n\ndef parse_int(s: str) -\u003e Result[int, str]:\n    \"\"\"\n    Parses a string into an integer wrapped in a Result type.\n    Returns Ok(n) if parsing is successful, Err(\"Invalid integer\") otherwise.\n    \"\"\"\n    try:\n        n = int(s)\n        return Ok(n)\n    except ValueError:\n        return Err(\"Invalid integer\")\n\n\ndef divide_safe(a: int, b: int) -\u003e Result[int, str]:\n    \"\"\"\n    Performs integer division of a by b wrapped in a Result type.\n    Returns Ok(a // b) if b is not zero, Err(\"Division by zero\") otherwise.\n    \"\"\"\n    if b == 0:\n        return Err(\"Division by zero\")\n    return Ok(a // b)\n\n\ndef print_final_result(res: Result[int, str]):\n    \"\"\"\n    Prints the final result based on whether it's Ok or Err.\n    \"\"\"\n    if res.is_ok():\n        print(f\"Result: {res.unwrap()}\")\n    else:\n        print(f\"Error: {res.unwrap_err()}\")\n\n\n# Test cases\n# 1. parse_int(\"10\") then divide by 2 -\u003e \"Result: 5\"\nresult1 = parse_int(\"10\").and_then(lambda n: divide_safe(n, 2))\nprint_final_result(result1)\n\n# 2. parse_int(\"10\") then divide by 0 -\u003e \"Error: Division by zero\"\nresult2 = parse_int(\"10\").and_then(lambda n: divide_safe(n, 0))\nprint_final_result(result2)\n\n# 3. parse_int(\"abc\") -\u003e \"Error: Invalid integer\"\n# The division won't even be attempted if parse_int returns an Err.\nresult3 = parse_int(\"abc\").and_then(lambda n: divide_safe(n, 10))\nprint_final_result(result3)",
  "first_attempt_ok": true,
  "repair_used": false,
  "repair_ok": false
}