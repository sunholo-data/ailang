-- v2_type_inference.ail
-- Pure lambda calculus demonstrating Phase 1 type inference
-- No arithmetic = no Num constraints = clean type checking!

-- 1. Polymorphic identity function
let id = \x. x in                    -- Inferred: ∀α. α → α

-- 2. Const combinator (K)
let const = \x y. x in                -- Inferred: ∀α β. α → β → α

-- 3. Function composition
let compose = \f g x. f(g(x)) in      -- Inferred: ∀α β γ. (β → γ) → (α → β) → α → γ

-- 4. Self-application (shows unification)
let apply = \f x. f(x) in             -- Inferred: ∀α β. (α → β) → α → β

-- 5. Church booleans
let tru = \t f. t in                  -- Inferred: ∀α β. α → β → α
let fls = \t f. f in                  -- Inferred: ∀α β. α → β → β

-- 6. Boolean operations (fixed for proper typing)
let band = \p q t f. p(q(t)(f))(f) in -- Boolean AND
let bor = \p q t f. p(t)(q(t)(f)) in  -- Boolean OR  
let bnot = \p t f. p(f)(t) in         -- Boolean NOT

-- 7. Church numerals (pure functions, no arithmetic!)
let zero = \f x. x in                 -- 0 = f^0(x) = x
let one = \f x. f(x) in               -- 1 = f^1(x) = f(x)
let two = \f x. f(f(x)) in            -- 2 = f^2(x) = f(f(x))

-- 8. Successor function for Church numerals
let succ = \n f x. f(n(f)(x)) in      -- Adds 1 to a Church numeral

-- 9. Complex type inference with multiple instantiations
let twice = \f. compose(f)(f) in      -- Apply function twice
let quad = twice(twice) in            -- Apply 4 times

-- Final expression: demonstrate polymorphism
apply(id)(const)