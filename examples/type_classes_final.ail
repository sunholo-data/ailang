-- Type Classes & Dictionary-Passing Demo
-- This example demonstrates AILANG's type class resolution system
-- All type class constraints are resolved to dictionary calls during compilation

-- Basic Arithmetic with Num type class
let demo1 = 
  let sum = 1 + 2 in              -- Uses Num[Int] dictionary
  let diff = 10 - 5 in            -- Uses Num[Int] dictionary  
  let prod = 3 * 4 in             -- Uses Num[Int] dictionary
  let quot = 20 / 4 in            -- Uses Num[Int] dictionary
  print("=== Basic Arithmetic (Int) ===") in
  print("1 + 2 = " ++ show(sum)) in
  print("10 - 5 = " ++ show(diff)) in  
  print("3 * 4 = " ++ show(prod)) in
  print("20 / 4 = " ++ show(quot)) in
  
-- Floating point arithmetic
let demo2 =
  let pi = 3.14159 in
  let tau = pi * 2.0 in           -- Uses Num[Float] dictionary
  let half_pi = pi / 2.0 in       -- Uses Num[Float] dictionary
  print("") in
  print("=== Floating Point (Float) ===") in
  print("pi * 2.0 = " ++ show(tau)) in
  print("pi / 2.0 = " ++ show(half_pi)) in

-- Equality comparisons with Eq type class  
let demo3 =
  let int_eq = 42 == 42 in        -- Uses Eq[Int] dictionary
  let int_neq = 10 == 20 in       -- Uses Eq[Int] dictionary
  print("") in
  print("=== Equality Tests (Eq) ===") in
  print("42 == 42 = " ++ show(int_eq)) in
  print("10 == 20 = " ++ show(int_neq)) in

-- Ordering comparisons with Ord type class
let demo4 =
  let lt = 5 < 10 in              -- Uses Ord[Int] dictionary
  let gt = 20 > 15 in             -- Uses Ord[Int] dictionary
  print("") in
  print("=== Ordering Tests (Ord) ===") in
  print("5 < 10 = " ++ show(lt)) in
  print("20 > 15 = " ++ show(gt)) in

-- Polymorphic function with Num constraint
let demo5 =
  let double = \x. x + x in       -- Has constraint: Num a => a -> a
  let int_double = double(5) in   -- Instantiated at Int
  let float_double = double(2.5) in -- Instantiated at Float
  print("") in
  print("=== Polymorphic Functions ===") in
  print("double(5) = " ++ show(int_double)) in
  print("double(2.5) = " ++ show(float_double)) in

-- Complex expression with multiple constraints
let demo6 =
  let result = if 3 < 5 then 10 + 5 else 20 - 5 in
  -- Uses Ord[Int] for comparison, Num[Int] for arithmetic
  print("") in
  print("=== Complex Expressions ===") in
  print("if 3 < 5 then 10 + 5 else 20 - 5 = " ++ show(result)) in
  
-- String comparisons
let demo7 =
  let str_lt = "apple" < "banana" in  -- Uses Ord[String] dictionary
  let str_eq = "hello" == "hello" in  -- Uses Eq[String] dictionary
  print("") in
  print("=== String Comparisons ===") in
  print("'apple' < 'banana' = " ++ show(str_lt)) in
  print("'hello' == 'hello' = " ++ show(str_eq)) in

-- Demonstrate defaulting
let demo8 =
  -- Literals without explicit type default to Int
  let x = 42 in                   -- Defaults to Int
  let y = 3.14 in                 -- Explicitly Float
  let sum = x + x in              -- Uses Num[Int]
  let prod = y * y in             -- Uses Num[Float]
  print("") in
  print("=== Defaulting Behavior ===") in
  print("42 + 42 (defaults to Int) = " ++ show(sum)) in
  print("3.14 * 3.14 (Float) = " ++ show(prod)) in
  
-- Run all demos
print("") in
print("====================================") in
print("Type Classes & Dictionary-Passing") in  
print("====================================") in
demo1 in
demo2 in
demo3 in
demo4 in
demo5 in
demo6 in
demo7 in
demo8 in
print("") in
print("All type class constraints resolved!")