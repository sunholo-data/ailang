-- Type Classes and Dictionary-Passing Demo
-- Demonstrates the complete pipeline from source to evaluation

module type_classes_demo

-- Basic arithmetic with type defaulting
-- These literals will default to Int type
let simple = 1 + 2 * 3 - 4

-- Floating point operations
let pi = 3.14159
let circle_area = pi * 10.0 * 10.0

-- Comparisons using Eq and Ord type classes
let test_eq = 42 == 42        -- Uses Eq[Int] dictionary
let test_neq = "hello" != "world"  -- Uses Eq[String] dictionary
let test_ord = 5 < 10 && 10 <= 15  -- Uses Ord[Int] dictionary

-- Unary negation
let negative = -100
let negFloat = -2.718

-- Function with type class constraint
pure func sum3(x: int, y: int, z: int) -> int {
  x + y + z
}

-- Using the function
let total = sum3(10, 20, 30)

-- Conditional with comparisons
pure func abs(n: int) -> int {
  if n < 0 then -n else n
}

-- Pattern matching with equality
pure func isZero(n: int) -> bool {
  n == 0
}

-- List operations
let nums = [1, 2, 3, 4, 5]
let firstIsOne = head(nums) == 1

-- Record with computed fields
let stats = {
  min: if 10 < 20 then 10 else 20,
  max: if 10 > 20 then 10 else 20,
  sum: 10 + 20,
  avg: (10 + 20) / 2
}

-- Demonstrating law-compliant Float equality
-- Our Eq[Float] makes NaN reflexive for law compliance
pure func testNaN() -> bool {
  let x = 0.0 / 0.0  -- NaN
  x == x              -- Returns true (reflexive)
}

-- Total ordering for Float
-- NaN is treated as greater than all other values
pure func compareWithNaN(x: float) -> bool {
  let nan = 0.0 / 0.0
  x < nan  -- Always true unless x is also NaN
}

-- Main computation
let main = {
  arithmetic: simple,
  area: circle_area,
  absolute: abs(-50),
  stats: stats,
  tests: {
    eq: test_eq,
    neq: test_neq,
    ord: test_ord,
    zero: isZero(0),
    nanReflexive: testNaN()
  }
}