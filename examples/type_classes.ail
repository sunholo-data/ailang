-- Type Classes and Dictionary Passing Example
-- Shows explicit dictionary passing for AILANG v2.0

-- Basic arithmetic with Num type class
let add_numbers = 2 + 3
-- Elaborates to: let dict1 = Num[Int].add in let add_numbers = dict1(2, 3)

-- Comparison with Ord type class  
let compare_values = 5 < 10
-- Elaborates to: let dict2 = Ord[Int].lt in let compare_values = dict2(5, 10)

-- Equality checking with Eq type class
let check_equality = "hello" == "world"
-- Elaborates to: let dict3 = Eq[String].eq in let check_equality = dict3("hello", "world")

-- Mixed operations requiring multiple type classes
let complex_expr = if (1 + 2) < 5 then "small" else "large"
-- Elaborates to:
-- let dict4 = Num[Int].add in
-- let dict5 = Ord[Int].lt in  
-- let dict6 = dict4(1, 2) in
-- let complex_expr = if dict5(dict6, 5) then "small" else "large"

-- Let polymorphism with type classes
let poly_func = \x. x + x
-- Type: ∀α. Num[α] ⇒ α → α
-- When applied, creates dictionary call: dict.add(x, x)

let apply_to_int = poly_func(5)    -- Uses Num[Int]
let apply_to_float = poly_func(3.14) -- Uses Num[Float]

-- Superclass provision: Ord provides Eq
-- If we have Ord[SomeType] but no explicit Eq[SomeType],
-- the system derives Eq from Ord using: eq(x,y) = ¬lt(x,y) ∧ ¬lt(y,x)

-- Show class for string conversion
let show_int = show(42)
-- Elaborates to: let dict7 = Show[Int].show in let show_int = dict7(42)

-- Numeric literal defaulting
let defaulted = 42  -- Defaults to Int when ambiguous
-- Without annotation, Num[α] ⇒ α defaults to Num[Int] ⇒ Int