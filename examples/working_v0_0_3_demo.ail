-- working_v3_2_demo.ail
-- Working examples for AILANG v3.2 features
-- These examples work with the current implementation

-- ============================================================================
-- WORKING IN REPL
-- ============================================================================

-- Basic arithmetic (works)
1 + 2
42 * 2

-- String concatenation (works)
"Hello, " ++ "AILANG!"

-- Booleans (works)
true && false
true || false

-- Lists (works)
[1, 2, 3]
[true, false, true]

-- Records (works - creation only, no field access yet)
{name: "Alice", age: 30}

-- Let expressions (works with single line or multi-line)
let x = 10 in x * 2
let y = true in if y then 42 else 0

-- Lambda expressions (works)
(\x. x + 1)(5)
let double = \x. x * 2 in double(21)

-- Nested let (works on single line)
let x = 5 in let y = 10 in x + y

-- ============================================================================
-- V3.2 REPL COMMANDS 
-- ============================================================================

-- Test the effects inspector
-- :effects 1 + 2
-- :effects \x. x * 2

-- Test JSON output modes
-- :compact on
-- :effects 5 + 5
-- :compact off

-- Run tests (when test cases are defined)
-- :test --json

-- ============================================================================
-- MULTI-LINE INPUT IN REPL
-- ============================================================================

-- The REPL now supports multi-line input for let expressions
-- When you type a line ending with " in", it will prompt with "..."

-- Example 1: Simple multi-line let
-- λ> let x = 42 in
-- ... x * 2
-- Result: 84 :: Int

-- Example 2: Nested multi-line let
-- λ> let x = 10 in
-- ... let y = 20 in
-- ... x + y
-- Result: 30 :: Int

-- Example 3: Let with record
-- λ> let user = {name: "Bob", age: 25} in
-- ... user
-- Result: {name: Bob, age: 25} :: {name: String, age: Int}

-- ============================================================================
-- TYPE CLASS FEATURES (WORKING)
-- ============================================================================

-- Type inference with constraints
-- :type \x. x + x
-- Result: ∀α. Num α ⇒ α → α

-- Defaulting in action
42      -- Defaults to Int
3.14    -- Parsed as Float

-- Show instances
-- :instances
-- Shows available type class instances

-- ============================================================================
-- NOTES ON CURRENT LIMITATIONS
-- ============================================================================

-- 1. Record field access (r.field) not yet implemented
-- 2. Pattern matching not fully implemented  
-- 3. Import statements being refined
-- 4. Type annotations in let expressions not yet supported
-- 5. Effects system is placeholder only

-- These features are part of the roadmap for future releases