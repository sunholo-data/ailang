-- ⚠️ WARNING: This example does not work with current implementation
-- Requires: func declarations, tests syntax, properties syntax, pattern matching
-- Status: Parser fails on 'tests' and 'properties' syntax
-- Try simple.ail or arithmetic.ail for working examples
--
-- factorial.ail: Demonstrates pure functions with tests and properties
module Factorial

-- Pure recursive factorial with inline tests
pure func factorial(n: int) -> int
  tests [
    (0, 1),
    (1, 1),
    (5, 120),
    (10, 3628800)
  ]
  properties [
    forall(n: int) where n >= 0 => factorial(n) > 0,
    forall(n: int) where n > 0 => factorial(n) == n * factorial(n - 1)
  ]
{
  if n <= 1 then 1 else n * factorial(n - 1)
}

-- Tail-recursive version using an accumulator
pure func factorialTail(n: int) -> int {
  let rec loop = (n: int, acc: int) -> int =>
    if n <= 1 then acc else loop(n - 1, n * acc)
  in
    loop(n, 1)
}

-- Pattern matching version
pure func factorialMatch(n: int) -> int {
  match n {
    0 => 1,
    1 => 1,
    n if n > 1 => n * factorialMatch(n - 1),
    _ => 0  -- Negative numbers return 0
  }
}

-- Test that all implementations are equivalent
test "factorial implementations" {
  forall(n: int) where n >= 0 && n <= 20 =>
    factorial(n) == factorialTail(n) &&
    factorial(n) == factorialMatch(n)
}