# AILANG Documentation for LLMs

This file contains all AILANG documentation in a single file for LLM consumption.

Last updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

---


# README

# AILANG: The AI-First Programming Language

![CI](https://github.com/sunholo-data/ailang/workflows/CI/badge.svg)
![Coverage](https://img.shields.io/badge/coverage-29.0%25-orange.svg)
![Go Version](https://img.shields.io/badge/go-%3E%3D1.22-blue.svg)
![License](https://img.shields.io/badge/license-Apache%202.0-green.svg)

AILANG is a purely functional programming language designed specifically for AI-assisted software development. It features static typing with algebraic effects, typed quasiquotes for safe string handling, CSP-based concurrency with session types, and automatic generation of training data for AI model improvement.

## Current Version: v0.3.0 (Clock & Net Effects + Type System Fixes)

**üéØ What Works**: Full module execution, **Clock effect** (monotonic time), **Net effect** (HTTP GET/POST with security), **record subsumption**, **row polymorphism** (opt-in), complete Hindley-Milner type inference, type classes (Num, Eq, Ord, Show), lambda calculus, REPL with full type checking, module execution runtime, effect system (IO, FS, Clock, Net with capability security), cross-module imports, pattern matching with exhaustiveness checking, **block expressions**, and **recursion support**.

**‚úÖ Major Milestones**:
- **Clock effect** with monotonic time and virtual time for deterministic execution
- **Net effect** with full Phase 2 PM security hardening:
  - DNS rebinding prevention
  - Protocol validation (https enforced, file:// blocked)
  - IP blocking (localhost, private IPs, link-local)
  - Redirect validation with IP re-check
  - Body size limits (5MB default)
  - Domain allowlist with wildcard support
- Records support subsumption: functions accepting `{id: int}` work with larger records
- Row polymorphism available via `AILANG_RECORDS_V2=1`

**üìä Test Coverage**: 48/66 examples passing (72.7%). All record subsumption, effect system (IO, FS, Clock, Net), type class, ADT, recursion, and block expression examples working. See [examples/STATUS.md](examples/STATUS.md) for details.

**üìñ Documentation**: [Implementation Status](docs/reference/implementation-status.md) | [CHANGELOG.md](CHANGELOG.md)

## Quick Start

### Installation

```bash
# From source
git clone https://github.com/sunholo/ailang.git
cd ailang
make install

# Verify installation
ailang --version
```

For detailed installation instructions, see the [Getting Started Guide](docs/guides/getting-started.md).

### Hello World (Module Execution)

AILANG v0.2.0 now executes module files with effects:

```ailang
-- examples/demos/hello_io.ail
module examples/demos/hello_io

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello from AILANG v0.2.0!")
}
```

```bash
ailang run --caps IO examples/demos/hello_io.ail
# Output: Hello from AILANG v0.2.0!
```

**Important**: Flags must come BEFORE the filename:
```bash
# ‚úÖ CORRECT:
ailang run --caps IO --entry main file.ail

# ‚ùå WRONG:
ailang run file.ail --caps IO --entry main
```

More examples:
```bash
ailang run examples/arithmetic.ail                        # Arithmetic
ailang run examples/simple.ail                            # Let bindings
ailang run --caps IO --entry main examples/micro_block_seq.ail  # Block expressions
ailang run --caps IO --entry greet examples/test_io_builtins.ail  # IO effects
ailang run --caps Clock,IO --entry main examples/micro_clock_measure.ail  # Clock effect ‚ú® NEW
ailang run --caps Net,IO --entry main examples/demo_ai_api.ail  # Net effect (API calls) ‚ú® NEW
ailang run --entry greet examples/test_invocation.ail     # Cross-function calls
```

**‚ú® NEW: Clock & Net Effects** (v0.3.0-alpha4)
```ailang
-- Clock effect: Monotonic time (immune to NTP/DST)
import std/clock (now, sleep)

func benchmark() -> int ! {Clock, IO} {
  let start = now();
  sleep(100);  -- Sleep 100ms
  let elapsed = now() - start;
  elapsed
}
```

```ailang
-- Net effect: HTTP GET/POST with security hardening
import std/net (httpGet, httpPost)
import std/io (println)

func callAPI() -> () ! {Net, IO} {
  let response = httpGet("https://api.example.com/data");
  println(response)
}
```

**Net Security Features**:
- ‚úÖ HTTPS enforced (http:// requires `--net-allow-http`)
- ‚úÖ DNS rebinding prevention
- ‚úÖ IP blocking (localhost, private IPs, link-local)
- ‚úÖ Protocol blocking (file://, ftp://, data://)
- ‚úÖ Redirect validation (max 5 redirects)
- ‚úÖ Body size limits (5MB default)
- ‚úÖ Domain allowlist with wildcard support

**‚ú® Block Expressions** (v0.3.0)
```ailang
-- Blocks allow sequencing multiple expressions
{
  println("first");
  println("second");
  42  -- Value of block is the last expression
}

-- Perfect for recursive functions with logging:
func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}
```

See [examples/STATUS.md](examples/STATUS.md) for complete example inventory (48/66 passing).

### Interactive REPL (Fully Functional)

The REPL is the **most complete** part of AILANG v0.1.0, featuring full type inference and type classes:

```bash
ailang repl

Œª> 1 + 2
3 :: Int

Œª> "Hello " ++ "World"
Hello World :: String

Œª> let double = \x. x * 2 in double(21)
42 :: Int

Œª> :type \x. x + x
\x. x + x :: ‚àÄŒ±. Num Œ± ‚áí Œ± ‚Üí Œ±

Œª> let compose = \f. \g. \x. f(g(x)) in compose (\x. x * 2) (\x. x + 1) 5
12 :: Int

Œª> :quit
```

**REPL Commands**: `:help`, `:type <expr>`, `:instances`, `:import <module>`, `:history`, `:clear`

See [REPL Commands](docs/reference/repl-commands.md) for full reference.

## What Works in v0.1.0

### ‚úÖ Complete Type System

- **Hindley-Milner Type Inference** - Full polymorphic type inference with let-polymorphism
- **Type Classes** - `Num`, `Eq`, `Ord`, `Show` with dictionary-passing semantics
- **Constraint Solving** - Type class constraint generation and resolution
- **Defaulting** - Automatic defaulting for ambiguous numeric types (Int, Float)
- **Type Checking** - Module interface checking, export resolution, import validation

### ‚úÖ Lambda Calculus & Expressions

- **Lambda Expressions** - First-class functions with closures and currying
- **Function Composition** - Higher-order functions, partial application
- **Let Bindings** - Polymorphic let expressions (up to 3 nested levels)
- **Conditionals** - `if-then-else` expressions
- **Block Expressions** - `{ e1; e2; e3 }` for sequencing (desugars to let chains) ‚ú® NEW in v0.3.0
- **Operators** - Arithmetic (`+`, `-`, `*`, `/`), comparison (`==`, `<`, `>`, etc.), string concatenation (`++`)

### ‚úÖ Data Structures

- **Lists** - `[1, 2, 3]` with type inference
- **Records** - `{name: "Alice", age: 30}` with field access
- **Tuples** - `(1, "hello", true)` for heterogeneous data
- **Strings** - String literals with concatenation

### ‚úÖ Module System (Type-Checking Only)

- **Module Declarations** - `module path/to/module`
- **Import/Export** - `import stdlib/std/io (println)`, `export func main() ...`
- **Path Resolution** - Correct module path resolution and validation
- **Dependency Analysis** - Import graph construction, cycle detection
- **Interface Generation** - Module signatures with exported types/functions

**Note**: Modules parse and type-check correctly but cannot execute until v0.2.0. See [LIMITATIONS.md](docs/LIMITATIONS.md#critical-limitation-module-execution-gap).

### ‚úÖ Interactive Development

- **Professional REPL** - Arrow key history, tab completion, persistent history (`~/.ailang_history`)
- **Type Inspection** - `:type <expr>` shows qualified types with constraints
- **Instance Inspection** - `:instances` lists available type class instances
- **Debugging Tools** - `:dump-core`, `:dump-typed`, `:trace-defaulting`, `:dry-link`
- **Auto-imports** - `stdlib/std/prelude` loaded automatically

### ‚úÖ Error Reporting

- **Structured Errors** - JSON error output with schema versioning
- **Deterministic Diagnostics** - Stable error messages, line/column positions
- **Helpful Messages** - Type errors, parse errors, module loading errors

## What's Coming in v0.2.0

### üöÄ v0.2.0 Roadmap (Module Execution & Effects)

**M-R1: Module Execution Runtime** (~1,200 LOC, 1.5-2 weeks)
- Module instance creation and initialization
- Import resolution and linking at runtime
- Top-level function execution
- Exported function calls

**M-R2: Algebraic Effects Foundation** (~800 LOC, 1-1.5 weeks)
- Effect declarations and checking
- Effect handler syntax (`with`, `handle`)
- Capability-based effect system
- Basic effects: `IO`, `FS`, `Net`

**M-R3: Pattern Matching** (~600 LOC, 1 week)
- `match` expressions
- Pattern guards
- Exhaustiveness checking
- Constructor patterns for ADTs

**Total Timeline**: 3.5-4.5 weeks for v0.2.0

See [v0.2.0 Roadmap](design_docs/planned/v0_2_0_module_execution.md) for details.

### üìã Future Features (v0.3.0+)

- Typed quasiquotes (SQL, HTML, JSON, regex)
- CSP-based concurrency with channels
- Session types for protocol verification
- Property-based testing (`properties [...]`)
- AI training data export

<!-- EXAMPLES_STATUS_START -->
## Status

![Examples](https://img.shields.io/badge/examples-56%20passing%2022%20failing-red.svg)

### Example Verification Status

*Last updated: 2025-10-06 10:46:17 UTC*

**Summary:** 56 passed, 22 failed, 4 skipped (Total: 82)

| Example File | Status | Notes |
|--------------|--------|-------|
| `adt_option.ail` | ‚úÖ Pass |  |
| `adt_simple.ail` | ‚úÖ Pass |  |
| `arithmetic.ail` | ‚úÖ Pass |  |
| `block_demo.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `block_recursion.ail` | ‚úÖ Pass |  |
| `bug_float_comparison.ail` | ‚úÖ Pass |  |
| `bug_modulo_operator.ail` | ‚úÖ Pass |  |
| `demo_ai_api.ail` | ‚ùå Fail | Error: execution failed: effect 'Net' requires ... |
| `demo_openai_api.ail` | ‚ùå Fail | Error: execution failed: effect 'IO' requires c... |
| `demos/adt_pipeline.ail` | ‚úÖ Pass |  |
| `demos/effects_pure.ail` | ‚ùå Fail | Warning: import path 'stdlib/std/*' is deprecat... |
| `demos/hello_io.ail` | ‚úÖ Pass |  |
| `effects_basic.ail` | ‚úÖ Pass |  |
| `effects_pure.ail` | ‚úÖ Pass |  |
| `experimental/ai_agent_integration.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/concurrent_pipeline.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/factorial.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/quicksort.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/web_api.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `guards_basic.ail` | ‚úÖ Pass |  |
| `hello.ail` | ‚úÖ Pass |  |
| `lambda_expressions.ail` | ‚ùå Fail | Error: type error in examples/lambda_expression... |
| `list_patterns.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `micro_block_if.ail` | ‚úÖ Pass |  |
| `micro_block_seq.ail` | ‚úÖ Pass |  |
| `micro_clock_measure.ail` | ‚ùå Fail | Error: execution failed: effect 'Clock' require... |
| `micro_io_echo.ail` | ‚úÖ Pass |  |
| `micro_net_fetch.ail` | ‚ùå Fail | Error: execution failed: effect 'Net' requires ... |
| `micro_option_map.ail` | ‚úÖ Pass |  |
| `micro_record_person.ail` | ‚úÖ Pass |  |
| `option_demo.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `patterns.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `records.ail` | ‚ùå Fail | Error: type error in examples/records (decl 3):... |
| `recursion_error.ail` | ‚úÖ Pass |  |
| `recursion_factorial.ail` | ‚úÖ Pass |  |
| `recursion_fibonacci.ail` | ‚úÖ Pass |  |
| `recursion_mutual.ail` | ‚úÖ Pass |  |
| `recursion_quicksort.ail` | ‚úÖ Pass |  |
| `showcase/01_type_inference.ail` | ‚úÖ Pass |  |
| `showcase/02_lambdas.ail` | ‚úÖ Pass |  |
| `showcase/03_lists.ail` | ‚ùå Fail | Error: evaluation error: builtin concat_String ... |
| `showcase/03_type_classes.ail` | ‚úÖ Pass |  |
| `showcase/04_closures.ail` | ‚úÖ Pass |  |
| `simple.ail` | ‚úÖ Pass |  |
| `stdlib_demo.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `stdlib_demo_simple.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `test_effect_annotation.ail` | ‚úÖ Pass |  |
| `test_effect_capability.ail` | ‚úÖ Pass |  |
| `test_effect_fs.ail` | ‚úÖ Pass |  |
| `test_effect_io.ail` | ‚úÖ Pass |  |
| `test_effect_io_simple.ail` | ‚ùå Fail | Error: evaluation error: _io_println: no effect... |
| `test_exhaustive_bool_complete.ail` | ‚úÖ Pass |  |
| `test_exhaustive_bool_incomplete.ail` | ‚úÖ Pass |  |
| `test_exhaustive_wildcard.ail` | ‚úÖ Pass |  |
| `test_fizzbuzz.ail` | ‚úÖ Pass |  |
| `test_float_comparison.ail` | ‚úÖ Pass |  |
| `test_float_eq_works.ail` | ‚úÖ Pass |  |
| `test_float_modulo.ail` | ‚úÖ Pass |  |
| `test_guard_bool.ail` | ‚úÖ Pass |  |
| `test_guard_debug.ail` | ‚úÖ Pass |  |
| `test_guard_false.ail` | ‚úÖ Pass |  |
| `test_import_ctor.ail` | ‚úÖ Pass |  |
| `test_import_func.ail` | ‚úÖ Pass |  |
| `test_integral.ail` | ‚úÖ Pass |  |
| `test_invocation.ail` | ‚úÖ Pass |  |
| `test_io_builtins.ail` | ‚úÖ Pass |  |
| `test_m_r7_comprehensive.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `test_module_minimal.ail` | ‚úÖ Pass |  |
| `test_modulo_works.ail` | ‚úÖ Pass |  |
| `test_net_file_protocol.ail` | ‚ùå Fail | Error: execution failed: effect 'Net' requires ... |
| `test_net_localhost.ail` | ‚ùå Fail | Error: execution failed: effect 'Net' requires ... |
| `test_net_security.ail` | ‚ùå Fail | Error: execution failed: effect 'Net' requires ... |
| `test_no_import.ail` | ‚úÖ Pass |  |
| `test_record_subsumption.ail` | ‚úÖ Pass |  |
| `test_single_guard.ail` | ‚úÖ Pass |  |
| `test_use_constructor.ail` | ‚úÖ Pass |  |
| `test_with_import.ail` | ‚úÖ Pass |  |
| `type_classes_working_reference.ail` | ‚úÖ Pass |  |
| `typeclasses.ail` | ‚ùå Fail | Error: type error in examples/typeclasses (decl... |
| `v3_3/imports.ail` | ‚úÖ Pass |  |
| `v3_3/imports_basic.ail` | ‚úÖ Pass |  |
| `v3_3/math/gcd.ail` | ‚ùå Fail | Error: entrypoint 'main' not found in module |

<!-- EXAMPLES_STATUS_END -->

## Documentation

### User Documentation
- **[LIMITATIONS.md](docs/LIMITATIONS.md)** - ‚ö†Ô∏è Read this first! Current v0.1.0 limitations and workarounds
- **[Getting Started](docs/guides/getting-started.md)** - Installation and quick tutorial
- **[REPL Commands](docs/reference/repl-commands.md)** - Interactive REPL guide (fully functional)
- **[Language Syntax](docs/reference/language-syntax.md)** - Complete language reference
- **[Examples Status](examples/STATUS.md)** - Inventory of all 42 example files
- **[Examples README](examples/README.md)** - How to use and understand examples

### Development Documentation
- **[Implementation Status](docs/reference/implementation-status.md)** - Detailed component status with metrics
- **[Development Guide](docs/guides/development.md)** - Contributing and development workflow
- **[CLAUDE.md](CLAUDE.md)** - Instructions for AI assistants working on AILANG
- **[Changelog](CHANGELOG.md)** - Version history and release notes

### Design & Architecture
- **[AI-First Features](docs/ai-first-features.md)** - Why AILANG is designed for AI collaboration
- **[Design Documents](design_docs/)** - Architecture and design decisions
- **[v0.1.0 MVP Roadmap](design_docs/20250929/v0_1_0_mvp_roadmap.md)** - Current milestone plan
- **[Showcase Issues](docs/SHOWCASE_ISSUES.md)** - Known parser/execution limitations discovered during example creation

## Development

```bash
# Build and install
make install

# Run tests
make test

# Start REPL
make repl

# Run example
make run FILE=examples/hello.ail

# Auto-rebuild on changes
make watch-install

# Check coverage
make test-coverage-badge

# AI Evaluation & Design Generation (NEW! ‚ú®)
make eval-suite          # Run AI benchmarks (AILANG vs Python)
make eval-report         # Generate evaluation report
make eval-analyze        # Analyze failures, generate design docs (auto-dedup)
make eval-analyze-fresh  # Force new docs (disable dedup)
make eval-to-design      # Full workflow: evals ‚Üí analysis ‚Üí design docs
```

See the [Development Guide](docs/guides/development.md) for detailed instructions.

## Project Structure

```
ailang/
‚îú‚îÄ‚îÄ cmd/ailang/       # CLI entry point
‚îú‚îÄ‚îÄ internal/         # Core implementation
‚îÇ   ‚îú‚îÄ‚îÄ repl/         # Interactive REPL
‚îÇ   ‚îú‚îÄ‚îÄ lexer/        # Tokenizer
‚îÇ   ‚îú‚îÄ‚îÄ parser/       # Parser
‚îÇ   ‚îú‚îÄ‚îÄ types/        # Type system
‚îÇ   ‚îú‚îÄ‚îÄ eval/         # Evaluator
‚îÇ   ‚îî‚îÄ‚îÄ ...           # Other components
‚îú‚îÄ‚îÄ examples/         # Example programs
‚îú‚îÄ‚îÄ docs/             # Documentation
‚îú‚îÄ‚îÄ design_docs/      # Design documents
‚îî‚îÄ‚îÄ scripts/          # CI/CD scripts
```

## Contributing

AILANG is an experimental language in active development. Contributions are welcome! Please see the [Development Guide](docs/guides/development.md) for guidelines.

## License

Apache 2.0 - See [LICENSE](LICENSE) for details.

## Acknowledgments

AILANG draws inspiration from:
- Haskell (type system, purity)
- OCaml (module system, effects)
- Rust (capability-based security)
- Erlang/Go (CSP concurrency)

---

## FAQ

**Q: Can I use AILANG for production code?**
A: Not yet. v0.1.0 is an MVP focused on the type system. Module execution arrives in v0.2.0 (planned ~4 weeks).

**Q: What's the difference between REPL and file execution?**
A: The REPL is fully functional with type classes. File execution works for non-module files. Module files type-check but cannot execute until v0.2.0.

**Q: Which examples actually work?**
A: See [examples/STATUS.md](examples/STATUS.md). 12 examples execute successfully. The showcase examples in `examples/showcase/` demonstrate working features.

**Q: How can I help or contribute?**
A: See [Development Guide](docs/guides/development.md). We especially welcome testing, example creation, and documentation improvements.

**Q: What makes AILANG "AI-first"?**
A: Explicit effects, deterministic execution traces, structured errors, and typed metaprogramming make AILANG ideal for AI-assisted development and training data generation. See [AI-First Features](docs/ai-first-features.md).

---

*For AI agents: This is an experimental functional language with complete Hindley-Milner type inference, type classes (Num/Eq/Ord/Show), and lambda calculus. The REPL is fully functional. Non-module file execution works for expressions and let bindings. Module files type-check but cannot execute (runtime coming in v0.2.0). See [LIMITATIONS.md](docs/LIMITATIONS.md) and [Implementation Status](docs/reference/implementation-status.md) for exact capabilities.*
---

# CHANGELOG

# AILANG Changelog

## [Unreleased] - 2025-10-08

### Added - M-EVAL-LOOP Milestone 1: Self-Repair Foundation ‚úÖ COMPLETE

**Complete self-repair system for AI evaluation benchmarks with error taxonomy, retry logic, and CLI integration (~520 LOC in 3.5 hours).**

**Implementation** (`internal/eval_harness/`)
- **Error taxonomy** (`errors.go`, ~150 LOC)
  - 6 error codes: PAR_001, TC_REC_001, TC_INT_001, EQ_001, CAP_001, MOD_001
  - Regex-based error matching with repair hints
  - `CategorizeErrorCode()` matches stderr against patterns
  - `FormatRepairPrompt()` generates error-specific fix guidance
  - Structured RepairHint with Title/Why/How format
- **RepairRunner orchestration** (`repair.go`, ~140 LOC)
  - Single-shot self-repair loop: attempt ‚Üí error ‚Üí repair ‚Üí retry
  - `Run()` method handles first attempt + optional repair
  - `runSingleAttempt()` for code generation + execution cycles
  - `populateMetrics()` for comprehensive metrics tracking
  - Automatic error categorization and repair prompt injection
- **Extended metrics** (`metrics.go`, modified)
  - Self-repair tracking: FirstAttemptOk, RepairUsed, RepairOk
  - Error details: ErrCode, RepairTokensIn, RepairTokensOut
  - Prompt versioning: PromptVersion field (ready for A/B testing)
  - Reproducibility: BinaryHash, StdlibHash, Caps fields

**Tests** (`internal/eval_harness/errors_test.go`, ~200 LOC)
- 10 test cases covering all error codes
- Repair prompt formatting validation
- Rule completeness checks
- Regex pattern validation
- All tests passing ‚úÖ

**CLI Integration** (`cmd/ailang/eval.go`, modified)
- New `--self-repair` flag for single-shot repair
- RepairRunner integration replacing manual execution
- Enhanced output showing repair attempts and results
- Backward compatible (repair disabled by default)

**Usage:**
```bash
# Without self-repair (0-shot)
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5

# With self-repair (1-shot)
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5 --self-repair
```

**Files Modified:**
- `internal/eval_harness/errors.go` (+150 LOC)
- `internal/eval_harness/errors_test.go` (+200 LOC)
- `internal/eval_harness/repair.go` (+140 LOC)
- `internal/eval_harness/metrics.go` (+30 LOC)
- `cmd/ailang/eval.go` (refactored for RepairRunner)
- Total: ~520 LOC

**Key Design Decisions:**
1. Single-shot repair only (no infinite loops)
2. Error-specific repair hints (not generic "fix it")
3. Metrics track both first attempt and repair separately
4. RepairRunner owns orchestration (agent + runner coordination)
5. Backward compatible CLI (repair opt-in via flag)

**Velocity:** ~150 LOC/hour, ahead of schedule (estimated 6-8 hours, actual 3.5 hours)

---

### Added - M-EVAL-LOOP Milestone 2: Prompt Versioning & A/B Testing ‚úÖ COMPLETE

**Complete prompt versioning system for A/B testing teaching strategies across AI models (~570 LOC in 2 hours).**

**Prompt Registry** (`prompts/versions.json`)
- JSON-based registry with metadata for all prompt versions
- SHA256 hash verification for prompt integrity
- Version tags: baseline, experimental, production, historical, control
- Active version tracking for defaults
- Created 2 initial versions:
  - `v0.3.0-baseline`: Original teaching prompt (3,674 tokens)
  - `v0.3.0-hints`: Enhanced with 6 error pattern sections (4,538 tokens, +864 tokens)

**Prompt Loader** (`internal/eval_harness/prompt_loader.go`, ~120 LOC)
- `NewPromptLoader()` loads registry from `prompts/versions.json`
- `LoadPrompt(versionID)` with SHA256 hash verification
- `GetActivePrompt()` for default version
- `GetVersion()` and `ListVersions()` for metadata queries
- `ComputePromptHash()` helper for updating registry
- Placeholder hash support for work-in-progress prompts

**Prompt Variants** (`prompts/v0.3.0-hints.md`, +864 tokens)
- Added explicit error pattern warnings based on error taxonomy
- 6 common error sections with wrong/correct examples:
  - PAR_001: Missing semicolons in blocks
  - TC_REC_001: Accessing non-existent record fields
  - TC_INT_001: Using modulo on floats
  - EQ_001: Wrong equality dictionary
  - CAP_001: Missing effect capabilities
  - MOD_001: Undefined module/entrypoint
- Hypothesis: Explicit warnings reduce first-attempt failures and improve repair success

**Tests** (`internal/eval_harness/prompt_loader_test.go`, ~270 LOC)
- 10 comprehensive test cases
- Hash verification and mismatch detection
- Placeholder hash support
- Active prompt loading
- All tests passing ‚úÖ

**CLI Integration** (`cmd/ailang/eval.go`, modified)
- New `--prompt-version` flag for version selection
- Automatic prompt loading with hash verification
- Metrics tracking with PromptVersion field
- Custom prompt + task prompt composition

**A/B Testing Tools**
- `tools/eval_prompt_ab.sh` (~200 LOC): Run full benchmark suite with two prompts
- `tools/compare_results.sh` (~180 LOC): Analyze and compare results
- Beautiful terminal output with success rates, token counts, cost comparison
- Recommendations based on performance deltas

**Makefile Targets**
- `make eval-prompt-list`: Show all available prompt versions
- `make eval-prompt-hash`: Compute SHA256 hashes for all prompts
- `make eval-prompt-ab A=v0.3.0-baseline B=v0.3.0-hints`: Run A/B comparison

**Usage:**
```bash
# Use specific prompt version
ailang eval --benchmark fizzbuzz --prompt-version v0.3.0-hints

# A/B comparison
make eval-prompt-ab A=v0.3.0-baseline B=v0.3.0-hints

# List available versions
make eval-prompt-list
```

**Files Modified:**
- `prompts/versions.json` (new, registry)
- `prompts/v0.3.0-hints.md` (new, +864 tokens)
- `internal/eval_harness/prompt_loader.go` (+120 LOC)
- `internal/eval_harness/prompt_loader_test.go` (+270 LOC)
- `internal/eval_harness/repair.go` (added SetPromptVersion method)
- `cmd/ailang/eval.go` (added --prompt-version flag)
- `tools/eval_prompt_ab.sh` (+200 LOC)
- `tools/compare_results.sh` (+180 LOC)
- `Makefile` (+3 targets)
- Total: ~770 LOC

**Key Design Decisions:**
1. Hash verification prevents accidental prompt modification mid-experiment
2. Prompt version tracked in metrics for historical analysis
3. A/B scripts automate full benchmark suite comparison
4. Terminal-based output for fast iteration (no GUI required)
5. Backward compatible (version optional, falls back to benchmark default)

**Velocity:** ~385 LOC/hour (estimated 3-4 hours, actual 2 hours)

---

### Added - M-EVAL-LOOP Milestone 3: AI-Friendly Formats & Validation ‚úÖ COMPLETE

**Complete validation workflow with AI-friendly formats for performance tracking and fix validation (~900 LOC in 1.5 hours).**

**AI-Friendly Export Tools**
- `tools/generate_summary_jsonl.sh` (~90 LOC): Convert results to JSONL for AI analysis
  - One JSON object per line with key metrics
  - Easy querying with jq or AI tools
  - Fields: id, model, success rates, tokens, cost, errors, repair status
- `tools/generate_matrix_json.sh` (~140 LOC): Generate performance matrix JSON
  - Aggregates by model, benchmark, error code, language, prompt version
  - Historical tracking of 0-shot vs 1-shot success rates
  - Repair effectiveness metrics
  - Token and cost analytics

**Validation Workflow**
- `tools/eval_baseline.sh` (~120 LOC): Store baseline for current version
  - Runs full benchmark suite
  - Generates performance matrix
  - Creates baseline metadata with git commit info
  - Enables future validation via diff
- `tools/eval_diff.sh` (~140 LOC): Compare two eval runs
  - Shows fixed benchmarks (‚úì)
  - Shows broken benchmarks (‚úó)
  - Calculates success rate deltas
  - Beautiful terminal output with color coding
- `tools/eval_validate_fix.sh` (~140 LOC): Validate a specific fix
  - Compares against baseline
  - Shows before/after status
  - Detects regressions
  - Exit code 0 = validated, 1 = failed/still broken

**Makefile Integration** (5 new targets)
- `make eval-baseline`: Store current results as baseline
- `make eval-diff BASELINE=<dir> NEW=<dir>`: Compare runs
- `make eval-validate-fix BENCH=<id>`: Validate specific fix
- `make eval-summary DIR=<dir>`: Generate JSONL summary
- `make eval-matrix DIR=<dir> VERSION=<ver>`: Generate performance matrix

**Usage Examples:**
```bash
# Validation workflow
make eval-baseline                      # Store baseline
# ... make code changes ...
make eval-validate-fix BENCH=float_eq   # Validate fix
make eval-diff BASELINE=baselines/v0.3.0 NEW=after_fix  # Show all changes

# AI-friendly exports
make eval-summary DIR=eval_results/baseline OUTPUT=summary.jsonl
make eval-matrix DIR=eval_results/baseline VERSION=v0.3.0-alpha5

# Query with jq
jq -s 'group_by(.err_code) | map({code: .[0].err_code, count: length})' summary.jsonl
```

**Files Created:**
- `tools/generate_summary_jsonl.sh` (+90 LOC)
- `tools/generate_matrix_json.sh` (+140 LOC)
- `tools/eval_baseline.sh` (+120 LOC)
- `tools/eval_diff.sh` (+140 LOC)
- `tools/eval_validate_fix.sh` (+140 LOC)
- `Makefile` (+5 targets, ~80 LOC)
- Total: ~710 LOC scripts + ~190 LOC integration

**Key Design Decisions:**
1. JSONL format for streaming and AI-friendly analysis
2. Exit codes for CI/CD integration (0 = pass, 1 = fail)
3. Baseline storage with git metadata for reproducibility
4. Terminal-based workflow (no GUI dependencies)
5. Composable scripts (can chain together)

**Velocity:** ~600 LOC/hour (estimated 4-5 hours, actual 1.5 hours!)

**Cumulative M-EVAL-LOOP Progress:**
- **Milestones 1, 2 & 3 Complete**: ~2,960 LOC in 7 hours
- **Average velocity**: ~423 LOC/hour
- **Ahead of schedule**: ~7-9 hours saved

---

### Added - Documentation & AI Agent Integration

**Complete documentation and slash command for AI agent access to M-EVAL-LOOP workflows.**

**Website Documentation**
- Created comprehensive eval-loop guide at `docs/docs/guides/evaluation/eval-loop.md`
- Covers all 3 milestones: Self-Repair, Prompt Versioning, Validation
- Includes usage examples, workflow descriptions, and best practices
- AI-friendly format with code examples and command references

**Slash Command** (`/.claude/commands/eval-loop.md`)
- New `/eval-loop` command for AI agents
- Workflows: baseline, validate, diff, prompt-ab, summary, matrix
- Automatic execution via Makefile targets
- Integrated with Claude Code for seamless access

**llms.txt Updates**
- Extended `tools/generate-llms-txt.sh` to include Docusaurus subdirectories
- Added all evaluation guides including eval-loop documentation
- Size increased from 181KB to 244KB (8 M-EVAL-LOOP references)
- Published at https://sunholo-data.github.io/ailang/llms.txt

**AI Agent Usage:**
```
User: "Let's validate the float_eq fix"
Assistant: /eval-loop validate float_eq
# Executes: make eval-validate-fix BENCH=float_eq
# Output: "‚úì FIX VALIDATED: Benchmark now passing!"

User: "Compare prompts"
Assistant: /eval-loop prompt-ab v0.3.0-baseline v0.3.0-hints
# Executes: make eval-prompt-ab A=v0.3.0-baseline B=v0.3.0-hints
# Output: "+7% improvement with hints prompt"
```

**Files Modified:**
- `docs/docs/guides/evaluation/eval-loop.md` (new, comprehensive guide)
- `.claude/commands/eval-loop.md` (new, slash command)
- `tools/generate-llms-txt.sh` (extended to include subdirectories)
- `docs/llms.txt` (regenerated with +63KB of eval-loop docs)

---

## [v0.3.0] - 2025-10-05

Complete implementation of Clock & Net effects (M-R6) with full Phase 2 PM security hardening, plus critical type system fixes (M-R7) for modulo operator and float comparison.

### Added - M-R7 Type System Fixes ‚úÖ COMPLETE
- **Fixed modulo operator (`%`)**: Works correctly with type defaulting (`5 % 3` returns `2`)
- **Fixed float comparison (`==`)**: Resolves dictionary correctly (`0.0 == 0.0` returns `true`)
- **Regression tests**:
  - `examples/test_integral.ail` - Locks in modulo fix
  - `examples/test_float_comparison.ail` - Locks in float comparison fix
  - `examples/test_fizzbuzz.ail` - Exercises both `%` and `==` together
  - `benchmarks/numeric_modulo.yml` - Eval harness benchmark for `%`
  - `benchmarks/float_eq.yml` - Eval harness benchmark for `==`
  - All tests passing ‚úÖ

### Added - AI API Examples (with v0.4.0 roadmap)
- **`examples/demo_openai_api.ail`** - OpenAI API example with workaround for missing features
- **`design_docs/planned/v0_4_0_net_enhancements.md`** - Complete roadmap for Net enhancements:
  - Custom HTTP headers (`httpPostWithHeaders`)
  - Environment variable reading (`getEnv`, `hasEnv`)
  - JSON parsing (`parseJSON`, `getValue`)
  - Response status/headers

## [v0.3.0-alpha4] - 2025-10-05

### Added - M-R6 Phase 2: Clock & Net Effects ‚úÖ COMPLETE
- **Clock effect** (`internal/effects/clock.go`, 109 LOC)
  - `_clock_now()` returns current time in milliseconds since Unix epoch
  - `_clock_sleep(ms)` suspends execution for specified milliseconds
  - Monotonic time: immune to NTP/DST changes (uses `time.Since(start) + epoch`)
  - Virtual time: deterministic mode with `AILANG_SEED` (starts at epoch 0)
  - stdlib wrapper: `std/clock` module with `now()` and `sleep()` functions
- **Net effect** (`internal/effects/net.go`, 355 LOC - Phase 2 PM FULL)
  - `_net_httpGet(url)` fetches content from HTTP/HTTPS URLs
  - `_net_httpPost(url, body)` sends POST requests with JSON body
  - **DNS rebinding prevention**: resolve ‚Üí validate IPs ‚Üí dial validated IP directly
  - **Protocol security**: https always allowed, http requires `--net-allow-http`, file:// blocked
  - **IP blocking**: localhost (127.x, ::1), private IPs (10.x, 192.168.x, 172.16-31.x), link-local
  - **Redirect validation**: max 5 redirects, re-validate IP at each hop
  - **Body size limits**: 5MB default via `io.LimitReader`, configurable via `NetContext.MaxBytes`
  - **Domain allowlist**: optional wildcard matching (*.example.com)
  - stdlib wrapper: `std/net` module with `httpGet()` and `httpPost()` functions
- **NetContext security configuration** (`internal/effects/context.go`, +130 LOC)
  - `Timeout` (30s default), `MaxBytes` (5MB), `MaxRedirects` (5)
  - `AllowHTTP` (false), `AllowLocalhost` (false)
  - `AllowedDomains` (wildcard support), `UserAgent` ("ailang/0.3.0")
- **IP validation helpers** (`internal/effects/net_security.go`, 91 LOC)
  - `validateIP()` checks IP against security policy
  - `resolveAndValidateIP()` prevents DNS rebinding attacks
  - `isAllowedDomain()` and `matchDomain()` for allowlist checking
- **Comprehensive test suites**:
  - Clock: 9 tests with flaky-guard (100 iterations for determinism)
  - Net: 6 test suites covering capabilities, protocols, IPs, domains, POST, body limits
  - All tests passing with both real network and mocked scenarios
- **2 new example files**:
  - `examples/micro_clock_measure.ail` - Clock effect demonstration
  - `examples/demo_ai_api.ail` - Real API calling with httpbin.org
- **Stdlib modules**:
  - `stdlib/std/clock.ail` - Clock effect wrappers
  - `stdlib/std/net.ail` - Net effect wrappers with security docs

### Security
- **M-R6 Net effect implements full Phase 2 PM hardening**
  - DNS rebinding prevention protects against SSRF attacks
  - IP blocking prevents access to localhost, private networks, link-local
  - Protocol validation blocks file://, ftp://, data://, gopher://
  - Redirect validation with IP re-check at each hop
  - Body size limits prevent memory exhaustion
  - Domain allowlist enables fine-grained access control
  - All security features tested with comprehensive test suite

### Fixed
- Added capability checks to `netHttpGet()` and `netHttpPost()` (requires `--caps Net`)
- Updated `resolveAndValidateIP()` to accept `*EffContext` for `AllowLocalhost` flag
- Fixed `validateIP()` to check `ctx.Net.AllowLocalhost` before blocking localhost IPs

## [v0.3.0-alpha3] - 2025-10-05

### Added - M-R5: Records & Row Polymorphism ‚úÖ COMPLETE
- **Record subsumption** for flexible field access
  - Functions accepting `{id: int}` now work with `{id: int, name: string, email: string}`
  - Field access uses open records: `{x: Œ± | œÅ}` unifies with larger closed records
  - Enables polymorphic functions over records with common fields
- **TRecord2 with row polymorphism** (opt-in via `AILANG_RECORDS_V2=1`)
  - Proper row types with tail variables: `{x: int, y: bool | œÅ}`
  - Row unification with occurs check prevents infinite types
  - Order-independent field matching: `{x:int,y:bool}` ~ `{y:bool,x:int}`
  - Nested record openness: `{u:{id:int | œÅ}}` ~ `{u:{id:int,email:string}}`
- **TRecordOpen compatibility shim** for Day 1 subsumption
  - Bridges old TRecord and new TRecord2 systems
  - Enables subsumption without breaking existing code
- **Enhanced error messages** (TC_REC_001 - TC_REC_004)
  - TC_REC_001: Missing field with available field suggestions
  - TC_REC_002: Duplicate field in literal with positions
  - TC_REC_003: Row occurs check with infinite type prevention
  - TC_REC_004: Field type mismatch with clear expected vs actual
- **New helper functions** in `internal/types/unification.go`:
  - `RecordHasField()` - Check field existence across record types
  - `RecordFieldType()` - Get field type safely
  - `IsOpenRecord()` - Detect open vs closed records
  - `TRecordToTRecord2()`, `TRecord2ToTRecord()` - Bidirectional conversion
- **Row unifier with occurs check**
  - `unifyRows()` handles field-by-field unification
  - Prevents `œÅ ~ {x: œÑ | œÅ}` infinite types
  - Proper tail unification with commutativity
- **2 new example files**:
  - `examples/micro_record_person.ail` - Simple field access and aliasing
  - `examples/test_record_subsumption.ail` - Demonstrates subsumption in action
- **16 new unit tests** covering:
  - TRecord2 ~ TRecord2 unification (4 cases)
  - TRecord ‚Üî TRecord2 conversion (3 cases)
  - Row occurs check (1 case)
  - Open-closed interactions (6 cases)
  - Order independence, nested openness, field mismatches

### Changed
- **Typechecker emits TRecord2** when `AILANG_RECORDS_V2=1` is set
  - `inferRecordLiteral()` creates TRecord2 for record literals
  - Default still uses TRecord for backwards compatibility
  - Plan: Enable by default in v0.3.1, remove TRecord in v0.4.0
- **Field access uses TRecordOpen** for subsumption
  - `inferRecordAccess()` emits open records instead of closed
  - Allows functions to work with record subsets

### Fixed
- **Record field access** now works with nested records
  - Before: `{ceo: {name: "Jane"}}.ceo.name` ‚Üí type error
  - After: Correctly types and evaluates to "Jane" ‚úÖ
- **Subsumption** enables polymorphic record functions
  - Before: Functions required exact field matches
  - After: Functions work with any record containing required fields ‚úÖ

### Impact
- **Lines of code**: ~670 total
  - Day 1: ~198 LOC (TRecordOpen, subsumption, helpers)
  - Day 2: ~280 LOC (TRecord2 unification, row unifier, conversion, occurs check, tests)
  - Day 3: ~192 LOC (flag support, error codes, examples, tests)
- **Examples**: 48/66 passing (72.7%, up from 40)
  - +9 fixed from subsumption (Day 1)
  - +2 new examples (Day 3)
- **Tests**: 16 new unit tests, all passing
- **Files modified**: 8 files
  - `internal/types/types.go` - TRecordOpen type
  - `internal/types/typechecker_core.go` - useRecordsV2 flag, inferRecordLiteral
  - `internal/types/unification.go` - Subsumption, TRecord2, unifyRows, helpers
  - `internal/types/errors.go` - TC_REC_001-004 error codes
  - `internal/types/record_unification_test.go` - 16 unit tests (NEW)
  - `examples/micro_record_person.ail` - (NEW)
  - `examples/test_record_subsumption.ail` - (NEW)
  - `examples/STATUS.md` - Updated counts

### Migration Guide
**Opt-in to TRecord2**:
```bash
export AILANG_RECORDS_V2=1
ailang run examples/micro_record_person.ail
```

**Using subsumption**:
```ailang
-- Define function with minimal fields
func printId(entity: {id: int}) -> () ! {IO} {
  println(show(entity.id))
}

-- Works with any record containing 'id'!
printId({id: 42})                           -- ‚úÖ
printId({id: 100, name: "Alice"})          -- ‚úÖ
printId({id: 200, name: "Bob", age: 30})   -- ‚úÖ
```

## [v0.3.0-alpha2] - 2025-10-05

### Added - M-R8: Block Expressions ‚úÖ COMPLETE
- **Block expression syntax** `{ e1; e2; e3 }` for sequencing multiple expressions
  - Last expression's value is the block's value
  - Non-last expressions evaluated for side effects
  - Desugars to let chains: `let _ = e1 in let _ = e2 in e3`
- **Bug fix** in `internal/elaborate/scc.go` (~10 LOC)
  - Added missing `*ast.Block` case to `findReferences()` function
  - Fixed recursion detection for functions using block syntax
  - Self-recursive and mutual recursion now work correctly with blocks
- **3 new example files**:
  - `examples/micro_block_seq.ail` - Basic block sequencing
  - `examples/micro_block_if.ail` - Blocks in if-then-else branches
  - `examples/block_recursion.ail` - Recursive functions with blocks
- **AI compatibility unlocked** ‚ú®
  - AI-generated code with blocks now works out of the box
  - No manual rewriting required
  - Compatible with Claude Sonnet 4.5, GPT-4, etc.

### Fixed
- **Recursion + Blocks Bug**: Functions with recursive calls inside blocks now correctly detected as recursive
  - Before: `func fact(n) { ... fact(n-1) }` ‚Üí "undefined variable: fact"
  - After: Correctly creates LetRec, recursion works ‚úÖ
- **SCC Detection**: `findReferences()` now traverses all expression types including blocks

### Impact
- Lines of code: 10 (5-line case statement)
- Examples: 3 new files
- Test status: All existing tests pass + new examples verified
- Developer experience: Major improvement for AI-assisted development

## [v0.3.0-alpha1] - 2025-10-05

### Added - M-R4: Recursion Support ‚úÖ COMPLETE
- **Full recursion support** via RefCell indirection (OCaml/Haskell-style semantics)
  - Self-referential closures with proper capture semantics
  - Mutually recursive functions (pre-bind all names before evaluation)
  - Function-first semantics: lambdas safe immediately, non-lambdas evaluated strictly
- **Stack overflow protection** with `--max-recursion-depth` CLI flag (default: 10,000)
  - Configurable depth limit for both module and non-module execution
  - Clear RT_REC_003 error messages with actionable guidance
- **Cycle detection** for recursive values (RT_REC_001 error)
  - Prevents infinite loops in non-function bindings
  - Example: `let rec x = x + 1 in x` properly detected and rejected
- **New runtime infrastructure** in `internal/eval/`
  - `RefCell` type for mutable indirection cells (value.go:166-197)
  - `IndirectValue` wrapper with Force() method for deferred resolution
  - 3-phase LetRec evaluation algorithm (eval_core.go:363-426)
  - Recursion depth tracking in CoreEvaluator (eval_core.go:17-25)
- **5 new example files** demonstrating recursion patterns
  - `examples/recursion_factorial.ail` - Simple & tail-recursive factorial
  - `examples/recursion_fibonacci.ail` - Tree recursion with 2 recursive calls
  - `examples/recursion_mutual.ail` - Mutually recursive isEven/isOdd
  - `examples/recursion_quicksort.ail` - Conceptual recursive structure
  - `examples/recursion_error.ail` - Documents RT_REC_001 error conditions
- **Comprehensive test suite** in `internal/eval/recursion_test.go`
  - 6 unit tests covering all recursion patterns
  - Tests for factorial, fibonacci, mutual recursion, stack overflow, deep recursion
  - All tests passing with experimental binop shim

### Changed
- **Example baseline improved**: 43 passing (up from 32), 14 failed, 4 skipped (Total: 61)
  - 11 additional examples now passing due to recursion infrastructure
- **CoreEvaluator** now tracks recursion depth for stack overflow detection
- **Module runtime** applies max recursion depth limit via `rt.GetEvaluator().SetMaxRecursionDepth()`

### Technical Details
- **Lines of code**: ~1,200 (core implementation) + ~380 (tests) + ~200 (examples)
- **Semantic model**: Proper Œª-calculus closure semantics matching textbook small-step operational semantics
- **Performance**: O(1) lookup via pointer indirection, negligible overhead
- **Error taxonomy**:
  - RT_REC_001: Recursive value used before initialization (non-function RHS)
  - RT_REC_002: Uninitialized recursive binding (internal ordering bug)
  - RT_REC_003: Stack overflow with depth limit exceeded

### Language Milestone
**AILANG is now Turing-complete** with deterministic semantics:
- ‚úÖ Œª-abstraction (first-class functions)
- ‚úÖ Application (function calls)
- ‚úÖ Conditionals (if-then-else)
- ‚úÖ Recursion (self & mutual)
- ‚úÖ Side-effects (IO/FS with capability security)

This milestone enables expressing every partial recursive function under deterministic semantics.

## [v0.2.1] - 2025-10-03

### Fixed
- **Windows Build Compatibility**: Fixed two Windows-specific test failures
  - Fixed `TestFSWriteFile_Success` using invalid `*` wildcard in filename (not allowed on Windows)
  - Fixed `TestNewModuleRuntime` path separator mismatch (Windows uses `\` vs Unix `/`)
  - All tests now pass on Windows, Linux, and macOS

### Changed
- Tests are now OS-agnostic, using `filepath.Clean()` for cross-platform compatibility
- Improved CI/CD reliability across all supported platforms

### üîÑ RECURSION & REAL-WORLD PROGRAMS (Target: 50+ examples)

**Status**: üöß IN PLANNING - See [design_docs/20251004/v0_3_0_implementation_plan.md](design_docs/20251004/v0_3_0_implementation_plan.md)

**Planned Features**:

#### M-R4: Recursion Support ‚úÖ COMPLETE (v0.3.0-alpha1)
- ‚úÖ **DONE**: LetRec support in runtime evaluator (RefCell indirection)
- ‚úÖ **DONE**: Self-referential closures (3-phase algorithm)
- ‚úÖ **DONE**: Recursive function examples (factorial, fibonacci, quicksort, mutual, error)
- ‚úÖ **DONE**: Stack overflow protection (--max-recursion-depth flag)
- **Impact**: AILANG now Turing-complete with deterministic semantics

#### M-R8: Block Expressions (HIGH PRIORITY, ~300 LOC) ‚Üê **NEW**
- ‚úÖ **TODO**: Block syntax `{ e1; e2; e3 }` as syntactic sugar
- ‚úÖ **TODO**: Desugar to let-sequencing: `let _ = e1 in let _ = e2 in e3`
- ‚úÖ **TODO**: Parser support (recognize `{ }` in expression position)
- ‚úÖ **TODO**: Empty block error with clear message
- ‚úÖ **TODO**: 3 integration examples (seq, if-then-else, recursion)
- **Impact**: **Critical for AI compatibility** - unblocks Claude Sonnet 4.5 generated code with blocks
- **Why**: AI models naturally generate blocks, currently fails to parse
- **Risk**: LOW (pure syntactic sugar, no type system or runtime changes)

#### M-R5: Records & Row Polymorphism (HIGH PRIORITY, ~500 LOC)
- ‚úÖ **TODO**: Complete TRecord unification
- ‚úÖ **TODO**: Row variables for polymorphic records
- ‚úÖ **TODO**: Field access type checking improvements
- **Impact**: Enables proper data modeling

#### M-R6: Extended Effects - Clock & Net (MEDIUM PRIORITY, ~700 LOC)
- ‚úÖ **TODO**: std/clock effect (now, sleep, timeout)
- ‚úÖ **TODO**: std/net effect (httpGet, httpPost)
- ‚úÖ **TODO**: Capability enforcement and security sandbox
- **Impact**: Real-world program connectivity

#### M-R7: Modulo Operator Fix (MEDIUM PRIORITY, ~200 LOC)
- ‚úÖ **TODO**: Integral type class (div, mod)
- ‚úÖ **TODO**: Fix % operator type inference
- **Impact**: Removes arithmetic operator blocker

#### M-UX2: User Experience (LOW PRIORITY, ~300 LOC)
- ‚úÖ **TODO**: Better recursion error messages
- ‚úÖ **TODO**: Audit script Clock/Net detection
- ‚úÖ **TODO**: 4-6 new micro examples

**Target Success Metrics**:
- **Passing Examples**: 42 ‚Üí 50+ (83%+)
- **Recursion**: Broken ‚Üí Working
- **Records**: Partial ‚Üí Working with row polymorphism
- **Effects**: IO/FS ‚Üí + Clock/Net (4 total)
- **Modulo (%)**: Broken ‚Üí Working via Integral

**Timeline**: October 17-21, 2025 (2 weeks)

---

## [v0.2.0] - 2025-10-03

### üéâ AUTO-ENTRY & EXAMPLE EXPLOSION: 42/53 Passing (79%) ‚úÖ

**Achieved Target**: Exceeded v0.2.0 goal of ‚â•35 passing examples, reaching **42/53 (79.2%)**

**Implementation**: ~200 LOC across 3 strategic improvements
1. **Auto-Entry Fallback** (`cmd/ailang/main.go`, ~50 LOC)
   - Intelligent entrypoint selection when `main` not found
   - Auto-selects single zero-arg function, or tries `test()`
   - Eliminated "entrypoint not found" errors for 10+ examples

2. **Audit Script Enhancement** (`tools/audit-examples.sh`, ~20 LOC)
   - Automatic capability detection (`! {IO}`, `! {FS}`)
   - Runs examples with appropriate `--caps` flags
   - Enabled testing of all IO/FS effect examples

3. **TRecord Unification Support** (`internal/types/unification.go`, ~40 LOC)
   - Added handler for legacy `*TRecord` type in unification
   - Fixed "unhandled type in unification" errors
   - Improved record type checking with field-by-field unification

4. **Micro Examples** (2 new passing examples)
   - `examples/micro_option_map.ail` - Pure ADT operations
   - `examples/micro_io_echo.ail` - IO effect demonstration

**Results**: +14 examples in single session
- Before: 28/51 passing (55%)
- After: 42/53 passing (79%)
- **Progress**: +50% more working examples

**Newly Passing Examples** (+14):
- `demos/hello_io.ail` - IO effect with println
- `effects_basic.ail` - Basic effect annotations
- `stdlib_demo.ail` - Standard library usage
- `stdlib_demo_simple.ail` - Simplified stdlib demo
- `test_effect_annotation.ail` - Effect syntax
- `test_effect_capability.ail` - Capability requirements
- `test_effect_fs.ail` - FS effect testing
- `test_effect_io.ail` - IO effect testing
- `test_invocation.ail` - Function invocation
- `test_io_builtins.ail` - IO builtin functions
- `test_module_minimal.ail` - Minimal module
- `test_no_import.ail` - No imports required
- `micro_io_echo.ail` - NEW micro example
- `micro_option_map.ail` - NEW micro example

**Key Insight**: Auto-entry was the MVP - single feature unlocked 10+ examples by making testing frictionless.

**Impact on v0.2.0 Goals**:
- ‚úÖ Target met: ‚â•35 examples (achieved 42)
- ‚úÖ Effect system validated: IO/FS working across examples
- ‚úÖ Module execution proven: Cross-module imports stable
- ‚úÖ User experience improved: Reduced friction for running examples

---

## [v0.2.0-rc1] - 2025-10-02

### üéØ M-EVAL: AI Evaluation Framework (~600 LOC) ‚úÖ

**AI Teachability Benchmarking System** - October 2, 2025

Added comprehensive framework for measuring AILANG's "AI teachability" - how easily AI models can learn to write correct AILANG code.

**Infrastructure**:
- `internal/eval_harness/` - Benchmark execution framework (~600 LOC)
  - `spec.go` - YAML benchmark loader with prompt file support
  - `runner.go` - Python & AILANG code execution with module path handling
  - `ai_agent.go` - LLM API wrapper with model resolution
  - `api_anthropic.go` - Claude API implementation (tested: 230 tokens)
  - `api_openai.go` - GPT API implementation (tested: 319 tokens)
  - `api_google.go` - Gemini/Vertex AI implementation (tested: 278 tokens)
  - `metrics.go` - JSON metrics logging with cost calculation
  - `models.go` - Centralized model configuration system

**Prompt System**:
- `prompts/v0.2.0.md` - Versioned AI teaching prompt for v0.2.0-rc1
- Documents working features: modules, effects, pattern matching, ADTs
- Includes common mistakes and correct patterns

**Benchmarks**:
- 5 benchmarks covering difficulty spectrum
- Supports prompt file loading via `prompt_file` YAML field
- Module path validation and stdlib resolution

**CLI**:
```bash
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5 --seed 42
./tools/run_benchmark_suite.sh  # Run all benchmarks with all 3 models
```

**Documentation**:
- `docs/guides/ai-prompt-guide.md` - AI teaching guide with v0.2.0 syntax
- `docs/guides/evaluation/` - Evaluation framework documentation
  - `baseline-tests.md` - Running first baseline tests
  - `model-configuration.md` - Model management
  - `README.md` - Framework overview

**Test Results**: All 3 models tested successfully
- ‚úÖ Claude Sonnet 4.5 (Anthropic): 230 tokens generated
- ‚úÖ GPT-5 (OpenAI): 319 tokens generated
- ‚úÖ Gemini 2.5 Pro (Vertex AI): 278 tokens generated

**KPI**: Establishes baseline for "AI teachability" metric (target: 80%+ success rate on simple benchmarks)

### üêõ Critical Fixes: Type Inference & Builtins (+22 LOC) ‚úÖ

**Fixed Arithmetic Operators** (`internal/runtime/builtins.go`, +13 LOC)
- Added `registerArithmeticBuiltins()` to register all arithmetic operators in module runtime
- Modulo operator `%` now works: `export func main() -> int { 5 % 3 }  -- Returns: 2`
- All arithmetic operators (`+`, `-`, `*`, `/`, `%`, `**`) available in module execution
- Delegates to existing `eval.Builtins` implementations via wrapper

**Fixed Comparison Operators** (`internal/types/typechecker_core.go`, +9 LOC)
- Modified `pickDefault()` to default `Ord`, `Eq`, `Show` constraints to `int`
- Comparison operators (`>`, `<`, `>=`, `<=`, `==`, `!=`) now work in modules
- No more "ambiguous type variable Œ± with classes [Ord]" errors
- Example: `export func compare(x: int, y: int) -> bool { x > y }  -- Works!`

**Impact**: AI-generated code now compiles correctly. Basic arithmetic and comparisons work as expected.

### ‚ö†Ô∏è Known Limitations (Discovered During M-EVAL Testing)

**Critical Issues Requiring v0.2.1 Patch**:

1. **Recursive Functions in Modules** - HIGH PRIORITY
   - Functions cannot call themselves: `factorial(n-1)` fails with "undefined variable"
   - Blocks common patterns (loops via recursion, FizzBuzz, tree traversal)
   - Root cause: Function bindings not in own scope during evaluation
   - Estimated fix: ~200-300 LOC, 2-3 days

2. **Capability Passing to Runtime** - CRITICAL
   - `--caps IO,FS` flag not propagating to effect context
   - All effect-based code fails even with capabilities granted
   - Blocks all IO/FS demos and examples
   - Estimated fix: ~100-200 LOC, 1-2 days

**See**: `design_docs/20251002/v0_2_0_implementation_plan.md` (Known Limitations section) for full details and next sprint recommendations.

---

## [Unreleased v0.2.0-rc1] - 2025-10-02 (Original Features)

### üöÄ Major Features: M-R1, M-R2, M-R3 ALL COMPLETE ‚úÖ

**Milestone Achievement**:
- Module execution runtime (M-R1, ~1,874 LOC) ‚úÖ
- Effect system runtime (M-R2, ~1,550 LOC) ‚úÖ
- Pattern matching polish (M-R3, ~700 LOC) ‚úÖ
  - Phase 1: Guards (~55 LOC)
  - Phase 2: Exhaustiveness checking (~255 LOC)
  - Phase 3: Decision trees (~390 LOC)
- Critical bug fixes

This release delivers core runtime milestones with working capability enforcement AND comprehensive pattern matching enhancements. AILANG now has:
- Fully executable module system with capability-based effect operations
- Pattern matching with conditional guards
- Exhaustiveness warnings for incomplete matches
- Decision tree optimization for pattern matching (available, disabled by default)
- Effects like IO and FS work with explicit permission grants via `--caps` flag

**üîß CRITICAL BUG FIXES (Oct 2)**: Removed legacy builtin path that bypassed effect system. Capability checking now works correctly. Fixed stdlib import resolution and integration test loader paths.

#### Added - M-R3 Phase 1: Guards (~55 LOC)

**Guard Support** (55 LOC)
- **Guard Elaboration** (`internal/elaborate/elaborate.go:1062-1069`)
  - Elaborates guard expressions during match compilation
  - Guards are normalized to Core ANF
  - Error handling for malformed guards
- **Guard Evaluation** (`internal/eval/eval_core.go:586-613`)
  - Evaluates guards with pattern bindings in scope
  - Enforces Bool type requirement for guards
  - False guards cause fallthrough to next arm
- **Tests**: 6 unit tests passing (`guards_simple_test.go`)
  - Basic true/false guards
  - Multiple sequential guards
  - Guard accessing pattern bindings
  - Non-Bool guard error handling
  - All guards failing ‚Üí non-exhaustive error
- **Examples**:
  - `test_guard_bool.ail` - Guard with true
  - `test_guard_false.ail` - Guard causing fallthrough

#### Added - M-R3 Phase 2: Exhaustiveness Checking (~255 LOC)

**Exhaustiveness Analysis** (255 LOC)
- **Pattern Universe Builder** (`internal/elaborate/exhaustiveness.go`)
  - Constructs complete pattern sets for types (Bool ‚Üí {true, false})
  - Pattern expansion and subtraction algorithms
  - Conservative handling of guards (don't count as coverage)
- **Integration** (`internal/elaborate/elaborate.go`, `internal/pipeline/pipeline.go`)
  - Exhaustiveness checker added to Elaborator
  - Warnings collected during elaboration
  - Result struct includes warnings array
- **CLI Display** (`cmd/ailang/main.go`)
  - Yellow-colored warnings displayed to stderr
  - Shows missing patterns for non-exhaustive matches
- **Tests**: 7 unit tests passing (`exhaustiveness_test.go`)
  - Complete Bool match (exhaustive)
  - Incomplete Bool match (non-exhaustive)
  - Wildcard coverage
  - Variable pattern coverage
  - Guard-aware checking
  - Infinite type handling (Int/Float/String)
- **Examples**:
  - `test_exhaustive_bool_complete.ail` - No warning
  - `test_exhaustive_bool_incomplete.ail` - Warning: missing false
  - `test_exhaustive_wildcard.ail` - Wildcard makes exhaustive

**Limitations**:
- Only Bool type fully supported (finite pattern universe)
- Int/Float/String require wildcard (infinite types)
- No ADT support yet (requires type environment integration)
- Guards conservatively treated as non-covering

#### Added - M-R3 Phase 3: Decision Trees (~390 LOC)

**Decision Tree Compilation** (390 LOC)
- **Tree Structure** (`internal/dtree/decision_tree.go`)
  - LeafNode, FailNode, SwitchNode representations
  - Pattern matrix compilation algorithm
  - Pattern specialization and row reduction
  - Heuristic for when to use decision trees (2+ literal/constructor patterns)
- **Tree Evaluation** (`internal/eval/decision_tree.go`)
  - Tree walking with scrutinee dispatch
  - Path-based value extraction for nested patterns
  - Guard checking in leaf nodes
  - Fallback to linear evaluation if tree compilation not beneficial
- **Integration** (`internal/eval/eval_core.go`)
  - Optional decision tree compilation (disabled by default)
  - Seamless fallback to linear pattern matching
  - Future: can be enabled via flag or heuristic
- **Tests**: 4 unit tests passing (`decision_tree_test.go`)
  - Simple Bool match compilation
  - Wildcard default handling
  - All-wildcards optimization
  - Heuristic validation

**Implementation Notes**:
- Decision trees available but disabled by default (runtime optimization)
- Reduces redundant pattern tests via switch-based dispatch
- Preserves exact semantics of linear pattern matching
- Can be enabled in future with flag/heuristic

#### Added - Phase 5: Function Invocation & Builtins (~280 LOC)

**Function Invocation** (60 LOC)
- **CallEntrypoint()** (`internal/runtime/entrypoint.go`)
  - Calls exported entrypoint functions from modules
  - Validates arity and function type
  - Sets up cross-module resolver
- **CallFunction()** (`internal/eval/eval_core.go`)
  - Public method to invoke FunctionValues
  - Manages environment binding and restoration
  - Supports 0-arg and multi-arg functions
- **CLI Integration** (`cmd/ailang/main.go`)
  - Argument decoding from `--args-json`
  - Result printing (silent for Unit types)
  - Helpful error messages for multi-arg functions

**Builtin Registry** (120 LOC)
- **BuiltinRegistry** (`internal/runtime/builtins.go`)
  - Native Go implementations of stdlib functions
  - IO builtins: `_io_print`, `_io_println`, `_io_readLine`
  - Integrated into ModuleRuntime initialization
- **Resolver Integration** (`internal/runtime/resolver.go`)
  - Checks builtins before local/import lookup
  - Supports `$builtin` module and `_` prefix names
- **Lit Expression Handling** (`internal/runtime/runtime.go`)
  - `extractBindings()` now handles Lit expressions at module level
  - Enables stdlib modules to load correctly

**Examples**
- `examples/test_invocation.ail` - 0-arg and 1-arg function examples
- `examples/test_io_builtins.ail` - Builtin IO function demonstration

#### Test Results - Phase 5

- **Unit Tests**: ‚úÖ 16/16 passing (all runtime non-integration tests)
- **Integration Tests**: ‚ö†Ô∏è 2/7 passing (5 fail due to known loader path issues)
- **End-to-End Examples**: ‚úÖ 2/2 new examples working
- **Total**: ~280 LOC added

---

#### üîß Fixed - Critical Bug Fixes (Oct 2, ~50 LOC changes)

**Bug #1: Legacy Builtin Path Bypassed Effect System** üö®
- **Issue**: Special case in `evalCoreApp()` called `CallBuiltin()` directly, bypassing capability checking
- **Location**: `internal/eval/eval_core.go:404-416` (deleted)
- **Fix**: Removed 13 LOC special case; all builtins now route through resolver
- **Impact**: Capability checking NOW WORKS correctly
- **Test**: `ailang run effects_basic.ail` ‚Üí denies without `--caps IO`, allows with it
- **Added**: Deprecation comment on old `CallBuiltin()` function

**Bug #2: Stdlib Imports Not Found** üîß
- **Issue**: `import std/io` failed with "module not found"
- **Location**: `internal/loader/loader.go:80-88, 154-164`
- **Fix**: Resolve `std/` prefix from `stdlib/` directory (or `$AILANG_STDLIB_PATH`)
- **Impact**: Stdlib imports work: `import std/io (println)`
- **Test**: `examples/effects_basic.ail` now loads and runs

**Bug #3: Integration Tests Failed on Module Loading** ‚ö†Ô∏è
- **Issue**: Loader used relative paths, tests couldn't find modules
- **Location**: `internal/loader/loader.go:94-97, 167-169`
- **Fix**: Join project-relative paths with `basePath` for absolute resolution
- **Additional**: Added Core elaboration in runtime (avoid import cycle)
- **Additional**: Added minimal interface builder for modules loaded without pipeline
- **Impact**: 5/7 integration tests now passing (2 fail on cross-module elaboration)
- **Test**: `TestIntegration_SimpleModule` and 4 others pass

**Test Coverage After Fixes**:
- ‚úÖ All eval tests passing (no regressions)
- ‚úÖ 39/39 effect tests passing
- ‚úÖ 5/7 integration tests passing
- ‚úÖ End-to-end capability enforcement verified

---

### ‚ö° Major Feature: Effect System Runtime (M-R2 COMPLETE ‚úÖ)

**Milestone Achievement**: Capability-based effect system (~1,550 LOC total).

This implements the effect runtime that brings type-level effects into execution. Effects require explicit capability grants via `--caps` flag. Includes IO and FS operations with sandbox support.

**Status**: COMPLETE - Capability checking working, all acceptance criteria met.

#### Added - Effect System Infrastructure (~1,550 LOC)

**Core Effect System** (650 LOC)
- **Capability** (`internal/effects/capability.go`, 50 LOC)
  - Grant tokens for effect permissions (e.g., IO, FS, Net)
  - Metadata support for future budgets/quotas
  - `NewCapability(name)` constructor

- **EffContext** (`internal/effects/context.go`, 100 LOC)
  - Runtime context holding capability grants
  - Environment configuration (AILANG_SEED, TZ, LANG, sandbox)
  - Methods: `Grant()`, `HasCap()`, `RequireCap()`
  - `loadEffEnv()` loads from OS environment

- **Effect Operations Registry** (`internal/effects/ops.go`, 100 LOC)
  - `EffOp` type: `func(ctx, args) (Value, error)`
  - Registry: effect name ‚Üí operation name ‚Üí EffOp
  - `Call()` performs capability check + execution
  - `RegisterOp()` for operation registration

**IO Effect** (150 LOC)
- **IO Operations** (`internal/effects/io.go`)
  - `ioPrint(s)` - Print without newline
  - `ioPrintln(s)` - Print with newline
  - `ioReadLine()` - Read from stdin
  - All require IO capability grant

**FS Effect** (200 LOC)
- **FS Operations** (`internal/effects/fs.go`)
  - `fsReadFile(path)` - Read file to string
  - `fsWriteFile(path, content)` - Write string to file
  - `fsExists(path)` - Check file/directory existence
  - Sandbox support via `AILANG_FS_SANDBOX` env var
  - All require FS capability grant

**Error Handling** (50 LOC)
- **CapabilityError** (`internal/effects/errors.go`)
  - Clear error messages for missing capabilities
  - Helpful hints: "Run with --caps IO"

**Integration** (150 LOC)
- **CLI Flag** (`cmd/ailang/main.go`)
  - `--caps IO,FS,Net` flag for granting capabilities
  - Comma-separated capability list
  - Creates EffContext with grants before execution

- **Evaluator Support** (`internal/eval/eval_core.go`)
  - `SetEffContext(ctx)` / `GetEffContext()` methods
  - EffContext field added to CoreEvaluator

- **Runtime Integration** (`internal/runtime/`)
  - Builtins route to effect system via `effects.Call()`
  - `GetEvaluator()` method for EffContext access

**Stdlib** (20 LOC)
- **stdlib/std/fs.ail** - FS module with readFile, writeFile, exists

#### Testing - Effect System (750 LOC)

**Unit Tests** (550 LOC):
- `internal/effects/context_test.go` (150 LOC) - 12 tests for capabilities
- `internal/effects/io_test.go` (250 LOC) - 15 tests for IO operations
- `internal/effects/fs_test.go` (250 LOC) - 12 tests for FS operations
- ‚úÖ **39/39 tests passing**
- ‚úÖ **100% coverage** for new packages

**Integration Tests** (200 LOC):
- `internal/effects/integration_cli_test.go` - Full flow testing
- Capability grant/denial scenarios
- Sandbox enforcement verification

**Examples**:
- `examples/test_effect_io.ail` - IO operations demo
- `examples/test_effect_fs.ail` - FS operations placeholder

#### Usage Examples

**IO with capability grant**:
```bash
ailang run app.ail --caps IO
```

**FS with sandbox**:
```bash
AILANG_FS_SANDBOX=/tmp ailang run app.ail --caps FS
```

**Multiple capabilities**:
```bash
ailang run app.ail --caps IO,FS,Net
```

#### Known Limitations - Effect System

‚ö†Ô∏è **Legacy Builtin Path**: The old `CallBuiltin()` in `internal/eval/builtins.go:410` bypasses capability checks. Effect operations work but enforcement is incomplete.

**Impact**: Architecture complete, runtime checks bypassed by legacy code
**Fix Planned**: v0.2.1 - Remove legacy builtin special case

#### Metrics - M-R2

| Metric | Value |
|--------|-------|
| Total LOC | 1,550 |
| Core Code | 650 |
| Tests | 750 |
| Integration | 150 |
| Test Coverage | 100% (new packages) |
| Unit Tests | 39 passing |

---

## [v0.1.1] - 2025-10-02

### üöÄ Major Feature: Module Execution Runtime (M-R1 Phases 1-4)

**Milestone Achievement**: Core infrastructure for module execution complete (~1,594 LOC).

This release delivers the foundation for executable modules. Function invocation was completed in v0.2.0-rc1.

#### Added - Module Runtime Infrastructure (~1,594 LOC)

**Phase 1: Scaffolding** (692 LOC)
- **ModuleInstance** (`internal/runtime/module.go`, 164 LOC)
  - Runtime representation of modules with evaluated bindings
  - Thread-safe initialization using `sync.Once`
  - Export filtering and access control
  - Methods: `GetExport()`, `HasExport()`, `GetBinding()`, `ListExports()`, `IsEvaluated()`

- **ModuleRuntime** (`internal/runtime/runtime.go`, 149 LOC)
  - Orchestrates module loading, caching, and evaluation
  - Circular import detection with clear error messages ("A ‚Üí B ‚Üí C ‚Üí A")
  - Topological dependency evaluation
  - Methods: `LoadAndEvaluate()`, `GetInstance()`, `PreloadModule()`

- **Unit Tests** (379 LOC)
  - `internal/runtime/module_test.go` - 7 tests for ModuleInstance
  - `internal/runtime/runtime_test.go` - 5 tests for ModuleRuntime
  - 12/12 tests passing ‚úÖ

**Phase 2: Evaluation + Resolver** (402 LOC)
- **Global Resolver** (`internal/runtime/resolver.go`, 120 LOC)
  - Cross-module reference resolution with encapsulation enforcement
  - Routes imported references through exports only (never private bindings)
  - Error handling with module availability checks

- **Module Evaluation** (~70 LOC in `runtime.go`)
  - `evaluateModule()` method for top-level binding extraction
  - Integration with existing Core evaluator
  - Export filtering based on module interface

- **Resolver Tests** (`internal/runtime/resolver_test.go`, 212 LOC)
  - 6 tests for local/import resolution, encapsulation, error cases
  - 18/18 total tests passing ‚úÖ

**Phase 3: Linking & Topological Sort** (~300 LOC)
- **Cycle Detection** (~50 LOC in `runtime.go`)
  - DFS-based circular import detection
  - Clear error messages with import path: "circular import detected: A ‚Üí B ‚Üí C ‚Üí A"
  - State tracking with `visiting` map and `pathStack`

- **Integration Tests** (`internal/runtime/integration_test.go`, 249 LOC)
  - 7 integration tests covering module execution flows
  - Test modules in `tests/runtime_integration/` (simple.ail, dep.ail, with_import.ail)
  - 2/7 passing (5 have known loader path issues, non-blocking)

**Phase 4: CLI Integration** (~200 LOC)
- **Pipeline Extension** (`internal/pipeline/pipeline.go`, ~60 LOC)
  - Added `Modules map[string]*loader.LoadedModule` to Result struct
  - Converts CompileUnits to LoadedModules after elaboration
  - Preserves Core AST, Iface, and imports for runtime use

- **Loader Preloading** (`internal/loader/loader.go`, ~15 LOC)
  - Added `Preload(path, loaded)` method to inject elaborated modules
  - Avoids redundant loading and elaboration

- **Recursive Binding Extraction** (`internal/runtime/runtime.go`, ~55 LOC)
  - `extractBindings()` helper for nested Let/LetRec declarations
  - Handles module elaboration structure: `let f1 = ... in (let f2 = ... in Var(...))`
  - Properly terminates at Var expressions

- **CLI Integration** (`cmd/ailang/main.go`, ~30 LOC)
  - Module runtime replaces "not yet supported" error
  - Pre-loads modules from pipeline result
  - Entrypoint validation with arity checking
  - Error messages show available exports

- **Entrypoint Helpers** (`internal/runtime/entrypoint.go`, 37 LOC)
  - `GetArity(val)` - Returns function parameter count
  - `GetExportNames(inst)` - Lists module exports for error messages

#### Architecture Highlights

**Key Design Decisions**:
1. **Pipeline Integration**: Runtime receives pre-elaborated modules from pipeline (no duplicate work)
2. **Recursive Extraction**: `extractBindings()` traverses nested Let structures from elaboration
3. **Preloading Pattern**: Modules injected into loader cache via `PreloadModule()`
4. **Thread-Safe Init**: `sync.Once` ensures each module evaluates exactly once
5. **Encapsulation**: Only exported bindings accessible across modules

**Data Flow**:
```
Parse ‚Üí Type-check ‚Üí Elaborate ‚Üí Pipeline
                                    ‚Üì
                              Convert to LoadedModules
                                    ‚Üì
                              Runtime.PreloadModule()
                                    ‚Üì
                              Runtime.LoadAndEvaluate()
                                    ‚Üì
                              Extract bindings recursively
                                    ‚Üì
                              Filter exports
                                    ‚Üì
                              Validate entrypoint ‚úÖ
```

#### Test Results

**Unit Tests**: ‚úÖ 18/18 passing
- Module instance creation and export access (7 tests)
- Runtime caching and management (5 tests)
- Global resolver with encapsulation (6 tests)

**Integration Tests**: ‚ö†Ô∏è 2/7 passing
- CircularImport detection ‚úÖ
- NonExistentModule error ‚úÖ
- SimpleModule, ModuleWithImport, etc. ‚ö†Ô∏è (loader path resolution issues, non-blocking)

**End-to-End Validation**: ‚úÖ Working
```bash
$ ailang --entry main run examples/test_runtime_simple.ail
‚úì: Module execution ready
  Entrypoint:  main
  Arity:       0
  Module:      examples/test_runtime_simple

Note: Function invocation coming soon (Phase 5 completion)
```

#### Known Limitations

1. **Function Invocation Not Implemented**
   - Entrypoints validated but not yet executed
   - Arity checking works ‚úÖ
   - Export resolution works ‚úÖ
   - Actual function calling deferred to Phase 5

2. **stdlib Modules Fail**
   - stdlib uses builtin stubs (`_io_print`, etc.)
   - Requires special handling for Lit expressions
   - Planned for Phase 5

3. **CLI Flag Order**
   - `--entry` must come before `run` command
   - Use: `ailang --entry <name> run <file>`
   - Known CLI parsing quirk, low priority fix

#### Files Changed

**New Files**:
- `internal/runtime/module.go` (164 LOC) - ModuleInstance
- `internal/runtime/runtime.go` (210 LOC) - ModuleRuntime with cycle detection
- `internal/runtime/resolver.go` (120 LOC) - Global resolver
- `internal/runtime/entrypoint.go` (37 LOC) - Helper functions
- `internal/runtime/module_test.go` (239 LOC) - Module tests
- `internal/runtime/runtime_test.go` (140 LOC) - Runtime tests
- `internal/runtime/resolver_test.go` (212 LOC) - Resolver tests
- `internal/runtime/integration_test.go` (249 LOC) - Integration tests
- `tests/runtime_integration/*.ail` (3 test modules)

**Modified Files**:
- `internal/pipeline/pipeline.go` (+60 LOC) - Added Modules map to Result
- `internal/loader/loader.go` (+15 LOC) - Added Preload() method
- `cmd/ailang/main.go` (+30 LOC) - CLI integration

#### Technical Metrics

- **Total LOC**: ~1,594 (implementation + tests)
- **Test Coverage**: 18/18 unit tests passing
- **Integration Tests**: 2/7 passing (loader issues non-blocking)
- **Timeline**: On schedule (Phases 1-4 complete)

#### Next Steps (Phase 5 - Pending)

1. **Function Invocation** - Connect to evaluator API, call entrypoints, print results
2. **stdlib Support** - Handle builtin functions and Lit expressions
3. **Example Verification** - Test all examples, update README
4. **Documentation** - Update CLAUDE.md, create execution guide

---

## [v0.1.0] - 2025-10-02

### üéØ MVP Release: Type System Complete

**Major Achievement**: First complete type system MVP with 27,610 LOC of Go implementation.

#### Added - Documentation & Polish (~2,500 lines)

**Documentation Suite**:
- **README.md**: Complete restructure for v0.1.0 with honest status, "What Works" section, FAQ
- **docs/LIMITATIONS.md**: NEW - 400+ lines comprehensive limitations guide
- **docs/METRICS.md**: NEW - 300+ lines project statistics and metrics
- **RELEASE_NOTES_v0.1.0.md**: NEW - 500+ lines comprehensive release notes
- **docs/SHOWCASE_ISSUES.md**: NEW - 350+ lines parser/execution limitations
- **examples/STATUS.md**: NEW - Complete inventory of 42 example files
- **examples/README.md**: NEW - User guide for examples
- **CLAUDE.md**: UPDATED - Current v0.1.0 status, accurate component breakdown

**Showcase Examples** (4 new files):
- `examples/showcase/01_type_inference.ail` - Type inference demonstration
- `examples/showcase/02_lambdas.ail` - Lambda composition
- `examples/showcase/03_type_classes.ail` - Type class polymorphism
- `examples/showcase/04_closures.ail` - Closures and captured environments

**Development Tools**:
- `tools/audit-examples.sh`: Automated example testing and categorization

**Warning Headers**: Added to 3 module examples that type-check but can't execute

#### Status Summary

**‚úÖ Complete (27,610 LOC)**:
- Hindley-Milner type inference (7,291 LOC)
- Type classes with dictionary-passing (linked system, ~3,000 LOC)
- Lambda calculus & closures (3,712 LOC)
- Professional REPL with debugging (1,351 LOC)
- Module type-checking (1,030 LOC module + 503 LOC loader)
- Parser with operator precedence (2,656 LOC)
- Structured error reporting with JSON schemas (657 LOC)

**‚ö†Ô∏è Known Limitation**:
- Module files type-check ‚úÖ but cannot execute ‚ùå (runtime in v0.2.0)
- Non-module `.ail` files execute successfully ‚úÖ
- REPL fully functional ‚úÖ

**Examples**:
- 12 working (25.5%)
- 3 type-check only (6.4%)
- 27 broken (57.4%)
- 6 skipped (test/demo files)

**Test Coverage**: 24.8% (10,559 LOC of tests)

#### Changed

- README.md version badge: v0.0.12 ‚Üí v0.1.0
- Implementation status: Updated to "Type System Complete"
- Test coverage badge: 31.3% ‚Üí 24.8% (accurate count)

#### Fixed

- Documentation now accurately reflects v0.1.0 capabilities
- Example status now honestly documented
- Module execution limitation clearly communicated

### v0.2.0 Roadmap (3.5-4.5 weeks)

**M-R1**: Module Execution Runtime (~1,200 LOC, 1.5-2 weeks)
**M-R2**: Algebraic Effects Foundation (~800 LOC, 1-1.5 weeks)
**M-R3**: Pattern Matching (~600 LOC, 1 week)

---

## [v0.0.12] - 2025-10-02

### Added - M-S1 Complete: Stdlib Foundation (~200 LOC)

**‚úÖ M-S1 MILESTONE ACHIEVED: All 5 stdlib modules type-check successfully**

#### Equation-Form Export Syntax (~30 LOC)
**Parser enhancement for thin wrapper functions:**

**New Syntax** (`internal/parser/parser.go`, lines 655-683):
- Added equation-form function syntax: `export func f(x: T) -> R = expr`
- Alternative to block-form: `export func f(x: T) -> R { expr }`
- Wraps expression in Block for uniform AST handling

**Implementation**:
```go
if p.peekTokenIs(lexer.ASSIGN) {
    p.nextToken() // move to ASSIGN
    p.nextToken() // move past ASSIGN
    body := p.parseExpression(LOWEST)
    fn.Body = &ast.Block{Exprs: []ast.Expr{body}, Pos: body.Position()}
}
```

**Use Case**: Thin wrappers around builtins (std/io module)
```ailang
export func println(s: string) -> () ! {IO} = _io_println(s)
export func print(s: string) -> () ! {IO} = _io_print(s)
export func readLine() -> string ! {IO} = _io_readLine()
```

---

#### Polymorphic ++ Operator (~170 LOC)
**Type checker enhancement for list and string concatenation:**

**Typing Rule**: `xs:[Œ±] ‚àß ys:[Œ±] ‚áí xs++ys:[Œ±]`

**Implementation** (`internal/types/typechecker_core.go`, lines 1155-1250):
- Decision tree for polymorphic concatenation:
  1. If at least one operand is a concrete list ‚Üí list concat
  2. If at least one operand is a concrete string ‚Üí string concat
  3. If both are type variables ‚Üí default to list concat (more polymorphic)
  4. Otherwise ‚Üí fallback to string concat

**Type Unification** (`internal/types/unification.go`, lines 125-143):
- Added TCon compatibility for both `TCon("String")` and `TCon("string")` (case variations)
- Proper unification when one operand is concrete type, other is type variable

**Examples Working**:
```ailang
"hello" ++ " world"        -- String concat
[1, 2] ++ [3, 4]           -- List concat: [Int]
[] ++ []                   -- Polymorphic: [Œ±]
concat xs ys = xs ++ ys    -- Infers: [Œ±] -> [Œ±] -> [Œ±]
```

---

#### Stdlib Modules Complete (All 5 type-check)

**stdlib/std/io.ail** (3 exports):
- `print(s: string) -> () ! {IO}` - Print without newline
- `println(s: string) -> () ! {IO}` - Print with newline
- `readLine() -> string ! {IO}` - Read from stdin
- Uses equation-form syntax for thin wrappers

**stdlib/std/list.ail** (10 exports):
- `map, filter, foldl, foldr, length, head, tail, reverse, concat, zip`
- ++ operator now works correctly for list concatenation

**stdlib/std/option.ail** (6 exports):
- `map, flatMap, getOrElse, isSome, isNone, filter`

**stdlib/std/result.ail** (6 exports):
- `map, mapErr, flatMap, isOk, isErr, unwrap`

**stdlib/std/string.ail** (7 exports):
- `length, substring, toUpper, toLower, trim, compare, find`

---

### Changed

**Parser Function Declaration**:
- Extended to support both block-form and equation-form syntax
- Equation-form used for simple wrapper functions
- Block-form used for multi-statement functions

**Type Checker**:
- Enhanced ++ operator to work polymorphically for both lists and strings
- Improved type variable unification for binary operators

---

### Fixed

**List Concatenation**: ++ operator now properly type-checks with polymorphic element types
**String Concatenation**: Works when one operand is a type variable
**Type Unification**: TCon case variations ("String" vs "string") now handled correctly

---

### Technical Details

**Files Modified**:
- `internal/parser/parser.go` (+30 LOC): Equation-form export syntax
- `internal/types/typechecker_core.go` (+95 LOC): Polymorphic ++ operator
- `internal/types/unification.go` (+18 LOC): TCon compatibility
- `stdlib/std/io.ail` (rewritten): 3 equation-form exports

**Test Results**:
- ‚úÖ All 5 stdlib modules type-check without errors
- ‚úÖ All existing tests pass (no regressions)
- ‚úÖ Examples type-check successfully (option_demo, block_demo, stdlib_demo)

**Known Limitations**:
- ‚ö†Ô∏è Example execution: Runner doesn't call `main()` in module files (type-checking works)
- ‚ö†Ô∏è No `_io_debug` builtin yet (deferred)

**Metrics**:
- Total new code: ~200 LOC (130 implementation + 70 stdlib)
- Stdlib modules: 5/5 complete (100%)
- M-S1 Status: ‚úÖ **COMPLETE**

---

#### Minimal Viable Runner (MVF) - Partial Implementation (~250 LOC)
**Entrypoint resolution and argument decoding foundation for v0.2.0:**

**‚úÖ What Works**:
1. **Argument Decoder Package** (`internal/runtime/argdecode/argdecode.go`, ~200 LOC)
   - Type-directed JSON‚ÜíValue conversion
   - Supports: null‚Üí(), number‚Üíint/float, string, bool, array‚Üílist, object‚Üírecord
   - Handles type variables with simple inference
   - Structured errors: `DecodeError` with Expected/Got/Reason

2. **CLI Flags** (3 new flags in `cmd/ailang/main.go`):
   - `--entry <name>` - Entrypoint function name (default: "main")
   - `--args-json '<json>'` - JSON arguments to pass (default: "null")
   - `--print` - Print return value even for unit (default: true)

3. **Entrypoint Resolution Logic**:
   - Looks up function in `result.Interface.Exports`
   - Validates it's a function type (`TFunc2`)
   - Supports 0 or 1 parameters (v0.1.0 constraint)
   - Rejects multi-arg functions with clear error
   - Lists available exports if entrypoint not found

4. **Demo Files** (3 examples in `examples/demos/`):
   - `hello_io.ail` - IO effects demo
   - `adt_pipeline.ail` - ADT/Option usage
   - `effects_pure.ail` - Pure list operations

**‚ùå What's NOT Implemented**:
- Module-level evaluation (no function values extracted)
- Actual entrypoint execution (blocked on module evaluation)
- Effect handlers (IO, etc.)
- Demo output and golden files (blocked on execution)

**Reason**: Module execution requires evaluating all bindings in dependency order, building runtime environments with closures, and handling effects. This is a significant feature planned for v0.2.0.

**Current Behavior**:
```bash
$ ailang run examples/demos/hello_io.ail

Note: Module evaluation not yet supported
  Entrypoint:  main
  Type:        () -> Œ±3 ! {...Œµ4}
  Parameters:  0
  Decoded arg: ()

What IS working:
  ‚úì Interface extraction and freezing
  ‚úì Entrypoint resolution
  ‚úì Argument type checking and JSON decoding
```

**Usage Examples**:
```bash
ailang run file.ail                                    # Zero-arg main()
ailang --entry=demo run file.ail                       # Zero-arg demo()
ailang --entry=process --args-json='42' run file.ail   # Single-arg
```

**Files Modified**:
- `internal/runtime/argdecode/argdecode.go` (+200 LOC): New package
- `cmd/ailang/main.go` (+60 LOC): CLI flags + entrypoint resolution
- `examples/demos/*.ail` (+3 files): Demo examples

**Value Delivered**:
- Foundation for v0.2.0 module execution
- Type-safe argument handling ready
- Clear UX messaging about what's working vs. coming
- Demo files ready for when evaluation lands

---

## [v0.0.11] - 2025-10-02

### Fixed - M-S1 Blockers: Cross-Module Constructors & Multi-Statement Functions (~224 LOC)

**CRITICAL FIXES unblocking realistic stdlib examples:**

#### Blocker 1: Cross-Module Constructor Resolution (~74 LOC)
**Problem**: Imported constructors like `Some` from `std/option` couldn't be used because the type checker didn't know their signatures.

**Root Cause**: Constructor factory functions were added to `globalRefs` for elaboration but NOT to `externalTypes` for type checking.

**Solution** (`internal/pipeline/pipeline.go`):
- Lines 452-497: When importing constructors, build factory function type and add to `externalTypes`
- Factory type: `TFunc2{Params: FieldTypes, Return: ResultType}` with `EffectRow: nil` (pure)
- Lines 700-739: Added `extractTypeVarsFromType()` helper to extract type variables for polymorphism
- Example: `Some: a -> Option[a]`, `None: Option[a]`

**Test Results**:
- ‚úÖ `examples/option_demo.ail` now type-checks (was: undefined make_Option_Some)
- ‚úÖ `stdlib/std/list.ail` constructor imports work
- ‚úÖ All existing tests pass

**Note**: `extractTypeVarsFromType()` handles both old (TApp/TVar) and new (TFunc2/TVar2) types for defensive compatibility. Should be cleaned up to use only TVar2 consistently.

---

#### Blocker 2: Multi-Statement Function Bodies (~150 LOC)
**Problem**: Parser only supported single-expression function bodies. Couldn't write realistic functions with multiple statements:
```ailang
func main() {
  let x = 1;      -- ‚ùå Parse error: unexpected ;
  let y = 2;
  x + y
}
```

**Root Cause**: Function bodies parsed as single expression via `parseExpression(LOWEST)`. No support for semicolon-separated statements.

**Solution**:
1. **AST** (`internal/ast/ast.go`, lines 228-243): Added `Block` node for sequential expressions
2. **Parser** (`internal/parser/parser.go`):
   - Line 663: Changed to call `parseFunctionBody()` instead of `parseExpression()`
   - Lines 673-721: New `parseFunctionBody()` parses semicolon-separated expressions
   - Lines 856-956: Modified `parseRecordLiteral()` to distinguish blocks from record literals
3. **Elaboration** (`internal/elaborate/elaborate.go`):
   - Lines 524-525: Added `Block` case to `normalize()`
   - Lines 786-831: New `normalizeBlock()` converts blocks to nested `Let` expressions
   - Transformation: `{ e1; e2; e3 }` ‚Üí `let _block_0 = e1 in let _block_1 = e2 in e3`

**Test Results**:
- ‚úÖ Single expression bodies still work
- ‚úÖ Multi-statement blocks with semicolons work
- ‚úÖ Blocks without trailing semicolon work
- ‚úÖ Empty blocks work: `{}`
- ‚úÖ Mixed let statements and expressions work
- ‚ö†Ô∏è Module files with blocks have elaboration issue (separate bug, non-blocking)

**Examples**:
- `examples/block_demo.ail` demonstrates multi-statement functions

**Known Issue**: Files with `module` declarations + blocks fail with "normalization received nil expression". Works fine without module declaration. Needs investigation but doesn't block core functionality.

---

**Combined Impact**: Both blockers resolved! Stdlib modules can now:
- Import and use constructors from other modules
- Write realistic functions with multiple statements and side effects
- Use pattern matching with imported types

**Files Changed**:
- `internal/pipeline/pipeline.go` (+74 LOC): Constructor type resolution
- `internal/ast/ast.go` (+16 LOC): Block AST node
- `internal/parser/parser.go` (+130 LOC): Block parsing
- `internal/elaborate/elaborate.go` (+48 LOC): Block elaboration
- `examples/block_demo.ail` (+17 LOC): Multi-statement example

**Total**: ~224 new LOC, ~5 hours work (Blocker 1: 2 hours, Blocker 2: 3 hours)

---

### Added - M-S1 Parts A & B: Import System & Builtin Visibility (~700 LOC)

#### Part A: Export System for Types and Constructors (~400 LOC)
**Complete end-to-end import resolution for types, constructors, and functions:**

**Loader Enhancement** (`internal/loader/loader.go`)
- Added `Types map[string]*ast.TypeDecl` to `LoadedModule` for exported type declarations
- Added `Constructors map[string]string` for constructor name ‚Üí type name mapping
- Created `buildTypes()` function to extract type declarations from AST (checks both `Decls` and `Statements`)
- Updated `GetExport()` to return `(nil, nil)` for types and constructors (not errors, just non-functions)
- Enhanced error reporting to list available types and constructors with labels

**Elaborator Updates** (`internal/elaborate/elaborate.go`)
- Added `AddBuiltinsToGlobalEnv()` method to inject all builtin functions into elaborator's global scope
- Modified import resolution in `ElaborateFile()` to skip types/constructors (handled later in pipeline)
- Builtins now available during elaboration, not just linking

**Interface Builder** (`internal/iface/iface.go`, `internal/iface/builder.go`)
- Added `Types map[string]*TypeExport` to `Iface` struct
- Created `TypeExport` struct with `Name` and `Arity` fields
- Enhanced `BuildInterfaceWithTypesAndConstructors()` to extract types from AST file
- Constructors extracted from `AlgebraicType.Constructors` (not `Variants`)
- Helper methods: `AddType()`, `GetType()`

**Pipeline Integration** (`internal/pipeline/pipeline.go`)
- Updated import resolution to check `GetType()` and `GetConstructor()` in addition to `GetExport()`
- Constructors map to `$adt.make_{TypeName}_{CtorName}` factory functions
- Added automatic injection of `$builtin` module exports into all modules' `externalTypes`
- Builtins now available globally without explicit imports
- Added `AddBuiltinsToGlobalEnv()` calls for both REPL and module compilation paths

**Module Linker** (`internal/link/module_linker.go`)
- Enhanced `BuildGlobalEnv()` to handle three symbol types: functions, types, constructors
- Types: Skip adding to environment (handled by type checker)
- Constructors: Add with `$adt` module reference for factory functions
- Functions: Add with original module reference
- Improved error reporting with separate listings for types and constructors
- Added `continue` statements to skip further processing for types/constructors

**Working Examples:**
```ailang
// Type and constructor imports work
import stdlib/std/option (Option, Some, None)

// Constructor usage (pending $adt runtime)
let x = Some(42)
match x {
  Some(n) => n,
  None => 0
}
```

**Test Results:**
- ‚úÖ Constructor imports: `import stdlib/std/option (Some)` type-checks
- ‚úÖ Type imports: `import stdlib/std/option (Option)` type-checks
- ‚úÖ Function imports: `import stdlib/std/option (getOrElse)` works
- ‚úÖ All existing tests pass (no regressions)
- ‚è≥ Constructor evaluation pending `$adt` runtime implementation

---

#### Part B: Builtin Type Visibility (~300 LOC)
**Made string and IO primitives available to all modules:**

**Builtin Module Enhancement** (`internal/link/builtin_module.go`)
- Added `handleStringPrimitive()` function for 7 string builtins:
  - `_str_len: String -> Int` (UTF-8 rune count)
  - `_str_slice: String -> Int -> Int -> String` (rune-based substring)
  - `_str_compare: String -> String -> Int` (lexicographic, returns -1/0/1)
  - `_str_find: String -> String -> Int` (first occurrence, rune index)
  - `_str_upper: String -> String` (Unicode-aware uppercase)
  - `_str_lower: String -> String` (Unicode-aware lowercase)
  - `_str_trim: String -> String` (Unicode whitespace)
- Added `handleIOBuiltin()` function for 3 IO builtins:
  - `_io_print: String -> Unit ! {IO}` (no newline)
  - `_io_println: String -> Unit ! {IO}` (with newline)
  - `_io_readLine: Unit -> String ! {IO}` (read from stdin)
- Proper effect row representation: `&types.Row{Kind: types.EffectRow, Labels: {"IO": ...}}`
- All builtins registered in `$builtin` module interface

**Pipeline Integration** (`internal/pipeline/pipeline.go`)
- Automatic injection of `$builtin` module into every module's compilation context
- Builtins available in `externalTypes` for type checking
- Builtins available in `globalRefs` for elaboration
- No explicit imports required - builtins are globally visible

**Test Results:**
- ‚úÖ `stdlib/std/string.ail` type-checks successfully (7 exports)
- ‚è≥ `stdlib/std/io.ail` has parse errors (inline function syntax limitation)
- ‚úÖ String primitives: length, substring, toUpper, toLower, trim, compare, find
- ‚úÖ Effect tracking: IO functions properly annotated with `! {IO}`

**Example Working:**
```ailang
module stdlib/std/string

export pure func length(s: string) -> int { _str_len(s) }
export pure func toUpper(s: string) -> string { _str_upper(s) }
// ... all 7 functions type-check correctly
```

---

### Added - Parser Fix + Stdlib Foundation (~300 LOC)

#### Generic Type Parameter Fix (`internal/parser/parser.go`)
**1-line fix unblocks generic functions in modules:**

**Issue Discovered**: Generic function syntax failed during stdlib implementation
```ailang
export func map[a, b](f: (a) -> b, xs: [a]) -> [b]  -- ‚ùå Parser error
```

**Root Cause**: After `parseTypeParams()` parsed `[a, b]`, parser was positioned AT `(` but code called `expectPeek(LPAREN)` expecting to PEEK at next token.

**Fix Applied** (lines 554-582):
- Check `hasTypeParams` flag to determine token positioning
- If generic: `curTokenIs(LPAREN)` (already at opening paren)
- If non-generic: `expectPeek(LPAREN)` (need to advance)
- Handles all cases: `func[T]()`, `func[T](x)`, `func()`, `func(x)`

**Impact**: ‚úÖ Generic function declarations now parse correctly in module files

---

#### String & IO Builtins Implementation (~150 LOC)

**7 String Primitives** (`internal/eval/builtins.go`):
- `_str_len(s: string) -> int` - UTF-8 aware length (rune count, not bytes)
- `_str_slice(s: string, start: int, end: int) -> string` - Substring with rune indices
- `_str_compare(a: string, b: string) -> int` - Lexicographic comparison (-1, 0, 1)
- `_str_find(s: string, sub: string) -> int` - First occurrence index (rune-based)
- `_str_upper(s: string) -> string` - Unicode-aware uppercase
- `_str_lower(s: string) -> string` - Unicode-aware lowercase
- `_str_trim(s: string) -> string` - Unicode whitespace trimming

**3 IO Primitives** (effectful: `IsPure: false`):
- `_io_print(s: string) -> ()` - Print without newline
- `_io_println(s: string) -> ()` - Print with newline
- `_io_readLine() -> string` - Read line from stdin (stub for v0.1.0)

**Design Principles**:
- UTF-8 safe: All string operations use rune indices, not byte indices
- Deterministic: No locale-dependent behavior
- Pure primitives: String functions are pure (IsPure: true)
- Effectful IO: IO functions marked impure (IsPure: false) for future effect tracking

**Updated CallBuiltin()** to handle:
- 0-argument functions: `_io_readLine()`
- 3-argument functions: `_str_slice(s, start, end)`
- New type signatures: `String -> Int`, `String -> String`, `String -> Unit`

---

#### Stdlib Modules Prepared (Ready for Deployment)

**5 Stdlib Modules Written** (~360 LOC AILANG code):
- `std_list.ail` (~180 LOC): map, filter, foldl, foldr, length, head, tail, reverse, concat, zip
- `std_option.ail` (~50 LOC): Option[a], map, flatMap, getOrElse, isSome, filter
- `std_result.ail` (~70 LOC): Result[a,e], map, mapErr, flatMap, isOk, unwrap
- `std_string.ail` (~40 LOC): length, concat, substring, join, toUpper, toLower, trim
- `std_io.ail` (~20 LOC): print, println, readLine, debug with `! {IO}` effects

**Status**: ‚ö†Ô∏è BLOCKED - Parser doesn't support pattern matching inside function bodies

**Blocker Details**:
- ‚úÖ Pattern matching works at top-level: `match Some(42) { ... }` (proven)
- ‚ùå Pattern matching fails inside functions: `export func f() { match x { ... } }` (broken)
- Error: "expected =>, got ] instead" when parsing list patterns `[]`, `[x, ...rest]`
- Affects: ALL stdlib modules (they use pattern matching extensively)

**Next Steps**: Fix pattern matching in function bodies (~1-2 days parser work)

---

### Fixed

**Parser Token Positioning** (`internal/parser/parser.go:554-582`)
- Generic type parameters now work in function declarations
- Correctly handles: `func name[T]()`, `func name[T](x: T)`, `func name()`, `func name(x: int)`
- Test case verified: `export func getOrElse[a](opt: Option[a], d: a) -> a` parses

---

### Changed

**CallBuiltin Signature Support** (`internal/eval/builtins.go`)
- Added 0-argument builtin handling (for `_io_readLine`)
- Added 3-argument builtin handling (for `_str_slice`)
- Extended type signatures: `String -> Int`, `String -> String`, `String -> Unit`

---

### Technical Details

**Files Modified**:
- `internal/parser/parser.go` (~30 LOC): Generic function fix
- `internal/eval/builtins.go` (~150 LOC): String and IO primitives
- Total: ~180 LOC implementation

**Stdlib Modules Created** (not yet deployable):
- 5 modules (~360 LOC) written and ready
- Blocked pending pattern matching parser fix

**Test Coverage**: Generic function test case passes, builtins compile and register

**Metrics**:
- Builtins: 10 new primitives (7 string + 3 IO)
- Parser fix: Unblocks generic functions in modules
- Stdlib: Ready to deploy once parser fixed

---

## [v0.0.10] - 2025-10-01

### Added - M-P4: Effect System (Type-Level) (~1,060 LOC)

#### Complete Type-Level Effect Tracking
**Full pipeline integration from parsing through type checking:**

**Effect Syntax Parsing** (`internal/parser/parser.go`, `internal/parser/effects_test.go`)
- Function declarations: `func f() -> int ! {IO, FS}`
- Lambda expressions: `\x. body ! {IO}`
- Type annotations: `(int) -> string ! {FS}`
- Comprehensive validation against 8 canonical effects: IO, FS, Net, Clock, Rand, DB, Trace, Async
- Error codes: PAR_EFF001_DUP (duplicates), PAR_EFF002_UNKNOWN (unknown effect with suggestions)
- Fixed BANG operator precedence to allow `! {Effects}` syntax
- 17 parser tests passing ‚úÖ

**Effect Elaboration Helpers** (`internal/types/effects.go`, `internal/types/effects_test.go`)
- `ElaborateEffectRow()`: Converts AST effect strings to normalized `*Row` with deterministic alphabetical sorting
- `UnionEffectRows()`: Merges two effect rows (e.g., `{IO} ‚à™ {FS} = {FS, IO}`)
- `SubsumeEffectRows()`: Checks effect subsumption (a ‚äÜ b) for capability checking
- `EffectRowDifference()`: Computes missing effects for error messages
- `FormatEffectRow()`: Pretty-prints effect rows as `! {IO, FS}`
- `IsKnownEffect()`: Validates effect names against canonical set
- Purity sentinel: `nil` effect row = pure function (not empty-but-non-nil)
- Closed rows only: `Tail = nil` always (no row polymorphism in v0.1.0)
- 29 elaboration tests passing ‚úÖ

**Type Checking Integration** (`internal/elaborate/elaborate.go`, `internal/types/typechecker_core.go`)
- Effect annotations stored in `Elaborator.effectAnnots` map (Core node ID ‚Üí effect names)
- Validation during elaboration using `ElaborateEffectRow()`
- Effect annotations thread to `CoreTypeChecker.effectAnnots`
- Modified `inferLambda()` to use explicit effect annotations when present
- Falls back to body effect inference when no annotation provided
- Annotations flow: AST ‚Üí Elaboration ‚Üí Type Checking ‚Üí TFunc2.EffectRow
- Existing effect infrastructure leveraged (effects already propagate through `inferApp`, `inferIf`, etc.)

**Files Modified:**
- `internal/parser/parser.go` (+150 LOC): Effect annotation parsing with validation
- `internal/parser/effects_test.go` (+360 LOC new file): 17 test cases
- `internal/types/effects.go` (+170 LOC new file): Effect row elaboration helpers
- `internal/types/effects_test.go` (+280 LOC new file): 29 test cases
- `internal/elaborate/elaborate.go` (+30 LOC): Effect annotation storage
- `internal/types/typechecker_core.go` (+40 LOC): Effect annotation integration
- Total: ~1,060 LOC (700 LOC core + 360 LOC tests)

**Key Design Decisions:**
1. **Purity Sentinel**: `nil` effect row = pure, never empty-but-non-nil
2. **Deterministic Normalization**: All effect labels sorted alphabetically
3. **Closed Rows**: No row polymorphism in v0.1.0 (Tail = nil always)
4. **Canonical Effects**: IO, FS, Net, Clock, Rand, DB, Trace, Async (8 total)
5. **Type-Level Only**: No runtime effect enforcement (deferred to v0.2.0)
6. **Effects in Type System**: Stored in TFunc2.EffectRow, not Core Lambda AST

**Test Results:**
- ‚úÖ 17 parser tests passing (effect syntax, validation, error messages)
- ‚úÖ 29 elaboration tests passing (ElaborateEffectRow, unions, subsumption)
- ‚úÖ All existing type checker tests passing
- ‚úÖ Full test suite passing (parser, elaboration, types)

**Outcome:** M-P4 effect system foundation is COMPLETE and ready for use! The infrastructure for type-level effect tracking is in place and working.

**Deferred to v0.2.0:**
- Runtime effect handlers and capability passing
- Effect polymorphism (row polymorphism: `! {IO | r}`)
- Pure function verification at compile time

---

### Added - M-P3: Pattern Matching Foundation with ADT Runtime

#### Minimal ADT Runtime Implementation (~600 LOC)
**Complete algebraic data type support with pattern matching:**

**TaggedValue Runtime** (`internal/eval/value.go`, `internal/eval/eval_core.go`)
- Runtime representation for ADT constructors with `TypeName`, `CtorName`, `Fields`
- Pretty-printing: `None`, `Some(42)`, `Ok(Some(99))`
- Helper functions: `isTag()` for constructor matching, `getField()` for field extraction
- Full test coverage: 16 test cases across 3 test suites

**$adt Synthetic Module** (`internal/link/builtin_module.go`)
- Factory function synthesis: `make_<TypeName>_<CtorName>` pattern
- Deterministic ordering (sorted by type name, then constructor name)
- Automatic registration from all loaded module interfaces
- Example: `make_Option_Some`, `make_Option_None`

**Type Declaration Elaboration** (`internal/elaborate/elaborate.go`)
- `normalizeTypeDecl()` converts AST type declarations to runtime constructors
- Tracks type parameters, field types, and arity
- Distinguishes local vs imported constructors
- Constructor tracking in elaborator with `constructors` map

**Constructor Expression Support**
- Non-nullary: `Some(42)` ‚Üí `VarGlobal("$adt", "make_Option_Some")(42)`
- Nullary: `None` ‚Üí `VarGlobal("$adt", "make_Option_None")` (direct value, not function call)
- Automatic elaboration in `normalizeFuncCall()` and identifier normalization
- Factory resolution with arity-aware handling (nullary returns value, others return function)

**Constructor Pattern Matching** (`internal/eval/eval_core.go`)
- Extended `matchPattern()` to handle `ConstructorPattern`
- Recursive field pattern matching with variable binding
- Constructor name and arity validation
- Full destructuring support: `Some(x)`, `Ok(Some(y))`, `None`

**Pipeline Integration** (`internal/pipeline/pipeline.go`)
- Constructors extracted from elaborator and added to module interfaces
- Factory types registered in `externalTypes` before type checking
- Used TFunc2/TVar2 (new type system) for unification compatibility
- Monomorphic result types (e.g., `Option` not `Option[Int]`) due to TApp limitation

**Interface Builder Enhancement** (`internal/iface/builder.go`)
- `BuildInterfaceWithConstructors()` accepts constructor information
- Constructors included in module interface for imports
- Constructor schemes with field types and result types

**Working Examples**:
```ailang
type Option[a] = Some(a) | None

match Some(42) {
  Some(n) => n,
  None => 0
}
-- Output: 42 ‚úÖ

match None {
  Some(n) => n,
  None => 999
}
-- Output: 999 ‚úÖ
```

#### Key Technical Decisions
1. **No new Core IR nodes**: Constructor calls use `VarGlobal("$adt", "make_*")` pattern
2. **Runtime factory functions**: $adt module populated at link time from interfaces
3. **Direct evaluation**: Match expressions evaluate without lowering pass
4. **Deterministic**: Factory names sorted, stable digest computation
5. **Nullary handling**: Returns TaggedValue directly (not wrapped in function)
6. **Type system hybrid**: TCon (old) + TFunc2/TVar2 (new) for unification compatibility

#### Files Changed
- `internal/eval/value.go`: Added TaggedValue type (~25 LOC)
- `internal/eval/eval_core.go`: Added isTag, getField helpers, constructor pattern matching (~180 LOC)
- `internal/link/builtin_module.go`: Added RegisterAdtModule (~120 LOC)
- `internal/link/module_linker.go`: Added GetLoadedModules method
- `internal/elaborate/elaborate.go`: Added normalizeTypeDecl, constructor tracking, nullary handling (~150 LOC)
- `internal/pipeline/compile_unit.go`: Added ConstructorInfo, Constructors field (~25 LOC)
- `internal/iface/builder.go`: Added BuildInterfaceWithConstructors (~60 LOC)
- `internal/pipeline/pipeline.go`: Added constructor pipeline wiring, TFunc2/TVar2 factory types (~120 LOC)
- `internal/link/resolver.go`: Enhanced resolveAdtFactory with arity lookup (~60 LOC)

#### Test Coverage
- 16 test cases: TaggedValue, isTag, getField functions
- End-to-end examples: `examples/adt_simple.ail`
- Both nullary and non-nullary constructors verified

### Known Limitations (Future Work)
- ‚ö†Ô∏è Let bindings with constructors have elaboration bug ("normalization received nil expression")
- ‚ö†Ô∏è Result types are monomorphic (`Option` vs `Option[Int]`) - TApp not supported in unifier yet
- ‚ö†Ô∏è No exhaustiveness checking for pattern matches
- ‚ö†Ô∏è No guard evaluation (guards are parsed but not evaluated)
- ‚ö†Ô∏è Type system migration incomplete: Mix of old (TFunc, TVar) and new (TFunc2, TVar2) types

### Technical Details
- Total implementation: ~600 LOC (3 days, as estimated)
- Pattern matching: Tuples, literals, variables, wildcards, constructors all work
- Type checking: Polymorphic factory types with proper unification
- Runtime: TaggedValue representation with arity-aware factory resolution
- Deterministic: All constructor names sorted, stable module digests

### Migration Notes
- ADT runtime is fully backward compatible
- Type declarations now elaborate to runtime constructors automatically
- Constructor expressions work in pattern contexts and regular code
- $adt module is synthetic and doesn't require explicit imports

## [v0.0.9] - 2025-09-30

### Changed - Upgraded to Go 1.22

**Security & Performance Upgrade:**
- Upgraded from Go 1.19 ‚Üí Go 1.22.12 (Go 1.19 EOL since Sept 2023)
- Updated `golang.org/x/text` from v0.20.0 ‚Üí v0.21.0
- Updated CI workflow to use Go 1.22
- All tests and linting pass with new version

**Benefits:**
- Security patches for 2+ years of vulnerabilities
- 1-3% CPU performance improvement
- ~1% memory reduction
- For-loop variable scoping fix (prevents common bugs)
- Enhanced HTTP routing, better generics support

**Files Changed:**
- `go.mod`: go 1.22, golang.org/x/text v0.21.0
- `.github/workflows/ci.yml`: go-version: '1.22'
- `.github/workflows/build.yml`: go-version: '1.22' (fixes Windows builds)
- `.github/workflows/release.yml`: go-version: '1.22'
- `go.sum`: Updated checksums

### Fixed - Windows Golden File Tests

**Cross-platform Test Compatibility:**
- Fixed Windows test failures in `TestLiterals` subtests
- Issue: Golden files checked out with CRLF line endings on Windows but comparison used raw bytes
- Solution: Normalize line endings (CRLF ‚Üí LF) in both `want` and `got` strings before comparison
- Updated `goldenCompare()` function in `internal/parser/testutil.go`
- All platforms (Linux, macOS, Windows) now pass golden file tests consistently

### Added - M-P2 Lock-In: Type System Hardening

#### Coverage Regression Protection
- Per-package coverage gates in Makefile (`cover-parser`, `gate-parser`, `cover-lexer`, `gate-lexer`)
- Parser baseline: 70% coverage (up from 69%)
- Lexer baseline: 57% coverage
- CI workflow enforces coverage thresholds on every push
- Golden drift protection: CI fails if golden files change without `ALLOW_GOLDEN_UPDATES=1`
- New make target: `check-golden-drift` validates golden file stability

#### Type Alias vs Sum Type Disambiguation
- Fixed bug: `type Names = [string]` now correctly parses as TypeAlias, not AlgebraicType
- Added `TypeAlias` AST node in `internal/ast/ast.go`
- Implemented `hasTopLevelPipe()` helper to detect sum types by presence of `|` operator
- Updated `parseTypeDeclBody()` to distinguish:
  - Type aliases: `type UserId = int`, `type Names = [string]`
  - Sum types: `type Color = Red | Green | Blue`
- Regenerated all type golden files with correct TypeAlias representation

#### Nested Record Types
- Record types now work in type positions: `type User = { addr: { street: string } }`
- Added `typeNode()`, `String()`, `Position()` methods to RecordType
- Created `parseRecordTypeExpr()` function for `{...}` in type expressions
- Added test case `TestRecordTypes/nested_record` with golden file
- RecordType now implements both TypeDef and Type interfaces

#### Export Metadata Tracking
- Added `Exported bool` field to TypeDecl AST node
- Updated `parseTypeDeclaration(exported bool)` to track export status
- AST printer includes `"exported": true` in JSON output for exported types
- Tests validate: `export type PublicColor = Red | Green` vs `type PrivateData = { value: int }`
- Regenerated export golden files with metadata

#### REPL/File Type Parity
- New test suite: `TestREPLFileParityTypes` with 10 type declaration test cases
- Validates identical parsing for: aliases, lists, records (simple & nested), sum types, generics, exports
- All type declarations parse identically in REPL (`<repl>`) vs file (`test.ail`) contexts
- Parser coverage increased to 70.8%

#### Metrics
- Parser coverage: 69% ‚Üí 70.8%
- New tests: 11 (1 nested record + 10 parity tests)
- All existing parser tests pass (544ms test suite)
- Golden files: 3 regenerated (export_alias, export_record, export_sum)
- Code changes: 7 files (ast.go, parser.go, print.go, repl_parity_test.go, type_test.go, Makefile, ci.yml)

### Added - M-P1: Parser Baseline (2025-09-30)

#### Comprehensive Test Infrastructure
- Created deterministic AST printer in `internal/ast/print.go` (445 lines)
- Created test utilities in `internal/parser/testutil.go` (241 lines)
- Established golden file testing framework with 116 snapshots
- Added Makefile targets: `test-parser`, `test-parser-update`, `fuzz-parser`

#### Test Coverage Across All Parser Features
- **Expression tests** (`expr_test.go`, 385 lines): 85 test cases covering literals, operators, collections, lambdas
- **Precedence tests** (`precedence_test.go`, 283 lines): 53 test cases validating operator precedence
- **Module tests** (`module_test.go`, 142 lines): 17 test cases for module/import declarations
- **Function tests** (`func_test.go`, 252 lines): 22 test cases for function declarations and signatures
- **Error recovery tests** (`error_recovery_test.go`, 312 lines): 38 test cases for graceful error handling
- **Invariant tests** (`invariants_test.go`, 320 lines): UTF-8 normalization, CRLF handling, BOM stripping
- **REPL parity tests** (`repl_parity_test.go`, 220 lines): Ensures REPL and file parsing consistency
- **Fuzz tests** (`fuzz_test.go`, 181 lines): 4 fuzz functions with 47 seed cases

#### Baseline Metrics
- **506 test cases** total across all parser features
- **70.2% line coverage** (baseline frozen)
- **Zero panics** in 52k+ fuzz executions
- **2,233 lines** of test code
- All tests pass in ~550ms

## [v0.0.7] - 2025-09-29

### Added - Milestone A2: Structured Error Reporting

#### Unified Error Report System (`internal/errors/report.go`)
- Canonical `errors.Report` type with schema `ailang.error/v1`
- `ReportError` wrapper preserves structured errors through error chains
- `AsReport()` function for type-safe error unwrapping using `errors.As()`
- `WrapReport()` ensures Reports survive through error propagation
- JSON-serializable with deterministic field ordering
- Structured `Data` map with sorted arrays for reproducibility
- `Fix` suggestions with confidence scores
- ~120 lines of core error infrastructure

#### Standardized Error Codes
- **IMP010** - Symbol not exported by module
  - Data: `symbol`, `module_id`, `available_exports[]`, `search_trace[]`
  - Suggests checking available exports in target module
- **IMP011** - Import conflict (multiple providers for same symbol)
  - Data: `symbol`, `module_id`, `providers[{export, module_id}]`
  - Suggests using selective imports to resolve conflict
- **IMP012** - Unsupported import form (namespace imports)
  - Data: `module_id`, `import_syntax`
  - Suggests using selective import syntax
- **LDR001** - Module not found during load
  - Data: `module_id`, `search_trace[]`, `similar[]`
  - Provides resolution trace and similar module suggestions
- **MOD006** - Cannot export underscore-prefixed (private) names
  - Parser validation prevents accidental private exports

#### Error Flow Hardening
- Removed `fmt.Errorf()` wrappers in `internal/elaborate/elaborate.go:112`
- Removed `fmt.Errorf()` wrappers in `internal/pipeline/pipeline.go:434`
- All error builders return `*errors.Report` instead of generic errors
- Link phase wraps reports with `errors.WrapReport()` in `internal/link/module_linker.go`
- Loader phase wraps reports with `errors.WrapReport()` in `internal/loader/loader.go`
- Errors flow end-to-end as first-class types, not string wrappers

#### CLI JSON Output (`cmd/ailang/main.go`)
- `--json` flag enables structured JSON error output
- `--compact` flag for token-efficient JSON serialization
- `handleStructuredError()` extracts Reports using `errors.As()`
- Generic error fallback for non-structured errors
- Exit code 1 for all error conditions

#### Golden File Testing Infrastructure
- **Test files** (`tests/errors/`):
  - `lnk_unresolved_symbol.ail` - Tests IMP010 (symbol not exported)
  - `lnk_unresolved_module.ail` - Tests LDR001 (module not found)
  - `import_conflict.ail` - Tests IMP011 (import conflict)
  - `export_private.ail` - Tests MOD_EXPORT_PRIVATE (private export)
- **Golden files** (`goldens/`):
  - `lnk_unresolved_symbol.json` - Expected IMP010 output
  - `lnk_unresolved_module.json` - Expected LDR001 output
  - `import_conflict.json` - Expected IMP011 output
  - `imports_basic_success.json` - Expected success output (value: 6)
- Golden files ensure byte-for-byte reproducibility of error output

#### Makefile Test Targets
- `make test-imports-success` - Verifies successful imports work
- `make test-import-errors` - Validates golden file matching with `diff -u`
- `make regen-import-error-goldens` - Regenerates golden files (use with caution)
- `make test-imports` - Combined import testing (success + errors)
- `make test-parity` - REPL/file parity test (manual, requires interactive REPL)

#### CI Integration (`.github/workflows/ci.yml`)
- Split import testing into explicit steps:
  - "Test import system (success cases)" - Runs `make test-imports-success`
  - "Test import errors (golden file verification)" - Runs `make test-import-errors`
- CI gates prevent regression in error reporting determinism
- Integrated into `ci-strict` target with operator lowering and builtin freeze tests

### Changed
- `internal/link/report.go` - All builders return `*errors.Report`
- `internal/link/env.go` - Renamed old `LinkReport` to `LinkDiagnostics` to avoid confusion
- `internal/loader/loader.go` - Search trace collection during module resolution
- `internal/parser/parser.go` - Added MOD_EXPORT_PRIVATE validation

### Fixed
- Structured errors were being stringified by `fmt.Errorf("%w")` wrappers
- Error type information now survives through error chains using `errors.As()`
- Flag ordering: Flags must come BEFORE subcommand (`ailang --json --compact run file.ail`)

### Technical Details
- Total new code: ~680 lines (implementation + test files + golden files)
- Test coverage: Golden files ensure deterministic error output
- Determinism: All arrays sorted, canonical module IDs, stable JSON field ordering
- No breaking changes to existing functionality
- Schema versioning allows future enhancements without breaking compatibility

### Migration Notes
- Existing error handling continues to work unchanged
- JSON output is opt-in via `--json` flag
- Structured errors available via `errors.AsReport()` for tools integration
- Golden file tests serve as documentation of expected error formats

## [v0.0.6] - 2025-09-29

### Added

#### Error Code Taxonomy (`internal/errors/codes.go`)
- Comprehensive error code system with structured taxonomy
- Error codes organized by phase: PAR (Parser), MOD (Module), LDR (Loader), TC (Type Check), etc.
- Error registry with phase and category metadata
- Helper functions: `IsParserError()`, `IsModuleError()`, `IsLoaderError()`, etc.
- ~278 lines of structured error definitions

#### Manifest System (`internal/manifest/`)
- Example manifest format for tracking example status (working/broken/experimental)
- Validation ensures consistency between documentation and implementation
- Statistics calculation with coverage metrics
- README generation support for automatic documentation updates
- Environment defaults for reproducible execution
- ~390 lines with full validation logic

#### Module Loader (`internal/module/loader.go`)
- Complete module loading system with dependency resolution
- Circular dependency detection using cycle detection algorithm
- Topological sorting using Kahn's algorithm for build order
- Module caching with thread-safe concurrent access
- Support for stdlib modules and relative imports
- Structured error reporting with resolution traces
- ~607 lines of robust module management

#### Path Resolver (`internal/module/resolver.go`)
- Cross-platform path normalization and resolution
- Support for relative imports (`./`, `../`)
- Standard library path resolution (`std/`)
- Project root detection and search path management
- Case-sensitive and case-insensitive filesystem handling
- Module identity derivation from file paths
- ~405 lines of platform-aware path handling

#### Example Files
- Basic module with function declarations
- Recursive functions with inline tests
- Module imports and composition
- Standard library usage patterns
- Property-based testing examples

### Changed
- Test coverage improved from 29.9% to 31.3%
- Module tests now include comprehensive cycle detection validation
- Topological sort correctly handles dependency ordering

### Fixed
- CI/CD script compilation errors by refactoring shared types into `scripts/internal/reporttypes`
- Test suite now correctly excludes `scripts/` directory containing standalone executables
- Makefile and CI workflow updated to use `go list ./... | grep -v /scripts` for testing

## [v0.0.5] - 2025-09-29

### Added

#### Schema Registry (`internal/schema/`)
- Frozen schema versioning system with forward compatibility
- Schema constants: `ErrorV1` (ailang.error/v1), `TestV1` (ailang.test/v1), `EffectsV1` (ailang.effects/v1)
- `Accepts()` method for prefix matching against newer schema versions
- `MarshalDeterministic()` for stable JSON output with sorted keys
- `CompactMode` flag support for token-efficient JSON serialization
- Registry pattern for managing versioned schemas across components
- ~145 lines of core implementation

#### Error JSON Encoder (`internal/errors/`)
- Structured error taxonomy with stable error codes (TC###, ELB###, LNK###, RT###)
- Always includes `fix` field with actionable suggestion and confidence score
- SID (Stable Node ID) discipline with "unknown" fallback for safety
- Builder pattern API: `WithFix()`, `WithSourceSpan()`, `WithMeta()`
- Schema-compliant JSON output using ailang.error/v1
- Safe encoding that never panics on malformed data
- ~190 lines with comprehensive error handling

#### Test Reporter (`internal/test/`)
- Structured test reporting in JSON format using ailang.test/v1 schema
- Complete test counts shape: passed/failed/errored/skipped/total
- Platform information capture for reproducibility tracking
- Deterministic sorting by suite name and test name
- Valid JSON output even with zero tests
- Test runner integration with SID generation
- ~206 lines with full test lifecycle support

#### REPL Effects Inspector (`internal/repl/effects.go`)
- `:effects <expr>` command for type and effect introspection
- Returns type signature and effect requirements without evaluation
- Supports both human-readable and JSON output modes
- Placeholder implementation (full version pending effect system)
- Schema-compliant output using ailang.effects/v1
- ~41 lines with extensible architecture

#### CLI Compact Mode Support
- `--compact` flag added to main CLI for global compact JSON mode
- Integrates with schema registry's `CompactMode` setting
- Affects all JSON output including errors, tests, and effects
- Token-efficient output for AI agent integration

#### Golden Test Framework Enhancements
- Platform-specific salt generation for reproducibility
- `UPDATE_GOLDENS` environment variable support
- JSON diff utilities for test validation
- Deterministic fixture generation and validation
- ~309 lines of comprehensive test infrastructure

### Added - Test Coverage & Quality
- 100% test coverage for schema registry (unit + integration)
- 100% test coverage for error encoder with edge cases
- 100% test coverage for test reporter with platform variations
- Golden test fixtures for all schema-compliant JSON outputs
- Integration tests validating cross-component schema compliance
- ~470 lines of test code ensuring reliability

### Changed
- All JSON output now uses deterministic field ordering
- Error messages consistently include actionable fix suggestions
- Test reporting standardized across all components
- Platform information consistently captured for reproducibility

### Technical Details
- Total new code: ~1,630 lines (implementation + tests)
- Dependencies: No new external dependencies
- Schema versioning: Forward-compatible design
- JSON output: Deterministic and stable across platforms
- Test coverage: 100% for all new packages

### Migration Notes
- All existing functionality preserved
- New features are opt-in via CLI flags and REPL commands
- JSON output format enhanced but remains backward compatible
- Schema versioning allows gradual migration to newer formats

## [v0.0.4] - 2025-09-28

### Added

#### Example Verification System (`scripts/`)
- `verify_examples.go` - Tests all examples, categorizes as passed/failed/skipped
- Outputs in JSON, Markdown, and plain text formats
- Captures error messages for failed examples
- Skips test/demo files automatically
- ~200 lines of Go code

#### README Auto-Update System
- `update_readme.go` - Updates README with verification status
- Auto-generates status table between markers
- Creates badges for CI, coverage, and example status
- Maintains timestamp of last update
- ~150 lines of Go code

#### CI GitHub Actions (`.github/workflows/ci.yml`)
- Automated testing on push/PR to main/dev branches
- Example verification with failure on broken examples
- Test coverage reporting to Codecov
- Auto-commits README updates on dev branch
- Build artifact generation
- Parallel linting and testing jobs

#### Make Targets
- `make verify-examples` - Run example verification
- `make update-readme` - Update README with status
- `make flag-broken` - Add warning headers to broken examples
- `make test-coverage-badge` - Generate coverage metrics
- `make ci` - Full CI pipeline

### Added - Documentation
- CI status badges in README (CI, Coverage, Examples)
- Auto-generated example status table
- Example verification report showing 13 working, 13 failing, 14 skipped
- Warning headers for broken examples (via `flag_broken_examples.go`)
- `.gitignore` entries for CI-generated files

### Changed
- REPL now displays version from git tags dynamically (via ldflags)
- All v3.x version references updated to semantic versioning (v0.0.x)
- Example files renamed to match version scheme (v0_0_3_features_demo.ail)
- Design docs restructured to match version scheme

### Technical Details
- Total new code: ~500 lines
- Test coverage: Verification scripts fully tested
- No external dependencies added
- Apache 2.0 license badge added

## [v0.0.3] - 2025-09-26

### Added

#### Schema Registry (`internal/schema/`)
- Versioned JSON schemas with forward compatibility
- `Accepts()` for schema version negotiation
- `MarshalDeterministic()` for stable JSON output
- `CompactMode` support for token-efficient output
- Schema constants: `ErrorV1`, `TestV1`, `DecisionsV1`, `PlanV1`, `EffectsV1`

#### Error JSON Encoder (`internal/errors/`)
- Structured error taxonomy with codes (TC###, ELB###, LNK###, RT###)
- Always includes `fix` field with suggestion and confidence score
- SID (Stable Node ID) discipline with fallback to "unknown"
- Builder pattern: `WithFix()`, `WithSourceSpan()`, `WithMeta()`
- Safe encoding that never panics

#### Test Reporter (`internal/test/`)
- Structured test reporting in JSON format
- Full counts shape (passed/failed/errored/skipped/total)
- Platform information for reproducibility
- Deterministic sorting by suite and name
- Valid JSON output even with 0 tests
- Test runner with SID generation

#### Effects Inspector
- `:effects <expr>` command for type/effect introspection
- Returns type and effects without evaluation
- Supports compact JSON mode
- Placeholder implementation (full version pending effect system)

#### Golden Test Framework (`testutil/`)
- Platform salt for reproducibility tracking
- `UPDATE_GOLDENS` environment variable support
- JSON diff utilities
- Deterministic test fixtures

#### REPL Enhancements
- `:test [--json]` - Run tests with optional JSON output
- `:effects <expr>` - Inspect type and effects
- `:compact on/off` - Toggle JSON compact mode
- Updated help with new commands

### Added - Examples & Documentation
- `examples/v3_2_features_demo.ail` - Demonstrates new v3.2 features
- `examples/repl_commands_demo.md` - REPL command documentation
- `examples/ai_agent_integration.ail` - Comprehensive AI agent guide
- `examples/working_v3_2_demo.ail` - Working examples for current state
- `design_docs/implemented/v3_2/` - Implementation report with metrics
- Comprehensive test suites for all new packages
- 100% test coverage for schema registry
- 100% test coverage for error encoder
- 100% test coverage for test reporter

### Changed
- `types.CanonKey()` alias added for consistent dictionary key generation
- REPL help updated with new AI-first commands

### Fixed
- Multi-line REPL input for `let...in` expressions
- Added continuation prompt (`...`) for incomplete expressions

### Technical Details
- Total new code: ~1,500 lines
- Test coverage: All new packages fully tested
- Dependencies: No new external dependencies

### Migration Notes
- No breaking changes
- New features are opt-in via REPL commands
- Existing code continues to work unchanged

## [v0.0.2] - Previous Release
- Type class resolution with dictionary-passing
- REPL improvements with history and tab completion
- Core type system implementation

## [v0.0.1] - Initial Release
- Basic lexer and parser
- AST implementation
- Initial REPL

---

# CLAUDE.md (Project Instructions)

# Claude Instructions for AILANG Development

## Project Overview
AILANG is an AI-first programming language designed for AI-assisted development. It features:
- Pure functional programming with algebraic effects (planned)
- Typed quasiquotes for safe metaprogramming (planned)
- CSP-based concurrency with session types (planned)
- Deterministic execution for AI training data generation (planned)
- File extension: `.ail`

## Current Status: v0.3.0-alpha3 (Records & Row Polymorphism COMPLETE ‚úÖ)

**‚úÖ COMPLETE (v0.3.0-alpha3):**
- ‚úÖ **M-R5: Records & Row Polymorphism** (~670 LOC) - COMPLETE
  - Record subsumption for flexible field access
  - TRecordOpen compatibility shim for Day 1 wins
  - TRecord2 with full row polymorphism (opt-in via `AILANG_RECORDS_V2=1`)
  - Row unification with occurs check
  - Helper functions and error codes (TC_REC_001-004)
  - 16 new unit tests, all passing ‚úÖ
  - Fixed 11 examples (9 from subsumption + 2 new) ‚úÖ

**‚úÖ COMPLETE (v0.3.0-alpha2):**
- ‚úÖ **M-R4: Recursion Support** (~1,780 LOC)
  - RefCell-based recursion (OCaml/Haskell style)
  - Self-recursive and mutual recursion
  - Depth guard (configurable limit)
  - Works in module runtime ‚úÖ

- ‚úÖ **M-R8: Block Expressions** (~10 LOC fix)
  - Block syntax `{ e1; e2; e3 }` for sequencing
  - Desugars to let chains
  - Works with recursion ‚úÖ
  - AI-generated code compatible ‚úÖ

**‚úÖ COMPLETE (v0.2.0):**
- ‚úÖ **M-R1: Module Execution Runtime** (~1,874 LOC)
  - Module instance creation and evaluation
  - Cross-module imports at runtime
  - Entrypoint execution (`--entry`, `--args-json`)
  - Function invocation with argument decoding
  - Builtin registry (IO, FS primitives)
  - **Cross-function references within modules**

- ‚úÖ **M-R2: Effect System Runtime** (~1,550 LOC)
  - Capability-based security (`--caps IO,FS`)
  - IO effect: `print`, `println`, `readLine`
  - FS effect: `readFile`, `writeFile`, `exists`
  - Secure by default (no caps unless explicitly granted)
  - Sandbox support (`AILANG_FS_SANDBOX`)

**üìä Test Status:**
- Unit tests: 80+ passing (runtime + effects + records)
- Example files: 48/66 passing (72.7%)
- All record subsumption examples working ‚úÖ
- All effect system examples working ‚úÖ
- All type class examples working ‚úÖ
- All recursion examples working ‚úÖ
- All block expression examples working ‚úÖ

**‚úÖ COMPLETE (v0.1.0):**
- Hindley-Milner type inference with let-polymorphism
- Type classes (Num, Eq, Ord, Show) with dictionary-passing
- Lambda calculus (first-class functions, closures, currying)
- Interactive REPL with full type checking
- Pattern matching (constructors, tuples, lists, wildcards)
- Algebraic data types (ADTs) with runtime
- Structured error reporting with JSON schemas
- AI Evaluation Framework (M-EVAL) with multi-model support
- Pattern matching guards and exhaustiveness warnings (M-R3, optional)

**‚ùå NOT YET IMPLEMENTED:**

- Typed quasiquotes (v0.3.0+)
- CSP concurrency (v0.3.0+)
- AI training data export (v0.3.0+)

**üéâ MAJOR MILESTONE:** Module files now execute! Use `ailang run --caps IO,FS --entry main module.ail` to run module code with effects.

**‚ö†Ô∏è Important**: Flags must come BEFORE the filename when using `ailang run`.

## Key Design Principles
1. **Explicit Effects**: All side effects must be declared in function signatures
2. **Everything is an Expression**: No statements, only expressions that return values
3. **Type Safety**: Static typing with Hindley-Milner inference + row polymorphism
4. **Deterministic**: All non-determinism must be explicit (seeds, virtual time)
5. **AI-Friendly**: Generate structured execution traces for training

## Project Structure (v0.2.0-rc1)
```
ailang/
‚îú‚îÄ‚îÄ cmd/ailang/         # CLI entry point ‚úÖ COMPLETE
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ ast/            # AST definitions ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ lexer/          # Tokenizer ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ parser/         # Parser ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ types/          # Type system ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ typeclass/      # Type classes ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ eval/           # Evaluator ‚úÖ COMPLETE (Core + module support)
‚îÇ   ‚îú‚îÄ‚îÄ repl/           # Interactive REPL ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ runtime/        # Module execution runtime ‚úÖ COMPLETE (v0.2.0)
‚îÇ   ‚îú‚îÄ‚îÄ effects/        # Effect system runtime ‚úÖ COMPLETE (v0.2.0)
‚îÇ   ‚îú‚îÄ‚îÄ loader/         # Module loader ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ errors/         # Error reporting ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ schema/         # JSON schemas ‚úÖ COMPLETE
‚îÇ   ‚îú‚îÄ‚îÄ eval_harness/   # AI evaluation framework ‚úÖ COMPLETE (M-EVAL)
‚îÇ   ‚îú‚îÄ‚îÄ channels/       # CSP implementation ‚ùå TODO (v0.3.0+)
‚îÇ   ‚îî‚îÄ‚îÄ session/        # Session types ‚ùå TODO (v0.3.0+)
‚îú‚îÄ‚îÄ stdlib/             # Standard library ‚úÖ COMPLETE (std/io, std/fs, std/prelude)
‚îú‚îÄ‚îÄ tools/              # Development tools ‚úÖ (benchmarking, example verification)
‚îú‚îÄ‚îÄ benchmarks/         # AI code generation benchmarks ‚úÖ
‚îú‚îÄ‚îÄ examples/           # Example .ail programs (~40 files)
‚îú‚îÄ‚îÄ tests/              # Test suite ‚úÖ
‚îî‚îÄ‚îÄ docs/               # Documentation ‚úÖ COMPLETE
```

## Development Workflow

### Building and Testing
```bash
make build          # Build the interpreter to bin/
make install        # Install ailang to system (makes it available everywhere)
make test           # Run all tests
make run FILE=...   # Run an AILANG file
make repl           # Start interactive REPL
```

### Code Quality & Coverage
```bash
make test-coverage-badge  # Quick coverage check (shows: "Coverage: 29.9%")
make test-coverage        # Run tests with coverage, generates HTML report
make lint                 # Run golangci-lint
make fmt                  # Format all Go code
make fmt-check            # Check if code is formatted
make vet                  # Run go vet
```

### Example Management
```bash
make verify-examples      # Verify all example files work/fail
make update-readme        # Update README with example status
make flag-broken          # Add warning headers to broken examples
```

### Development Helpers
```bash
make deps                 # Install all dependencies
make clean                # Remove build artifacts and coverage files
make ci                   # Run full CI verification locally
make help                 # Show all available make targets
```

#### Keeping `ailang` Up to Date

**Option 1: Manual Update**
After making code changes, run:
```bash
make quick-install  # Fast reinstall
# OR
make install        # Full reinstall with version info
```

### IMPORTANT: Keeping Documentation Updated

**Required documentation updates for every change:**

#### 1. README.md
- Update implementation status when adding new features
- Update current capabilities when functionality changes
- Update examples when they're fixed or new ones added
- Keep line counts and completion status accurate
- Document new builtin functions and operators
- Update the roadmap as items are completed

#### 2. CHANGELOG.md
**Must be updated for every feature or bug fix:**
- Follow semantic versioning (vMAJOR.MINOR.PATCH)
- Group changes by category: Added, Changed, Fixed, Deprecated, Removed
- Include code locations for new features (e.g., `internal/schema/`)
- Note breaking changes clearly
- Add migration notes if needed
- Include metrics (lines of code, test coverage)

Example entry:
```markdown
## [v3.2.0] - 2024-09-28

### Added
- Schema Registry (`internal/schema/`) - Versioned JSON schemas
- Error JSON Encoder (`internal/errors/`) - Structured error reporting
- Test coverage: 100% for new packages
- Total new code: ~1,500 lines
```

#### 3. Design Documentation
- **Before starting**: Create design doc in `design_docs/planned/`
- **After completing**: Move to `design_docs/implemented/vX_Y/`
- Include implementation report with metrics and limitations

**CRITICAL: Example Files Required**
**Every new language feature MUST have a corresponding example file:**
- Create `examples/feature_name.ail` for each new feature
- Include comprehensive examples showing all capabilities
- Add comments explaining the behavior and expected output
- ‚ö†Ô∏è **Test that examples actually work with current implementation**
- ‚ö†Ô∏è **Add warning headers to examples that don't work**
- These examples will be used in documentation and tutorials
- Always test examples before documenting them as working

### Common Tasks

#### Adding a New Language Feature
1. Update token definitions in `internal/lexer/token.go`
2. Modify lexer in `internal/lexer/lexer.go` to recognize tokens
3. Add AST nodes in `internal/ast/ast.go`
4. Update parser in `internal/parser/parser.go`
5. Add type rules in `internal/types/`
6. Implement evaluation in `internal/eval/` (when created)
7. Write tests in corresponding `*_test.go` files
8. Add examples in `examples/`

## Language Syntax Reference

**üìñ When Writing AILANG Code:**
If you (Claude or other AI) are writing AILANG code during development, refer to the **AI Teaching Prompt** for comprehensive syntax guidance:
- **Current version**: [prompts/v0.3.0.md](prompts/v0.3.0.md) (v0.3.0-alpha3 features)
- This is the same prompt used in eval benchmarks and validated through multi-model testing
- Covers syntax, limitations, common pitfalls, and working examples

### ‚úÖ Working Syntax (v0.3.0-alpha3)

**Basic Expressions:**
```ailang
-- Comments use double dash
let x = 5 in x * 2                     -- Let binding (works up to 3 nested)
\x. x * 2                               -- Lambda function
if x > 0 then "pos" else "neg"         -- Conditional expression
{ e1; e2; e3 }                          -- Block expression (NEW! ‚ú®)
[1, 2, 3]                               -- List literal
{ name: "Alice", age: 30 }             -- Record literal
(1, "hello", true)                      -- Tuple literal
1 + 2 * 3                               -- Arithmetic with precedence
"Hello " ++ "World"                     -- String concatenation
```

**REPL Features:**
```ailang
Œª> :type \x. x + x
\x. x + x :: ‚àÄŒ±. Num Œ± ‚áí Œ± ‚Üí Œ±

Œª> let double = \x. x * 2 in double(21)
42 :: Int

Œª> :instances
Available instances: Num[Int], Num[Float], Eq[Int], Eq[Float], Ord[Int], Ord[Float]
```

**Module Syntax (NOW EXECUTES! ‚úÖ):**
```ailang
module examples/demo

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello from module!")
}
```

**Running modules:**
```bash
ailang run --caps IO --entry main examples/demo.ail
# Output: Hello from module!
```

**Pattern Matching:**
```ailang
type Option[a] = Some(a) | None

match Some(42) {
  Some(x) => x * 2,
  None => 0
}
-- Result: 84
```

**Effects (v0.2.0):**
```ailang
import std/io (println)
import std/fs (readFile)

export func main() -> () ! {IO, FS} {
  let content = readFile("data.txt");
  println(content)
}
```

**Running with capabilities:**
```bash
ailang run --caps IO,FS --entry main app.ail
```

**Block Expressions (v0.3.0-alpha2, NEW! ‚ú®):**
```ailang
-- Blocks allow sequencing with automatic let-chain desugaring
{
  println("Computing...");
  println("Result:");
  42
}

-- Perfect for recursive functions with side effects:
func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}
```

**Pattern Guards (M-R3, optional):**
```ailang
match value {
  Some(x) if x > 0 => x * 2,  -- ‚ùå Guards not yet supported
  Some(x) => x,
  None => 0
}
```

### ‚ùå Planned Syntax (Not Yet Implemented)

**Error Propagation (future):**
```ailang
func readAndPrint() -> () ! {IO, FS} {
  let content = readFile("data.txt")?  -- ‚ùå ? operator not implemented
  print(content)
}
```

**Quasiquotes (v0.3.0+):**
```ailang
let query = sql"""SELECT * FROM users WHERE age > ${minAge: int}"""
```

**Concurrency (v0.3.0+):**
```ailang
func worker(ch: Channel[Task]) ! {Async} {
  loop {
    let task <- ch
    ch <- process(task)
  }
}
```

## What Works & What Doesn't (v0.2.0-rc1)

### ‚úÖ Working Features
- ‚úÖ **Module execution** - `ailang run --entry main module.ail`
- ‚úÖ **Effect system** - IO and FS effects with capability security
- ‚úÖ **Pattern matching** - Constructors, tuples, lists, wildcards
- ‚úÖ **ADTs** - Algebraic data types with runtime support
- ‚úÖ **Type classes** - Num, Eq, Ord, Show with dictionary-passing
- ‚úÖ **Imports** - Cross-module imports work at runtime
- ‚úÖ **REPL** - Fully functional with all type system features
- ‚úÖ **Builtins** - String primitives, IO, FS operations

### ‚úÖ Working Examples
```bash
# Module with IO
ailang run --caps IO --entry main examples/test_io_builtins.ail

# Pattern matching with ADTs
ailang run --entry main examples/adt_simple.ail

# Cross-module imports
ailang run --caps IO --entry main examples/effects_basic.ail
```

See [examples/STATUS.md](examples/STATUS.md) for complete example inventory.

### ‚ö†Ô∏è Known Limitations (v0.3.0-alpha2)

**Still TODO:**
1. ‚ö†Ô∏è Pattern matching guards - `if condition` in match arms not evaluated
2. ‚ö†Ô∏è Exhaustiveness checking - No warnings for non-exhaustive patterns
3. ‚ö†Ô∏è Let expressions limited to 3 nesting levels (4+ fails)
4. ‚ùå `tests [...]` and `properties [...]` syntax not implemented
5. ‚ùå Error propagation operator `?` not implemented

**Execution Modes:**
AILANG supports two execution modes:

1. **Simple scripts** (no module declaration):
   - Cannot use `func`, `type`, `import`, `export` keywords
   - Just write expressions: `let x = 5 in x * 2`
   - Run with: `ailang run script.ail`
   - Example: [examples/simple.ail](examples/simple.ail)

2. **Module files** (with `module` declaration):
   - Must start with `module path/name`
   - Can use `func`, `type`, `import`, `export` keywords
   - Can import from stdlib and use effects
   - Run with: `ailang run --caps IO --entry main module.ail`
   - Example: [examples/effects_basic.ail](examples/effects_basic.ail)

**Execution Limitations:**
1. ‚ö†Ô∏è REPL and file execution use different code paths (intentional)
2. ‚ö†Ô∏è Type classes work in REPL and module files, not in simple scripts
3. ‚ö†Ô∏è Record field access has unification bugs in some cases
4. ‚ö†Ô∏è List operations have limited runtime support

See [docs/LIMITATIONS.md](docs/LIMITATIONS.md) for comprehensive details and workarounds.

### üöÄ v0.2.0 Roadmap (3.5-4.5 weeks)

**Status**: Design complete, ready for implementation

**M-R1: Module Execution Runtime** (~1,000-1,300 LOC, 1.5-2 weeks)
- Module instance creation and evaluation
- Cross-module imports at runtime
- Entrypoint execution (`--entry`, `--args-json`)
- `--runner=fallback` to preserve v0.1.0 wrapper

**M-R2: Minimal Effect Runtime** (~700-900 LOC, 1-1.5 weeks)
- Capability-based security (`--caps IO,FS`)
- IO effect: `print`, `println`, `readLine`
- FS effect: `readFile`, `writeFile`, `exists`
- Secure by default (no caps unless explicitly granted)

**M-R3: Pattern Matching Polish** (~450-650 LOC, 1 week) [STRETCH]
- Guards: `pattern if condition => body`
- Exhaustiveness warnings with suggested missing cases
- Decision tree compilation for performance

**See**: [v0.2.0 Implementation Plan](design_docs/planned/v0_2_0_implementation_plan.md)

### üìã Future (v0.3.0+)
1. Effect composition DSL, budgets, async effects
2. Typed quasiquotes (SQL, HTML, JSON)
3. CSP concurrency with channels
4. Session types
5. Property-based testing
6. AI training data export

## REPL Usage (v2.3)

The AILANG REPL now features professional-grade interactive development with full type class support:

### Interactive Features
- **Arrow Key History**: Navigate command history with ‚Üë/‚Üì arrows
- **Persistent History**: Commands saved in `~/.ailang_history`
- **Tab Completion**: Auto-complete REPL commands with Tab key
- **Auto-imports**: `std/prelude` loaded automatically on startup
- **Clean Exit**: `:quit` command properly exits the REPL

### Basic Usage
```bash
ailang repl
```

The REPL auto-imports `std/prelude` on startup, providing:
- Numeric defaults: `Num ‚Üí Int`, `Fractional ‚Üí Float`  
- Type class instances for `Num`, `Eq`, `Ord`, `Show`
- String concatenation with `++` operator
- Record literals and field access

### Key Commands
- `:help, :h` - Show all available commands
- `:quit, :q` - Exit the REPL (also works: Ctrl+D)
- `:type <expr>` - Show qualified type with constraints
- `:import <module>` - Import type class instances
- `:instances` - List available instances with superclass provisions
- `:dump-core` - Toggle Core AST display for debugging
- `:dump-typed` - Toggle Typed AST display
- `:dry-link` - Show required dictionary instances without evaluating
- `:trace-defaulting on/off` - Enable/disable defaulting trace
- `:history` - Show command history
- `:clear` - Clear the screen
- `:reset` - Reset environment (auto-reimports prelude)

### Example REPL Session

```ailang
Œª> 1 + 2
3 :: Int

Œª> 3.14 * 2.0
6.28 :: Float

Œª> "Hello " ++ "AILANG!"
Hello AILANG! :: String

Œª> true && false
false :: Bool

Œª> [1, 2, 3]
[1, 2, 3] :: [Int]

Œª> {name: "Alice", age: 30}
{name: Alice, age: 30} :: {name: String, age: Int}

Œª> :type \x. x + x
\x. x + x :: ‚àÄŒ±. Num Œ± ‚áí Œ± ‚Üí Œ±

Œª> let double = \x. x * 2 in double(21)
42 :: Int
```

### Type Class Pipeline
The REPL executes the full pipeline:
1. **Parse** - Surface syntax to AST
2. **Elaborate** - AST to Core (ANF)
3. **TypeCheck** - Infer types with constraints
4. **Dictionary Elaboration** - Transform operators to dictionary calls
5. **ANF Verification** - Ensure well-formed Core
6. **Link** - Resolve dictionary references
7. **Evaluate** - Execute with runtime dictionaries

### Example Session
```
Œª> 1 + 2 * 3
:: Int
7

Œª> :type 42 == 42
42 == 42 :: Bool

Œª> :instances
Available instances:
  Num:
    ‚Ä¢ Num[Int], Num[Float]
  Eq:
    ‚Ä¢ Eq[Int], Eq[Float]
  Ord:
    ‚Ä¢ Ord[Int] (provides Eq[Int])
    ‚Ä¢ Ord[Float] (provides Eq[Float])
```

### Architecture Notes
- **Type-level instances** (`instEnv`) - Used during type checking and defaulting
- **Runtime dictionaries** (`instances`) - Used during evaluation
- Both must be kept in sync when importing modules
- Method names are standardized: `eq`/`neq`, `lt`/`lte`/`gt`/`gte`

## Testing Guidelines

### Unit Tests
- Each module should have a corresponding `*_test.go` file
- Test both success and error cases
- Use table-driven tests for multiple inputs

### Integration Tests
- Test complete programs in `examples/`
- Verify type checking catches errors
- Test effect propagation
- Ensure deterministic execution

### Property-Based Tests
AILANG supports inline property tests:
```ailang
property "sort preserves length" {
  forall(list: [int]) =>
    length(sort(list)) == length(list)
}
```

## Code Style Guidelines

1. **Go Code**:
   - Follow standard Go conventions
   - Use descriptive names
   - Add comments for complex logic
   - Keep functions under 50 lines

2. **AILANG Code**:
   - Use 2-space indentation
   - Prefer pure functions
   - Make effects explicit
   - Include tests with functions
   - Use type annotations when helpful

## Error Handling

### In Go Implementation
- Return explicit errors, don't panic
- Include position information in parse errors
- Provide helpful error messages with suggestions

### In AILANG
- Use Result type for fallible operations
- Propagate errors with `?` operator
- Provide structured error context

## Performance Considerations
- Parser uses Pratt parsing for efficient operator precedence
- Type inference should cache resolved types
- Lazy evaluation for better performance (future)
- String interning for identifiers

## Debug Commands
```bash
# Parse and print AST (when implemented)
ailang parse file.ail

# Type check without running
ailang check file.ail

# Show execution trace
ailang run --trace file.ail

# Export training data
ailang export-training
```

## Common Patterns

### Adding a Binary Operator
1. Add token in `token.go`
2. Add to lexer switch statement
3. Define precedence in parser
4. Add to `parseInfixExpression`
5. Add type rule
6. Implement evaluation

### Adding a Built-in Function
1. Define type signature
2. Add to prelude or appropriate module
3. Implement in Go
4. Add tests

## Resources
- Design doc: `design_docs/20250926/initial_design.md`
- Examples: `examples/` directory
- Go tests: `*_test.go` files

## Testing Policy
**ALWAYS remove out-of-date tests. No backward compatibility.**
- When architecture changes, delete old tests completely
- Don't maintain legacy test suites
- Write new tests for new implementations
- Keep test suite clean and current

## üö® CRITICAL: Linting & "Unused" Code Warnings

**‚ö†Ô∏è LESSON LEARNED: Never blindly delete "unused" functions without understanding WHY they're unused!**

### The Import System Disaster (September 2025)
In commit `eae08b6`, working import functions were deleted because linter said they were "unused".
**What actually happened:**
1. Function **calls** were renamed from `parseModuleDecl()` to `_parseModuleDecl()` (note underscore)
2. Function **definitions** kept original names (no underscore)
3. Calls were then **commented out**
4. Linter correctly said "hey, `parseModuleDecl` is never called!"
5. Functions were **blindly deleted**
6. Result: **Working import system completely broken** üí•

### Rules to Prevent This:
1. **NEVER delete functions just because linter says "unused"**
   - First understand WHY they're unused
   - Check git history - were they just commented out?
   - Search entire codebase for references (including comments)
   - Run `make test-imports` and `make test` BEFORE deleting anything

2. **If renaming function calls, rename definitions too**
   - Use IDE refactoring tools, not manual find/replace
   - If adding `_` prefix to mark as TODO, add to BOTH call and definition
   - Better: use TODO comments instead of renaming

3. **Test between each change**
   - Don't combine: rename + comment out + delete
   - Run tests after EACH step:
     - After rename ‚Üí `make test`
     - After commenting out ‚Üí `make test-imports`
     - After deleting ‚Üí `make test && make lint`

4. **When linter complains about unused code:**
   ```bash
   # Step 1: Check if it's really unused
   git log -p --all -S 'functionName' internal/
   grep -r "functionName" internal/

   # Step 2: Check recent changes
   git log --oneline internal/parser/parser.go | head -5
   git diff HEAD~1 internal/parser/parser.go | grep functionName

   # Step 3: If truly unused AND you know why, document it
   git commit -m "Remove unused parseOldFormat() - replaced by parseNewFormat() in commit abc123"
   ```

5. **Special warning for parser/module/import code**
   - These are **critical** for language functionality
   - If you break these, **nothing imports work**
   - Always run `make test-imports` before committing parser changes
   - Check that example files still work: `make verify-examples`

### Recovery Checklist (if this happens again):
1. Find last working commit: `git log --all --oneline | grep "import"`
2. Check what was deleted: `git diff working_commit broken_commit`
3. Restore deleted functions: `git show working_commit:file.go`
4. Test imports: `make test-imports`
5. Document in commit message what was broken and how it was fixed

### Development Commands

```bash
# Module runtime development
make test                          # Run all tests
go test ./internal/runtime/...     # Test module runtime
make verify-examples               # Verify examples work

# Effect runtime development
go test ./internal/effects/...     # Test effects
AILANG_FS_SANDBOX=/tmp make test  # Test with sandbox

# Pattern matching development
go test ./internal/elaborate/...   # Test exhaustiveness
go test ./internal/eval/...        # Test evaluation

# Full CI check
make ci                           # Run all checks locally
```

## Important Notes
1. The language is expression-based - everything returns a value
2. Effects are tracked in the type system - never ignore them
3. Pattern matching must be exhaustive
4. All imports must be explicit
5. Row polymorphism allows extensible records and effects
6. Session types ensure protocol correctness in channels

## Quick Debugging Checklist
- [ ] Check lexer is producing correct tokens
- [ ] Verify parser is building proper AST
- [ ] Ensure all keywords are in the keywords map
- [ ] Confirm precedence levels are correct
- [ ] Check that all AST nodes implement correct interfaces
- [ ] Verify type substitution is working correctly

## Contact & Support
This is an experimental language. For questions or issues:
- Check the design documents in @design_docs
- Look at example programs
- Run tests for expected behavior
- Refer to similar functional languages (Haskell, OCaml, F#)
---

# Guide: ai-prompt-guide.md

# AI Prompt Guide: Teaching AILANG to Language Models

**Purpose**: This document points to the canonical AILANG teaching prompt for AI models.

**KPI**: One of AILANG's key success metrics is **"teachability to AI"** - how easily can an LLM learn to write correct AILANG code from a single prompt?

---

## Canonical Prompt (v0.3.0)

**The official AILANG teaching prompt is maintained at**:

### üìñ [prompts/v0.3.0.md](../prompts/v0.3.0)

This prompt is:
- ‚úÖ **Validated through eval benchmarks** - Tested across GPT-4o-mini, Gemini 2.0, Claude Sonnet 4.5
- ‚úÖ **Up-to-date with v0.3.0 features** - Recursion, blocks, records, Clock/Net effects
- ‚úÖ **Versioned with SHA-256 hashing** - Reproducible eval results
- ‚úÖ **Actively maintained** - Updated as language evolves

---

## Quick Reference

**Current version**: v0.3.0 (Clock & Net Effects + Type System Fixes)

**What works in v0.3.0**:
- ‚úÖ Module execution with effects
- ‚úÖ Recursion (self-recursive and mutually-recursive)
- ‚úÖ Block expressions (`{ stmt1; stmt2; result }`)
- ‚úÖ Records (literals + field access)
- ‚úÖ Effects: IO, FS, Clock, Net
- ‚úÖ Type classes, ADTs, pattern matching
- ‚úÖ REPL with full type checking

**What doesn't work yet**:
- ‚ùå Record update syntax `{r | field: val}`
- ‚ùå Pattern guards (parsed but not evaluated)
- ‚ùå Error propagation operator `?`
- ‚ùå Deep let nesting (4+ levels)
- ‚ùå Typed quasiquotes
- ‚ùå CSP concurrency

**For complete details**, see [prompts/v0.3.0.md](../prompts/v0.3.0)

---

## Using the Prompt

### For AI Code Generation

When asking an AI model (Claude, GPT, Gemini) to write AILANG code, provide the full prompt from `prompts/v0.3.0.md`.

**Example usage**:
```
I need you to write AILANG code to solve this problem: [problem description]

First, read this AILANG syntax guide:
[paste contents of prompts/v0.3.0.md]

Now write the code.
```

### For Eval Benchmarks

The eval harness automatically loads the correct prompt version:

```yaml
# benchmarks/example.yml
id: example_task
languages: ["ailang", "python"]
prompt_files:
  ailang: "prompts/v0.3.0.md"
  python: "prompts/python.md"
task_prompt: |
  Write a program that [task description]
```

See [benchmarks/README.md](https://github.com/sunholo-data/ailang/tree/main/benchmarks) for details.

---

## Prompt Versioning

AILANG teaching prompts are versioned alongside language releases:

| Version | File | Features |
|---------|------|----------|
| v0.2.0 | `prompts/v0.2.0.md` | Module execution, effects (IO, FS) |
| v0.3.0 | `prompts/v0.3.0.md` | + Recursion, blocks, records, Clock/Net |
| v0.4.0 | `prompts/v0.4.0.md` | (Future: record updates, pattern guards) |

**Why versioning matters**:
- Reproducible eval results (hash verification)
- A/B testing of teaching strategies
- Track prompt evolution over time

---

## Eval Results

**Current success rates** (v0.3.0 prompt):
- **GPT-4o-mini**: 100% success on recursion/blocks/records benchmarks
- **Gemini 2.0 Flash**: 100% success on recursion/blocks/records benchmarks
- **Claude Sonnet 4.5**: 100% success on recursion/blocks/records benchmarks

**Token efficiency**:
- AILANG generates **8-15% fewer output tokens** than Python for equivalent tasks
- Prompt tokens are higher (teaching overhead), but will be reduced via fine-tuning

See [eval_results/](https://github.com/sunholo-data/ailang/tree/main/eval_results) for detailed reports.

---

## Contributing Improvements

If you find ways to improve the AILANG teaching prompt:

1. **Test your changes** with the eval harness:
   ```bash
   ailang eval --benchmark all --model gpt-4o-mini
   ```

2. **Measure impact**:
   ```bash
   tools/compare_prompts.sh old_version new_version
   ```

3. **Update the prompt** at `prompts/v0.3.0.md` (or create new version)

4. **Document changes** in `prompts/versions.json` (future enhancement)

---

## See Also

- **[CLAUDE.md](https://github.com/sunholo-data/ailang/blob/main/CLAUDE.md)** - Instructions for AI assistants working on AILANG development
- **[examples/](https://github.com/sunholo-data/ailang/tree/main/examples)** - Working AILANG code examples
- **[LIMITATIONS.md](./limitations)** - Current limitations and workarounds
- **[benchmarks/](https://github.com/sunholo-data/ailang/tree/main/benchmarks)** - Eval harness benchmark suite

---

*Last updated: October 5, 2025 for v0.3.0*

---

# Guide: benchmarking.md

# AI Usability Benchmarking Guide

## Overview

AILANG includes a built-in benchmarking system (M-EVAL) to empirically measure AI efficiency when generating code in AILANG vs Python. This helps validate AILANG's core value proposition: reducing AI token usage and improving code generation success rates.

**‚ö†Ô∏è Current Phase: Baseline Single-Shot (M-EVAL Phase 1)**

This guide covers **single-shot code generation** ‚Äî one prompt, one response, no iteration. This provides baseline data on:
- Initial token efficiency
- Syntax familiarity
- First-attempt success rate

**Multi-turn agentic evaluation** (M-EVAL2) is planned for v0.3.0 and will measure:
- Total effort across multiple iterations
- Debugging/fix cycles
- Real-world AI coding workflows

See [M-EVAL2 Design Doc](https://github.com/sunholo-data/ailang/blob/main/design_docs/20251002/m_eval2_agentic.md) for details.

## Quick Start

### Running a Benchmark (Mock Mode)

```bash
# Run FizzBuzz benchmark with mock AI agent
ailang eval --benchmark fizzbuzz --mock

# Run with both Python and AILANG
ailang eval --benchmark fizzbuzz --mock --langs python,ailang

# Generate report
make eval-report
```

### Running with Real AI Models

```bash
# Set API keys
export OPENAI_API_KEY="your-key-here"
# or
export ANTHROPIC_API_KEY="your-key-here"

# Run benchmark with GPT-4
ailang eval --benchmark fizzbuzz --model gpt-4 --seed 42

# Run with Claude
ailang eval --benchmark adt_option --model claude-3 --seed 42
```

## Available Benchmarks

| ID | Description | Difficulty | Focus Area |
|----|-------------|------------|------------|
| `fizzbuzz` | Classic FizzBuzz (1-100) | Easy | Control flow |
| `json_parse` | Parse JSON, filter, output | Medium | Data parsing |
| `pipeline` | stdin ‚Üí transform ‚Üí stdout | Medium | IO + lists |
| `cli_args` | Read file, process, sum | Hard | IO + FS |
| `adt_option` | Option/Maybe monad ops | Medium | Algebraic types |

## Command-Line Options

```bash
ailang eval [options]

Required:
  --benchmark <id>     Benchmark ID to run (e.g., fizzbuzz)

Optional:
  --langs <list>       Comma-separated languages (default: python,ailang)
  --model <name>       LLM model (default: gpt-4)
  --seed <n>           Random seed for reproducibility (default: 42)
  --output <dir>       Output directory (default: eval_results)
  --timeout <dur>      Execution timeout (default: 30s)
  --mock               Use mock AI agent (for testing)
```

## Understanding Results

### JSON Metrics

Each run produces a JSON file in `eval_results/` with:

```json
{
  "id": "fizzbuzz",
  "lang": "python",
  "model": "gpt-4",
  "seed": 42,
  "tokens": 290,
  "cost_usd": 0.0087,
  "compile_ok": true,
  "runtime_ok": true,
  "stdout_ok": true,
  "duration_ms": 120,
  "error_category": "none",
  "timestamp": "2025-10-02T12:34:56Z",
  "code": "..."
}
```

### Error Categories

- **`none`**: All checks passed
- **`compile_error`**: Syntax or type error
- **`runtime_error`**: Crashed during execution
- **`logic_error`**: Wrong output (compile/runtime OK)

### Reports

The `make eval-report` command generates:

**CSV** (`eval_results/summary.csv`):
```csv
benchmark,lang,model,seed,tokens,cost_usd,compile,runtime,stdout,duration_ms,error_type
fizzbuzz,python,gpt-4,42,290,0.0087,true,true,true,120,none
fizzbuzz,ailang,gpt-4,42,180,0.0054,true,true,true,80,none
```

**Markdown** (`eval_results/leaderboard.md`):
```markdown
# AILANG vs Python Benchmark Results

| Benchmark | Lang | Tokens | Cost | Compile | Run | Pass | Duration |
|-----------|------|--------|------|---------|-----|------|----------|
| fizzbuzz | python | 290 | $0.0087 | ‚úÖ | ‚úÖ | ‚úÖ | 0.12s |
| fizzbuzz | ailang | 180 | $0.0054 | ‚úÖ | ‚úÖ | ‚úÖ | 0.08s |

## Summary
- **Avg Token Reduction:** 37.9%
- **AILANG Success Rate:** 100% (1/1)
- **Python Success Rate:** 100% (1/1)
```

## Creating Custom Benchmarks

### 1. Create YAML Spec

Create `benchmarks/my_benchmark.yml`:

```yaml
id: my_benchmark
description: "My custom benchmark"
languages: ["python", "ailang"]
entrypoint: "main"
caps: ["IO"]
difficulty: "medium"
expected_gain: "high"
prompt: |
  Write a program in <LANG> that:
  1. Does something interesting
  2. Produces specific output

  Output only the code, no explanations.
expected_stdout: |
  expected
  output
  here
```

### 2. Run It

```bash
ailang eval --benchmark my_benchmark --mock
```

### 3. Validate Output

The benchmark passes if:
- Code compiles without errors
- Executes without crashing
- Output matches `expected_stdout` (exact string match after trimming whitespace)

## Reproducibility

### Deterministic Runs

Use `--seed` for reproducible results:

```bash
# Same seed ‚Üí same model output (when supported)
ailang eval --benchmark fizzbuzz --model gpt-4 --seed 123
ailang eval --benchmark fizzbuzz --model gpt-4 --seed 123
```

### Comparing Across Models

```bash
# Run same benchmark with different models
ailang eval --benchmark adt_option --model gpt-4 --seed 42
ailang eval --benchmark adt_option --model gpt-3.5-turbo --seed 42
ailang eval --benchmark adt_option --model claude-3 --seed 42

# Generate unified report
make eval-report
```

## Best Practices

### 1. Start with Mock Mode
```bash
# Verify benchmark works before using real API
ailang eval --benchmark my_benchmark --mock
```

### 2. Use Consistent Seeds
```bash
# Always use same seed for fair comparisons
ailang eval --benchmark fizzbuzz --model gpt-4 --seed 42
```

### 3. Test Both Languages
```bash
# Always compare AILANG vs Python
ailang eval --benchmark fizzbuzz --langs python,ailang
```

### 4. Clean Between Runs
```bash
# Avoid confusion from stale results
make eval-clean
```

## Interpreting Results

### Token Reduction

**Good**: 30-50% reduction
- Indicates AILANG's concise syntax is effective
- Lower API costs
- Faster generation

**Neutral**: 0-30% reduction
- May indicate benchmark doesn't stress AILANG's strengths
- Consider more ADT-heavy or effect-heavy tasks

**Bad**: Negative reduction (AILANG uses more tokens)
- Investigate: Is AILANG verbose for this task?
- May indicate need for language improvements

### Success Rate

**Target**: 80%+ for both languages

If AILANG < 80%:
- Check runtime errors (capability issues? stdlib gaps?)
- Review generated code for common patterns
- May indicate missing language features

If Python < 80%:
- Check if task is too hard for AI
- Simplify prompt or expected output

### Error Patterns

Monitor `error_category` distribution:
- High `compile_error`: AI doesn't understand syntax
- High `runtime_error`: Missing builtins or capabilities
- High `logic_error`: AI misunderstood requirements

## Troubleshooting

### "OPENAI_API_KEY environment variable not set"

```bash
export OPENAI_API_KEY="sk-..."
```

### "ailang binary not found"

```bash
make install
# Ensure $GOPATH/bin is in PATH
```

### "Benchmark not found"

```bash
ls benchmarks/
# Check that <id>.yml exists
```

### Mock code doesn't match expected output

This is expected! Mock code is for testing the harness, not for real evaluation. Use `--model gpt-4` for actual benchmarks.

## Makefile Targets

```bash
make eval            # Run FizzBuzz with mock agent
make eval-report     # Generate CSV + Markdown reports
make eval-clean      # Remove all eval_results files
```

## Future Extensions

**v0.3.0:**
- Net/Clock benchmarks (once effects land)
- Auto-retry on failure
- Cost tracking across vendors

**v0.4.0:**
- Concurrency benchmarks (spawn, channels)
- Performance metrics
- Memory usage tracking

**v0.5.0:**
- Web leaderboard
- Historical trending
- CI integration

## Contributing

When adding benchmarks:
1. Use neutral prompts (no language bias)
2. Test with `--mock` first
3. Verify expected output is achievable
4. Document difficulty and expected gain
5. Submit PR with results from at least 2 models

---

**Next Steps:**
- Run your first benchmark: `ailang eval --benchmark fizzbuzz --mock`
- Create a custom benchmark for your domain
- Share results to help guide AILANG development

---

# Guide: development.md

# AILANG Development Guide

## Development Workflow

### Building and Testing
```bash
make build          # Build the interpreter to bin/
make install        # Install ailang to system (makes it available everywhere)
make test           # Run all tests
make run FILE=...   # Run an AILANG file
make repl           # Start interactive REPL
```

### Code Quality & Coverage
```bash
make test-coverage-badge  # Quick coverage check (shows current %)
make test-coverage        # Run tests with coverage, generates HTML report
make lint                 # Run golangci-lint
make fmt                  # Format all Go code
make fmt-check            # Check if code is formatted
make vet                  # Run go vet
```

### Example Management
```bash
make verify-examples      # Verify all example files work/fail
make update-readme        # Update README with example status
make flag-broken          # Add warning headers to broken examples
```

### Development Helpers
```bash
make deps                 # Install all dependencies
make clean                # Remove build artifacts and coverage files
make ci                   # Run full CI verification locally
make help                 # Show all available make targets
```

### Auto-rebuild on File Changes
```bash
make watch-install        # Automatically rebuilds and installs on file changes
make quick-install        # Fast reinstall after changes
```

## Project Structure

```
ailang/
‚îú‚îÄ‚îÄ cmd/ailang/          # CLI entry point with REPL
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ repl/            # Interactive REPL
‚îÇ   ‚îú‚îÄ‚îÄ ast/             # Abstract syntax tree definitions
‚îÇ   ‚îú‚îÄ‚îÄ lexer/           # Tokenizer with full Unicode support
‚îÇ   ‚îú‚îÄ‚îÄ parser/          # Recursive descent parser
‚îÇ   ‚îú‚îÄ‚îÄ eval/            # Tree-walking interpreter
‚îÇ   ‚îú‚îÄ‚îÄ core/            # Core AST with ANF
‚îÇ   ‚îú‚îÄ‚îÄ elaborate/       # Surface to Core elaboration
‚îÇ   ‚îú‚îÄ‚îÄ typedast/        # Typed AST
‚îÇ   ‚îú‚îÄ‚îÄ types/           # Type system with HM inference
‚îÇ   ‚îú‚îÄ‚îÄ link/            # Dictionary linker
‚îÇ   ‚îú‚îÄ‚îÄ schema/          # Schema registry for AI features
‚îÇ   ‚îú‚îÄ‚îÄ errors/          # Error code taxonomy and JSON encoder
‚îÇ   ‚îú‚îÄ‚îÄ test/            # Test reporter
‚îÇ   ‚îú‚îÄ‚îÄ manifest/        # Example manifest system
‚îÇ   ‚îú‚îÄ‚îÄ module/          # Module loader and path resolver
‚îÇ   ‚îú‚îÄ‚îÄ effects/         # Effect system (TODO)
‚îÇ   ‚îú‚îÄ‚îÄ channels/        # CSP implementation (TODO)
‚îÇ   ‚îú‚îÄ‚îÄ session/         # Session types (TODO)
‚îÇ   ‚îî‚îÄ‚îÄ typeclass/       # Type classes (TODO)
‚îú‚îÄ‚îÄ testutil/            # Testing utilities
‚îú‚îÄ‚îÄ examples/            # Example AILANG programs
‚îú‚îÄ‚îÄ docs/                # Documentation
‚îú‚îÄ‚îÄ design_docs/         # Design documents
‚îî‚îÄ‚îÄ scripts/             # CI/CD scripts
```

## Adding a New Language Feature

1. **Update token definitions** in `internal/lexer/token.go`
2. **Modify lexer** in `internal/lexer/lexer.go` to recognize tokens
3. **Add AST nodes** in `internal/ast/ast.go`
4. **Update parser** in `internal/parser/parser.go`
5. **Add type rules** in `internal/types/`
6. **Implement evaluation** in `internal/eval/`
7. **Write tests** in corresponding `*_test.go` files
8. **Add examples** in `examples/`
9. **Update documentation**

## Adding a Binary Operator

1. Add token in `token.go`
2. Add to lexer switch statement
3. Define precedence in parser
4. Add to `parseInfixExpression`
5. Add type rule
6. Implement evaluation
7. Write tests

## Adding a Built-in Function

1. Define type signature
2. Add to prelude or appropriate module
3. Implement in Go
4. Add tests
5. Document in examples

## Testing Guidelines

### Running Tests
```bash
# Run all tests
make test

# Run tests with coverage
make test-coverage

# Run specific package tests
go test ./internal/lexer        # Tokenization
go test ./internal/parser       # Parsing  
go test ./internal/eval         # Evaluation
go test ./internal/types        # Type inference & defaulting
go test ./internal/elaborate    # Dictionary elaboration
go test ./cmd/test_integration  # End-to-end type class tests

# Run with verbose output
go test -v ./...
```

### Test Coverage Highlights
- ‚úÖ Complete type class resolution pipeline
- ‚úÖ Spec-aligned defaulting (neutral vs primary classes)
- ‚úÖ Dictionary-passing transformation
- ‚úÖ ANF verification and idempotency
- ‚úÖ Law-compliant Float instances
- ‚úÖ Superclass provision (Ord provides Eq)

### Writing Tests
- Each module should have a corresponding `*_test.go` file
- Test both success and error cases
- Use table-driven tests for multiple inputs
- Include integration tests for complete programs

## Code Style Guidelines

### Go Code
- Follow standard Go conventions
- Use descriptive names
- Add comments for complex logic
- Keep functions under 50 lines

### AILANG Code
- Use 2-space indentation
- Prefer pure functions
- Make effects explicit
- Include tests with functions
- Use type annotations when helpful

## Error Handling

### In Go Implementation
- Return explicit errors, don't panic
- Include position information in parse errors
- Provide helpful error messages with suggestions

### In AILANG
- Use Result type for fallible operations
- Propagate errors with `?` operator
- Provide structured error context

## Debug Commands

```bash
# Parse and print AST (when implemented)
ailang parse file.ail

# Type check without running
ailang check file.ail

# Show execution trace
ailang run --trace file.ail

# Export training data
ailang export-training
```

## Performance Considerations
- Parser uses Pratt parsing for efficient operator precedence
- Type inference should cache resolved types
- String interning for identifiers
- Lazy evaluation for better performance (future)

## Documentation Requirements

### Required Documentation Updates
Every change must update:

1. **README.md**
   - Implementation status when adding features
   - Current capabilities when functionality changes
   - Examples when fixed or added
   - Line counts and completion status

2. **CHANGELOG.md**
   - Follow semantic versioning
   - Group by: Added, Changed, Fixed, Deprecated, Removed
   - Include code locations
   - Note breaking changes
   - Add migration notes if needed

3. **Design Documentation**
   - Create design doc in `design_docs/planned/` before starting
   - Move to `design_docs/implemented/` after completing
   - Include implementation report with metrics

4. **Example Files**
   - Create `examples/feature_name.ail` for each new feature
   - Include comprehensive examples
   - Add comments explaining behavior
   - Test that examples actually work

## Testing Policy

**ALWAYS remove out-of-date tests. No backward compatibility.**
- When architecture changes, delete old tests completely
- Don't maintain legacy test suites  
- Write new tests for new implementations
- Keep test suite clean and current

## Quick Debugging Checklist
- [ ] Check lexer is producing correct tokens
- [ ] Verify parser is building proper AST
- [ ] Ensure all keywords are in the keywords map
- [ ] Confirm precedence levels are correct
- [ ] Check that all AST nodes implement correct interfaces
- [ ] Verify type substitution is working correctly
---

# Guide: getting-started.md

# Getting Started with AILANG

## Installation

### From GitHub Releases

Download pre-built binaries for your platform from the [latest release](https://github.com/sunholo-data/ailang/releases/latest):

```bash
# macOS (Apple Silicon)
curl -L https://github.com/sunholo-data/ailang/releases/latest/download/ailang-darwin-arm64.tar.gz | tar -xz
sudo mv ailang /usr/local/bin/

# macOS (Intel)  
curl -L https://github.com/sunholo-data/ailang/releases/latest/download/ailang-darwin-amd64.tar.gz | tar -xz
sudo mv ailang /usr/local/bin/

# Linux
curl -L https://github.com/sunholo-data/ailang/releases/latest/download/ailang-linux-amd64.tar.gz | tar -xz
sudo mv ailang /usr/local/bin/
```

### From Source

```bash
# Clone the repository
git clone https://github.com/sunholo/ailang.git
cd ailang

# Build and install
make install

# Verify installation
ailang --version
```

### Making ailang Accessible System-Wide

#### First-Time Setup
1. Install ailang to your Go bin directory:
   ```bash
   make install
   ```

2. Add Go bin to your PATH (if not already done):
   ```bash
   # For zsh (macOS default)
   echo 'export PATH="$HOME/go/bin:$PATH"' >> ~/.zshrc
   source ~/.zshrc
   
   # For bash
   echo 'export PATH="$HOME/go/bin:$PATH"' >> ~/.bashrc
   source ~/.bashrc
   ```

3. Test it works:
   ```bash
   ailang --version
   ```

#### Keeping ailang Up to Date

**Option 1: Manual Update**
```bash
make quick-install  # Fast reinstall
# OR
make install        # Full reinstall with version info
```

**Option 2: Auto-Update on File Changes**
```bash
make watch-install  # Automatically rebuilds and installs on file changes
```

**Option 3: Alias for Quick Updates**
```bash
# Add to ~/.zshrc or ~/.bashrc
alias ailang-update='cd /path/to/ailang && make quick-install && cd -'
```

## Quick Start

### Hello World (v0.3.0 Module Syntax)

```ailang
-- hello.ail
module examples/hello

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello, AILANG!")
}
```

Run it:
```bash
ailang run --caps IO --entry main hello.ail
```

**Note**: Flags must come BEFORE the filename when using `ailang run`.

### Working with Values

```ailang
-- values.ail
let name = "AILANG" in
let version = 0.0 in
print("Welcome to " ++ name ++ " v" ++ show(version))
```

### Lambda Expressions

```ailang
-- Lambda syntax with closures
let add = \x y. x + y in
let add5 = add(5) in  -- Partial application
print("Result: " ++ show(add5(3)))  -- Result: 8

-- Higher-order functions
let compose = \f g x. f(g(x)) in
let double = \x. x * 2 in
let inc = \x. x + 1 in
let doubleThenInc = compose(inc)(double) in
print("Composed: " ++ show(doubleThenInc(5)))  -- Composed: 11
```

### Using the REPL

Start the interactive REPL:
```bash
ailang repl
```

Try some expressions:
```ailang
Œª> 1 + 2
3 :: Int

Œª> "Hello " ++ "World"
Hello World :: String

Œª> let double = \x. x * 2 in double(21)
42 :: Int

Œª> :type \x. x + x
\x. x + x :: ‚àÄŒ±. Num Œ± ‚áí Œ± ‚Üí Œ±

Œª> :quit
```

## Working Examples (v0.3.0)

The following examples are confirmed to work with the current implementation:

**Recursion**:
- `examples/recursion_factorial.ail` - Recursive factorial function
- `examples/recursion_fibonacci.ail` - Fibonacci sequence
- `examples/recursion_quicksort.ail` - Quicksort implementation
- `examples/recursion_mutual.ail` - Mutual recursion (isEven/isOdd)

**Records**:
- `examples/micro_record_person.ail` - Record literals and field access
- `examples/test_record_subsumption.ail` - Record subsumption

**Effects**:
- `examples/test_effect_io.ail` - IO effect examples
- `examples/test_effect_fs.ail` - File system operations
- `examples/micro_clock_measure.ail` - Clock effect (time, sleep)
- `examples/micro_net_fetch.ail` - Net effect (HTTP GET)

**Pattern Matching & ADTs**:
- `examples/adt_simple.ail` - Algebraic data types
- `examples/adt_option.ail` - Option type with pattern matching
- `examples/guards_basic.ail` - Pattern guards

**Blocks**:
- `examples/micro_block_if.ail` - Block expressions with if
- `examples/micro_block_seq.ail` - Sequential blocks
- `examples/block_recursion.ail` - Recursion in blocks

See [examples/STATUS.md](https://github.com/sunholo-data/ailang/blob/main/examples/STATUS.md) for the complete list of 48+ working examples.

## Next Steps

- Learn the [language syntax](../reference/language-syntax.md)
- Explore [REPL commands](../reference/repl-commands.md)
- Check [implementation status](../reference/implementation-status.md)
- Read the [development guide](./development.md)
---

# Guide: module_execution.md

# Module Execution Guide

**AILANG v0.2.0** - Complete guide to executing modules with entrypoint functions

---

## Overview

AILANG v0.2.0 introduces the **Module Execution Runtime** (M-R1), enabling you to run modules with exported entrypoint functions. This guide covers basic usage, requirements, and common patterns.

## Quick Start

### Basic Usage

```bash
# Run a module with a main() function
ailang --entry main run examples/hello.ail

# Run with a different entrypoint
ailang --entry greet run examples/demo.ail

# Pass arguments via JSON
ailang --entry process --args-json '{"input": "data"}' run examples/processor.ail
```

### Minimal Example

```ailang
-- hello.ail
module examples/hello

export func main() -> () {
    _io_println("Hello from AILANG!")
}
```

Run with:
```bash
ailang --entry main run examples/hello.ail
# Output: Hello from AILANG!
```

---

## Module Structure

### Anatomy of an Executable Module

```ailang
-- my_module.ail
module examples/my_module
import stdlib/std/option (Some, None)

-- Private helper (not exported)
func helper(x: int) -> int {
    x * 2
}

-- Exported entrypoint (0 arguments)
export func main() -> int {
    helper(21)
}

-- Exported entrypoint (1 argument)
export func process(input: {value: int}) -> int {
    helper(input.value)
}
```

### Module Declaration

- **Required**: Every executable module must have a `module` declaration
- **Path matching**: Module path must match file path
  - File: `examples/demo.ail` ‚Üí Module: `module examples/demo`
  - File: `src/utils/math.ail` ‚Üí Module: `module src/utils/math`

---

## Entrypoint Functions

### Requirements

An entrypoint function must:
1. ‚úÖ Be **exported** from the module (`export func`)
2. ‚úÖ Be a **function** (not a value)
3. ‚úÖ Have **0 or 1 parameters** (v0.2.0 limitation)
4. ‚úÖ Be specified via `--entry <name>` flag

### Supported Arities

#### 0-Argument Functions

```ailang
export func main() -> int {
    42
}
```

Run with:
```bash
ailang --entry main run module.ail
# Output: 42
```

#### 1-Argument Functions

```ailang
export func greet(name: string) -> () {
    _io_println(name)
}
```

Run with:
```bash
ailang --entry greet --args-json '"World"' run module.ail
# Output: World
```

#### Record Parameters (Recommended Pattern)

```ailang
export func process(params: {input: string, count: int}) -> () {
    _io_println(params.input)
}
```

Run with:
```bash
ailang --entry process --args-json '{"input": "data", "count": 5}' run module.ail
# Output: data
```

### Multi-Argument Workaround

Functions with 2+ parameters are not directly supported. Wrap parameters in a record:

‚ùå **Not supported:**
```ailang
export func add(x: int, y: int) -> int {
    x + y
}
```

‚úÖ **Supported pattern:**
```ailang
export func add(params: {x: int, y: int}) -> int {
    params.x + params.y
}
```

Run with:
```bash
ailang --entry add --args-json '{"x": 10, "y": 32}' run module.ail
# Output: 42
```

---

## stdlib Functions

### IO Builtins

AILANG v0.2.0 provides three builtin IO functions:

#### `_io_print(s: string) -> ()`

Print a string without a newline.

```ailang
export func main() -> () {
    _io_print("Hello")
    _io_print(" ")
    _io_print("World")
}
```

Output: `Hello World`

#### `_io_println(s: string) -> ()`

Print a string with a newline.

```ailang
export func main() -> () {
    _io_println("Line 1")
    _io_println("Line 2")
}
```

Output:
```
Line 1
Line 2
```

#### `_io_readLine() -> string`

Read a line from stdin (blocking).

```ailang
export func main() -> () {
    _io_println("Enter your name:")
    let name = _io_readLine() in
    _io_println(name)
}
```

---

## Return Values and Output

### Printing Results

- **Non-Unit values**: Printed to stdout automatically
- **Unit values**: Silent (no output)

```ailang
-- Returns int, prints to stdout
export func compute() -> int {
    42
}

-- Returns unit, no output
export func greet() -> () {
    _io_println("Hello")
}
```

### Exit Codes

- **Success**: Exit code 0
- **Runtime error**: Exit code 1
- **Type error**: Exit code 1
- **Parse error**: Exit code 1

---

## Effects and Type Checking

### Effect Annotations (v0.2.0)

Effects are **type-checked** but **not enforced** at runtime in v0.2.0.

```ailang
-- Effect annotation required for IO operations
export func main() -> () ! {IO} {
    _io_println("Hello")
}
```

**Note**: Runtime effect enforcement (capability checks) is planned for v0.3.0 (M-R2).

### Pure Functions

Pure functions have no effect annotation:

```ailang
export pure func add(x: int, y: int) -> int {
    x + y
}
```

---

## Common Patterns

### Simple Script

```ailang
module scripts/hello

export func main() -> () {
    _io_println("Hello from AILANG!")
}
```

### CLI Tool with Arguments

```ailang
module tools/greeter

export func greet(config: {name: string, greeting: string}) -> () {
    _io_print(config.greeting)
    _io_print(" ")
    _io_println(config.name)
}
```

Usage:
```bash
ailang --entry greet --args-json '{"name":"Alice","greeting":"Hello"}' run tools/greeter.ail
```

### Interactive Program

```ailang
module apps/echo

export func main() -> () {
    _io_println("Enter text:")
    let input = _io_readLine() in
    _io_println(input)
}
```

---

## Error Handling

### Common Errors

#### Entrypoint Not Found

```
Error: entrypoint 'main' not found in module examples/demo
  Available exports: greet, process
```

**Solution**: Use `--entry <name>` with an exported function name.

#### Wrong Arity

```
Error: entrypoint 'process' takes 2 parameters. v0.2.0 supports 0 or 1.
  Suggestion: wrap as 'wrapper(p:{...}) -> ...' and pass --args-json
```

**Solution**: Wrap parameters in a record type.

#### Not a Function

```
Error: entrypoint 'config' is not a function (got RecordValue)
```

**Solution**: Only functions can be entrypoints. Values cannot be executed.

#### Module Path Mismatch

```
Error: module declaration 'hello' doesn't match canonical path 'examples/hello'
Suggestions:
  1. Rename module to: module examples/hello
  2. Move file to: hello.ail
```

**Solution**: Ensure module path matches file path.

---

## Known Limitations (v0.2.0)

### Supported ‚úÖ
- 0-argument and 1-argument entrypoints
- Builtin IO functions (`_io_print`, `_io_println`, `_io_readLine`)
- JSON argument parsing
- Module imports and dependency resolution
- Type checking with effects
- Pure functions

### Not Yet Supported ‚è≥
- **Multi-argument functions** (2+ parameters)
  - Workaround: Use record parameter
- **Effect enforcement** at runtime
  - Effects are type-checked only
  - Runtime capability checks coming in M-R2 (v0.3.0)
- **Pattern matching guards**
  - Planned for M-P4
- **Multi-statement function bodies**
  - Parser limitation, planned for future release

---

## Advanced Topics

### Module Dependencies

Modules can import other modules:

```ailang
-- math/utils.ail
module math/utils

export func double(x: int) -> int {
    x * 2
}
```

```ailang
-- app/main.ail
module app/main
import math/utils (double)

export func main() -> () {
    let result = double(21) in
    _io_println(show(result))
}
```

### Encapsulation

Only **exported** bindings are accessible from other modules:

```ailang
module lib/secret

-- Private (not accessible from imports)
func private_helper() -> int {
    42
}

-- Public (accessible via import)
export func public_api() -> int {
    private_helper()
}
```

---

## CLI Reference

### Flags

- `--entry <name>`: Specify entrypoint function (required for modules)
- `--args-json <json>`: Pass arguments as JSON (for 1-arg functions)
- `--runner <mode>`: Choose execution runner (`module` or `fallback`)
- `--no-print`: Suppress output (exit code only)

### Examples

```bash
# Basic execution
ailang --entry main run app.ail

# With arguments
ailang --entry process --args-json '{"data": [1,2,3]}' run app.ail

# Use fallback runner (pre-M-R1 execution)
ailang --runner fallback run app.ail

# Exit code only (no output)
ailang --entry main --no-print run app.ail
echo $?  # Check exit code
```

---

## Troubleshooting

### Module won't load

1. Check module path matches file path
2. Ensure all imports exist
3. Verify no circular imports
4. Check for syntax errors: `ailang check module.ail`

### Function won't execute

1. Ensure function is exported: `export func ...`
2. Check arity (0 or 1 parameters only)
3. Verify entrypoint name: `--entry <name>`
4. Check type errors: `ailang check module.ail`

### No output

- Functions returning `()` (Unit) produce no output
- Use `_io_println()` for explicit output
- Check stderr for errors: `ailang ... 2>&1 | grep Error`

---

## What's Next?

### v0.3.0 (M-R2: Effect Runtime)
- Runtime effect enforcement
- Capability-based security
- IO and FS capabilities
- Deny-by-default model

### v0.4.0 (Pattern Matching Polish)
- Guards in match expressions
- Exhaustiveness checking
- Decision tree optimization

### Future
- Multi-statement function bodies
- Async/await concurrency
- Quasiquotes (SQL, HTML, regex)
- Training data export

---

## Resources

- **Examples**: `examples/` directory
- **stdlib**: `stdlib/std/io.ail`, `stdlib/std/option.ail`
- **Design docs**: `design_docs/20251002/m_r1_module_execution.md`
- **CHANGELOG**: Track new features and breaking changes

---

**Version**: v0.2.0-rc1
**Last Updated**: October 2, 2025
**Status**: Complete

---

# Guide/evaluation: README.md

# AI Evaluation Framework (M-EVAL)

This directory contains documentation for the AILANG AI evaluation framework, which measures how well AI models can generate AILANG code compared to Python.

## Overview

M-EVAL is designed to empirically measure the "AI teachability" of AILANG - one of the project's key success metrics. It compares AI code generation efficiency for AILANG vs Python across multiple benchmarks and models.

## Documentation

- **[baseline-tests.md](baseline-tests.md)** - Complete guide for running your first baseline tests
- **[model-configuration.md](model-configuration.md)** - How to configure and manage AI models
- **[benchmarking.md](../benchmarking.md)** - Technical details of the benchmarking system

## Quick Start

### Prerequisites

You need at least one of these:

1. **Anthropic Claude** (recommended)
   ```bash
   export ANTHROPIC_API_KEY="sk-ant-..."
   ```

2. **OpenAI GPT**
   ```bash
   export OPENAI_API_KEY="sk-proj-..."
   ```

3. **Google Gemini** (via Vertex AI)
   ```bash
   gcloud auth application-default login
   gcloud config set project YOUR_PROJECT_ID
   ```

### Run Baseline Tests

```bash
# Quick test with single model
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5 --seed 42

# Full benchmark suite with all 3 models
./tools/run_benchmark_suite.sh

# Generate report
make eval-report
cat eval_results/leaderboard.md
```

## Available Models (October 2025)

All three models tested and working:

- ‚úÖ **Claude Sonnet 4.5** (Anthropic) - Recommended for coding
- ‚úÖ **GPT-5** (OpenAI) - Latest reasoning model
- ‚úÖ **Gemini 2.5 Pro** (Google Vertex AI) - Multimodal capabilities

See [model-configuration.md](model-configuration.md) for details.

## Benchmarks

Current benchmark suite (5 benchmarks):

1. **fizzbuzz** - Control flow (if/else, loops)
2. **json_parse** - Data parsing and filtering
3. **pipeline** - IO + list operations
4. **cli_args** - Command-line argument handling (IO + FS)
5. **adt_option** - Algebraic data types (Option monad)

## Results Location

After running benchmarks:

- **JSON**: `eval_results/*.json` - Full details for each run
- **CSV**: `eval_results/summary.csv` - Aggregated data
- **Markdown**: `eval_results/leaderboard.md` - Human-readable report

## Key Metrics

The framework tracks:

- **Token efficiency** - Tokens used per attempt
- **Success rate** - % of attempts that compile and run correctly
- **Error categories** - compile_error, runtime_error, logic_error
- **Cost** - Estimated API cost per run

## Target KPIs

- **AI Teachability**: 80%+ success rate on simple benchmarks
- **Token Efficiency**: AILANG should use ‚â§ Python tokens (concise syntax)
- **Error Quality**: Clear error categories to identify documentation gaps

## Next Steps

1. Run baseline tests following [baseline-tests.md](baseline-tests.md)
2. Analyze results to identify common AI errors
3. Update AI prompt guide based on findings
4. Re-run benchmarks to measure improvement

## Phase 2: M-EVAL2 (Future)

The current framework (M-EVAL Phase 1) does single-shot evaluation. Phase 2 will add:

- Multi-turn evaluation with error feedback
- Integration with Claude Code and Gemini CLI
- Retry loops with corrective hints
- Success rate tracking across iterations

See design docs for details.

---

**Last Updated**: October 2, 2025 (v0.2.0-rc1)
**Framework Status**: ‚úÖ Complete and operational
**Models Tested**: 3/3 working

---

# Guide/evaluation: baseline-tests.md

# Running Your First Baseline Tests

**Goal**: Generate empirical data on AI code generation efficiency for AILANG vs Python.

This will reveal where the AI struggles with AILANG syntax and help guide documentation improvements.

---

## Prerequisites

### 1. Build ailang

```bash
make build
# or
make install  # to make it globally available
```

### 2. Set Up API Access

The benchmark suite uses three models by default. You'll need at least one:

**Option A: Anthropic Claude (Recommended)**

1. Go to https://console.anthropic.com/
2. Create API key
3. Export it:

```bash
export ANTHROPIC_API_KEY="sk-ant-..."
```

**Option B: OpenAI GPT**

1. Go to https://platform.openai.com/api-keys
2. Create new key
3. Export it:

```bash
export OPENAI_API_KEY="sk-proj-..."
```

**Option C: Google Gemini (via Vertex AI)**

Requires Google Cloud SDK (`gcloud`):

```bash
# Install gcloud SDK if needed
# See: https://cloud.google.com/sdk/docs/install

# Authenticate
gcloud auth application-default login

# Set your GCP project
gcloud config set project YOUR_PROJECT_ID

# Enable Vertex AI API
gcloud services enable aiplatform.googleapis.com
```

**‚úÖ All Three Working**: As of October 2025, all three API implementations are tested and working:
- ‚úÖ Claude Sonnet 4.5 (Anthropic) - 230 tokens baseline
- ‚úÖ GPT-5 (OpenAI) - 319 tokens baseline
- ‚úÖ Gemini 2.5 Pro (Google Vertex AI) - 278 tokens baseline

### 3. Verify Setup

```bash
# Test with mock mode (no API key needed)
ailang eval --benchmark fizzbuzz --mock

# Should see:
# ‚Üí Running benchmark: Classic FizzBuzz...
# ‚úì Benchmark complete. Results saved to eval_results/
```

---

## Quick Baseline Run (5 minutes, ~$0.10)

Run all 5 benchmarks with both Python and AILANG:

### Option 1: Automated Script (Recommended)

```bash
# Run complete benchmark suite with all 3 models
./tools/run_benchmark_suite.sh
```

This will run all benchmarks with:
- GPT-5 (OpenAI)
- Claude Sonnet 4.5 (Anthropic)
- Gemini 2.5 Pro (Google)

### Option 2: Manual (Single Model)

```bash
# Clean previous results
make eval-clean

# Run all benchmarks with Claude Sonnet 4.5 (recommended)
for bench in fizzbuzz json_parse pipeline cli_args adt_option; do
    echo "Running $bench..."
    ailang eval --benchmark $bench --model claude-sonnet-4-5 --seed 42 --langs python,ailang
    sleep 5  # Rate limiting
done

# Generate report
make eval-report

# View results
cat eval_results/leaderboard.md
```

### Available Models

Check available models:
```bash
ailang eval --list-models
```

**Default models** (October 2025):
- `gpt5` - OpenAI GPT-5 (released August 2025)
- `claude-sonnet-4-5` - Anthropic Claude Sonnet 4.5 (released September 2025, **recommended**)
- `gemini-2-5-pro` - Google Gemini 2.5 Pro (released March 2025)

**Expected time**: ~3-5 minutes per model
**Expected cost**: ~$0.05-0.15 per model (full 5-benchmark suite)

---

## What to Look For

### 1. Token Efficiency

**Hypothesis**: AILANG should use fewer tokens per attempt (concise syntax)

```bash
# Check summary section of report
cat eval_results/leaderboard.md | grep "Avg Token Reduction"

# Expected: 20-40% reduction
```

### 2. Success Rate

**Hypothesis**: Python will have higher success rate (familiar to AI)

```bash
# Check success rates
cat eval_results/leaderboard.md | grep "Success Rate"

# Expected:
# - Python: 60-80% (AI knows Python well)
# - AILANG: 20-40% (unfamiliar syntax)
```

### 3. Error Patterns

**Key Question**: What AILANG syntax confuses the AI?

```bash
# Look at error categories
cat eval_results/summary.csv | grep ailang | grep -v "none"

# Common errors we expect:
# - compile_error: Missing "in" after "let"
# - compile_error: Wrong module import syntax
# - runtime_error: Unknown builtin functions
```

### 4. Per-Benchmark Analysis

```bash
# Check which benchmarks favor AILANG
cat eval_results/leaderboard.md

# Expected observations:
# - fizzbuzz: Similar tokens, Python succeeds more
# - adt_option: AILANG much fewer tokens, but may fail
# - json_parse: Python easier (stdlib familiarity)
```

---

## Detailed Analysis

### Extract AILANG Error Messages

```bash
# Look at the actual generated code
for file in eval_results/fizzbuzz_ailang_*.json; do
    echo "=== $file ==="
    jq -r '.stderr' "$file" | head -5
    echo ""
done
```

**What to look for:**
- Syntax errors ‚Üí document correct syntax
- Type errors ‚Üí provide examples
- Import errors ‚Üí clarify module system
- Runtime errors ‚Üí identify missing builtins

### Compare Token Usage

```bash
# Python avg
cat eval_results/summary.csv | grep python | awk -F, '{sum+=$5; count++} END {print "Python avg:", sum/count}'

# AILANG avg
cat eval_results/summary.csv | grep ailang | awk -F, '{sum+=$5; count++} END {print "AILANG avg:", sum/count}'
```

### Success by Category

```bash
# Python success rate
echo "Python success:"
cat eval_results/summary.csv | grep python | awk -F, '$9=="true" {s++} END {print s " / " NR " = " (s/NR*100) "%"}'

# AILANG success rate
echo "AILANG success:"
cat eval_results/summary.csv | grep ailang | awk -F, '$9=="true" {s++} END {print s " / " NR " = " (s/NR*100) "%"}'
```

---

## Using Results to Improve AILANG

### Step 1: Identify Top 3 Errors

```bash
# Extract error messages from failed AILANG runs
grep ailang eval_results/*.json | grep compile_ok | grep false -B5
```

**Example findings:**
```
Error 1: "Expected 'in' after let binding"
  ‚Üí Frequency: 3/5 benchmarks
  ‚Üí Fix: Add to docs, improve error message

Error 2: "Module 'option' not found"
  ‚Üí Frequency: 2/5 benchmarks
  ‚Üí Fix: Document stdlib imports

Error 3: "Unexpected token 'func'"
  ‚Üí Frequency: 1/5 benchmarks
  ‚Üí Fix: Clarify module vs non-module syntax
```

### Step 2: Update Documentation

Create or improve:
- `docs/syntax_guide.md` - Common syntax patterns
- `docs/stdlib_reference.md` - How to import/use stdlib
- `examples/ai_friendly.ail` - Examples for AI context

### Step 3: Improve Benchmark Prompts

Add AILANG-specific hints to prompts:

```yaml
# benchmarks/fizzbuzz_v2.yml
prompt: |
  Write a program in <LANG> that implements FizzBuzz.

  <LANG=AILANG> Syntax notes:
  - Let expressions: `let x = 5 in x * 2`
  - Print function: `print("text")`
  - Modulo operator: `%`
```

### Step 4: Re-run Benchmarks

```bash
# Run again with improved prompts
make eval-clean
# ... repeat baseline run ...

# Compare results
diff eval_results_v1/summary.csv eval_results_v2/summary.csv
```

**Expected improvement:**
- AILANG success rate: 20% ‚Üí 40% (+100%)
- Token increase (due to hints): +10-20%
- Net benefit: Higher success rate justifies slightly longer prompts

---

## Cost Management

### Minimize API Costs

**During development:**
```bash
# Use GPT-3.5 (10x cheaper)
ailang eval --benchmark fizzbuzz --model gpt-3.5-turbo --seed 42

# Or use mock mode (free)
ailang eval --benchmark fizzbuzz --mock
```

**For final results:**
```bash
# Use GPT-4 for quality
ailang eval --benchmark fizzbuzz --model gpt-4 --seed 42
```

### Track Spending

```bash
# Sum total cost
cat eval_results/summary.csv | awk -F, '{sum+=$6} END {print "Total cost: $" sum}'
```

---

## Sharing Results

### Generate Clean Report

```bash
# Create shareable markdown
make eval-report

# Copy to project root for visibility
cp eval_results/leaderboard.md BASELINE_RESULTS.md

# Add to git
git add BASELINE_RESULTS.md
git commit -m "Add baseline evaluation results"
```

### Publish Findings

Include in your next release notes:

```markdown
## Baseline Evaluation Results (v0.2.0)

We measured AI code generation efficiency for AILANG vs Python across 5 benchmarks:

**Key Findings:**
- ‚úÖ AILANG uses 35% fewer tokens per attempt
- ‚ö†Ô∏è AILANG has 50% lower first-attempt success rate
- üìä Most common error: Missing "in" after "let" (60% of failures)

**Next Steps:**
- Improve syntax documentation based on error patterns
- Add AILANG-specific prompts for Phase 2 (multi-turn evaluation)
- Target 80% success rate with enhanced context

Full results: [BASELINE_RESULTS.md](BASELINE_RESULTS.md)
```

---

## API Implementation Status

All three target models have been tested and verified working as of October 2, 2025:

### ‚úÖ Anthropic Claude Sonnet 4.5

```bash
./bin/ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5 --langs python --seed 42
```

**Result**:
- ‚úÖ API call successful
- Generated: 230 tokens
- Code compiled and ran successfully
- API endpoint: `https://api.anthropic.com/v1/messages`

### ‚úÖ OpenAI GPT-5

```bash
./bin/ailang eval --benchmark fizzbuzz --model gpt5 --langs python --seed 42
```

**Result**:
- ‚úÖ API call successful
- Generated: 319 tokens
- Code compiled and ran successfully
- API endpoint: `https://api.openai.com/v1/chat/completions`

### ‚úÖ Google Gemini 2.5 Pro (Vertex AI)

```bash
./bin/ailang eval --benchmark fizzbuzz --model gemini-2-5-pro --langs python --seed 42
```

**Result**:
- ‚úÖ API call successful (via Vertex AI)
- Generated: 278 tokens
- Code compiled and ran successfully
- API endpoint: `https://us-central1-aiplatform.googleapis.com/v1/projects/{PROJECT}/locations/us-central1/publishers/google/models/gemini-2.5-pro:generateContent`
- Authentication: OAuth via `gcloud auth application-default print-access-token`

**Implementation Notes**:
- All three use direct HTTP calls (no SDKs) for minimal dependencies
- Anthropic & OpenAI use API keys from environment variables
- Google uses Vertex AI with gcloud Application Default Credentials (ADC)
- Token counting works correctly for all three providers
- All responses successfully extract code from markdown fences

---

## Troubleshooting

### "rate limit exceeded"

OpenAI has rate limits. Wait a minute between runs:

```bash
for bench in fizzbuzz json_parse pipeline cli_args adt_option; do
    ailang eval --benchmark $bench --model gpt-4 --seed 42
    sleep 60  # Wait 1 minute
done
```

### "Model not found"

Check available models:

```bash
# OpenAI models
curl https://api.openai.com/v1/models \
  -H "Authorization: Bearer $OPENAI_API_KEY" | jq '.data[].id'

# Use full model ID
ailang eval --benchmark fizzbuzz --model gpt-4-turbo-2024-04-09
```

### Results look wrong

Verify with mock mode first:

```bash
# Run mock mode
ailang eval --benchmark fizzbuzz --mock --langs python,ailang

# Check that harness works
cat eval_results/*.json | jq .
```

---

## Next Steps

After baseline tests:

1. ‚úÖ Analyze error patterns
2. ‚úÖ Document common issues
3. ‚úÖ Improve AILANG documentation
4. ‚úÖ Update benchmark prompts
5. ‚úÖ Re-run with improved context
6. ‚úÖ Compare v1 vs v2 results
7. üîÆ Prepare for M-EVAL2 (multi-turn evaluation)

---

**Happy testing!** üöÄ

Your baseline results will directly inform AILANG's development priorities and documentation improvements.

---

# Guide/evaluation: eval-loop.md

# M-EVAL-LOOP: Self-Improving AI Feedback Loop

The M-EVAL-LOOP system transforms the AILANG eval harness from passive benchmarking into a **self-improving feedback loop** that teaches AI models and validates language improvements.

## Overview

**Status**: ‚úÖ COMPLETE (v0.3.0-alpha5)

The eval loop closes the development cycle:
1. **Eval** ‚Üí Run benchmarks, collect failures
2. **Analyze** ‚Üí Generate design docs from patterns
3. **Iterate** ‚Üí Review with multiple AI vendors
4. **Implement** ‚Üí Fix language/compiler/stdlib
5. **Validate** ‚Üí Re-run benchmarks, measure improvement
6. **Track** ‚Üí Update performance tables

## Key Features

### 1. AI Self-Repair (Milestone 1)

AI models can retry failed code generation with error-specific guidance:

```bash
# Enable self-repair (single-shot retry)
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5 --self-repair
```

**Error Taxonomy**: 6 error codes with repair hints
- `PAR_001`: Parse errors (missing semicolons)
- `TC_REC_001`: Record field not found
- `TC_INT_001`: Modulo on floats
- `EQ_001`: Wrong Eq dictionary
- `CAP_001`: Missing capability
- `MOD_001`: Undefined module/entrypoint

**Metrics Tracked**:
- `first_attempt_ok`: Did it work without error feedback?
- `repair_used`: Did self-repair trigger?
- `repair_ok`: Did self-repair succeed?
- `err_code`: Which error pattern matched?

### 2. Prompt A/B Testing (Milestone 2)

Compare different teaching strategies across AI models:

```bash
# Use specific prompt version
ailang eval --benchmark fizzbuzz --prompt-version v0.3.0-hints

# A/B comparison (full automation)
make eval-prompt-ab A=v0.3.0-baseline B=v0.3.0-hints

# List available versions
make eval-prompt-list
```

**Prompt Versions**:
- `v0.3.0-baseline`: Original teaching prompt (3,674 tokens)
- `v0.3.0-hints`: Enhanced with error pattern warnings (4,538 tokens)

**Hash Verification**: SHA256 prevents accidental modification mid-experiment

### 3. Fix Validation (Milestone 3)

Prove fixes work before committing:

```bash
# Store baseline
make eval-baseline

# Make code changes...
vim internal/eval/builtins.go

# Validate fix
make eval-validate-fix BENCH=float_eq
# Output: "‚úì FIX VALIDATED: Benchmark now passing!"

# Compare all changes
make eval-diff BASELINE=baselines/v0.3.0 NEW=after_fix
```

### 4. AI-Friendly Formats

Export results in formats optimized for AI analysis:

```bash
# JSONL (one JSON per line)
make eval-summary DIR=eval_results/baseline OUTPUT=summary.jsonl

# Performance matrix
make eval-matrix DIR=eval_results/baseline VERSION=v0.3.0-alpha5
```

**Query with jq**:
```bash
# Count successes
jq -s 'map(select(.stdout_ok == true)) | length' summary.jsonl

# Error distribution
jq -s 'group_by(.err_code) | map({code: .[0].err_code, count: length})' summary.jsonl

# Repair effectiveness
jq -s 'map(select(.repair_used == true)) | {total: length, success: map(select(.repair_ok == true)) | length}' summary.jsonl
```

## Complete Workflow

### Step 1: Store Baseline

Before making changes, store current results:

```bash
make eval-baseline
```

This runs all benchmarks and stores:
- Individual result JSON files
- Performance matrix with aggregates
- Baseline metadata with git commit

### Step 2: A/B Test Prompts (Optional)

Test if a new teaching strategy helps:

```bash
make eval-prompt-ab A=v0.3.0-baseline B=v0.3.0-hints
```

Output shows success rate comparison:
```
0-shot Success    85%           92%          +7%
Final Success     90%           95%          +5%
```

### Step 3: Implement Fix

Make code changes to fix identified issues:

```bash
vim internal/eval/builtins.go
make test
```

### Step 4: Validate Fix

Prove the fix works for specific benchmarks:

```bash
make eval-validate-fix BENCH=float_eq
```

**Possible outcomes**:
- ‚úÖ **FIX VALIDATED**: Was failing, now passing
- ‚úó **REGRESSION**: Was passing, now failing
- ‚ö† **STILL FAILING**: Remains broken
- ‚Ñπ **NO CHANGE**: Was already passing

### Step 5: Compare All Changes

See what else changed:

```bash
make eval-diff BASELINE=baselines/v0.3.0 NEW=after_fix
```

Output shows:
- ‚úì Fixed benchmarks (3)
- ‚úó Broken benchmarks (0)
- ‚Üí Still passing (45)
- ‚ö† Still failing (2)
- Success rate: 85% ‚Üí 95% (+10%)

### Step 6: Update Performance Matrix

Track progress over time:

```bash
make eval-matrix DIR=after_fix VERSION=v0.3.0-alpha5
```

Generates `performance_tables/v0.3.0-alpha5.json` with:
- Aggregates by model, benchmark, error code
- 0-shot vs 1-shot success rates
- Token costs and efficiency
- Historical tracking

## Makefile Targets

### Self-Repair

```bash
make eval                    # Run single benchmark (mock)
make eval-suite              # Full suite, all models
make eval-suite-repair       # Full suite with self-repair
```

### Prompt Versioning

```bash
make eval-prompt-list        # Show available versions
make eval-prompt-hash        # Compute SHA256 hashes
make eval-prompt-ab A=X B=Y  # A/B comparison
```

### Validation Workflow

```bash
make eval-baseline                    # Store baseline
make eval-validate-fix BENCH=<id>    # Validate fix
make eval-diff BASELINE=X NEW=Y      # Compare runs
make eval-summary DIR=<dir>          # Generate JSONL
make eval-matrix DIR=<dir> VERSION=X # Generate matrix
```

### Analysis

```bash
make eval-analyze            # Generate design docs from failures
make eval-analyze-fresh      # Force new docs (no dedup)
make eval-to-design          # Full workflow: eval ‚Üí analyze
```

## Performance Metrics

The system tracks:

**0-shot metrics** (no error feedback):
- First attempt success rate
- Error distribution
- Token efficiency

**1-shot metrics** (with self-repair):
- Final success rate after repair
- Repair trigger rate
- Repair success rate

**Cost metrics**:
- Input/output tokens
- USD cost per benchmark
- Cost efficiency by model

**Time metrics**:
- Compilation time
- Execution time
- Total duration

## AI Agent Integration

### For Research

```bash
# Export for analysis
make eval-summary DIR=results OUTPUT=summary.jsonl

# Load into your tool
import jsonlines
with jsonlines.open('summary.jsonl') as reader:
    results = list(reader)

# Analyze
errors = [r for r in results if not r['stdout_ok']]
print(f"Error distribution: {Counter(e['err_code'] for e in errors)}")
```

### For Automation

```bash
# CI/CD integration
make eval-validate-fix BENCH=float_eq
EXIT_CODE=$?

if [ $EXIT_CODE -eq 0 ]; then
  echo "Fix validated, safe to merge"
else
  echo "Fix failed or caused regression"
  exit 1
fi
```

### For Historical Tracking

```bash
# Store matrix for each version
make eval-matrix DIR=results VERSION=v0.3.0-alpha5

# Compare versions
jq -s '[.[] | {version: .version, success: .aggregates."final_success"}]' \
  performance_tables/*.json
```

## Best Practices

1. **Store baseline before every fix** - Enables validation
2. **Run self-repair by default** - Measures teachability
3. **A/B test prompt changes** - Isolate what works
4. **Update performance tables after validation** - Track progress
5. **Review uncategorized errors monthly** - Expand taxonomy
6. **Keep benchmarks up-to-date** - Add new test cases

## Implementation Details

- **Total LOC**: ~2,960 (implementation + tests + scripts)
- **Development Time**: ~7 hours (3 milestones)
- **Files Modified**: 25+
- **Test Coverage**: 100% for new code
- **All tests passing**: ‚úÖ

## Automated Fix Implementation (NEW! üöÄ)

**Milestone 4** adds fully automated fix implementation:

```bash
# Dry-run (preview what would be done)
make eval-auto-improve

# Actually implement the fix
make eval-auto-improve-apply
```

**How it works:**
1. Runs benchmarks (or uses recent results)
2. Analyzes failures ‚Üí generates design docs
3. **AI agent reads design doc and implements fix** ‚¨Ö NEW!
4. Runs tests to verify
5. Re-runs affected benchmarks
6. Shows before/after comparison

**Example workflow:**
```bash
# Preview
make eval-auto-improve
# Shows: Design doc preview, what would be done

# Apply
make eval-auto-improve-apply
# AI agent implements the fix automatically

# Validate
make eval-validate-fix BENCH=<benchmark-id>
make eval-diff
```

**Agent Integration:**
- Uses Claude Code Task agent (general-purpose)
- Pluggable design for future CLI/API agents
- Task file generated: `.eval_auto_improve_task.md`

**Safety:**
- Dry-run by default
- Tests must pass before accepting fix
- Human review before commit
- Automatic rollback on test failures

## Next Steps

Future enhancements could include:

- **Multi-agent coordination**: Multiple agents working on related fixes
- **Multi-shot repair**: Allow more than one retry
- **Error pattern learning**: Auto-generate repair hints from manual fixes
- **Cross-model comparison**: Compare GPT vs Claude vs Gemini on same benchmarks
- **Prompt evolution tracking**: Automated prompt optimization
- **Performance dashboards**: Web UI for historical trends

## References

- [Design Document](https://github.com/sunholo-data/ailang/blob/dev/design_docs/planned/M-EVAL-LOOP_self_improving_feedback.md)
- [CHANGELOG Entry](https://github.com/sunholo-data/ailang/blob/dev/CHANGELOG.md)
- [Evaluation Guide](./README.md)
- [Benchmarking Guide](../benchmarking.md)

---

# Guide/evaluation: model-configuration.md

# Model Configuration Guide

## Overview

AILANG evaluation system supports the latest AI models from OpenAI, Anthropic, and Google. Model configurations are centralized in `benchmarks/models.yml` for easy updates when new versions are released.

---

## Current Models (October 2025)

### Default: Claude Sonnet 4.5 (Anthropic)

**Why Claude Sonnet 4.5 is the default:**
- Released September 29, 2025
- **Best coding model in the world** (Anthropic's claim)
- Optimized for complex agents and autonomous coding
- 1M token context window
- Competitive pricing: $3/$15 per million tokens

### Recommended Benchmark Suite

For comprehensive evaluation, run all three:

1. **GPT-5** (OpenAI)
   - Released: August 7, 2025
   - API Name: `gpt-5`
   - Strength: Reasoning, general intelligence
   - Pricing: ~$30/$60 per million (estimated)

2. **Claude Sonnet 4.5** (Anthropic) ‚≠ê **Default**
   - Released: September 29, 2025
   - API Name: `claude-sonnet-4-5-20250929`
   - Strength: Coding, agents, computer use
   - Pricing: $3/$15 per million

3. **Gemini 2.5 Pro** (Google)
   - Released: March 2025
   - API Name: `gemini-2.5-pro`
   - Strength: Math, science, reasoning
   - Pricing: ~$1/$2 per million (estimated)

---

## Quick Start

### 1. Set API Keys

```bash
# OpenAI
export OPENAI_API_KEY="sk-..."

# Anthropic (recommended)
export ANTHROPIC_API_KEY="sk-ant-..."

# Google
export GOOGLE_API_KEY="..."
```

### 2. List Available Models

```bash
make eval-models
# or
ailang eval --list-models
```

### 3. Run Single Benchmark

```bash
# With default model (Claude Sonnet 4.5)
ailang eval --benchmark fizzbuzz

# With specific model
ailang eval --benchmark fizzbuzz --model gpt5
ailang eval --benchmark fizzbuzz --model gemini-2-5-pro
```

### 4. Run Full Suite (All Models)

```bash
make eval-suite
# or
./tools/run_benchmark_suite.sh
```

This runs all 5 benchmarks (fizzbuzz, json_parse, pipeline, cli_args, adt_option) with all 3 models.

**Expected cost**: ~$0.15-0.30 total (5 benchmarks √ó 3 models √ó 2 languages)
**Expected time**: ~15-20 minutes (with rate limiting)

---

## Configuration File

Models are configured in `benchmarks/models.yml`:

```yaml
models:
  claude-sonnet-4-5:
    api_name: "claude-sonnet-4-5-20250929"
    provider: "anthropic"
    description: "Claude Sonnet 4.5 - best for coding"
    env_var: "ANTHROPIC_API_KEY"
    pricing:
      input_per_1k: 0.003
      output_per_1k: 0.015
```

### When to Update

**Update `benchmarks/models.yml` when:**
- New model versions release (e.g., GPT-6, Claude 5)
- Pricing changes
- API names change (e.g., `gpt-5-2026-01-01`)

**How to update:**
1. Edit `benchmarks/models.yml`
2. Add new model entry
3. Update `default:` if needed
4. Update `benchmark_suite:` list
5. Test with `ailang eval --list-models`

---

## Model Selection Strategy

### For Development/Testing
```bash
# Use GPT-5 mini (fastest, cheapest)
ailang eval --benchmark fizzbuzz --model gpt5-mini --mock
```

### For Baseline Data
```bash
# Use Claude Sonnet 4.5 (best balance)
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5 --seed 42
```

### For Comprehensive Comparison
```bash
# Run all 3 models
make eval-suite
```

### For Budget-Conscious Testing
```bash
# Start with mock mode (free)
ailang eval --benchmark fizzbuzz --mock

# Then run one model
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5
```

---

## Pricing Comparison (October 2025)

| Model | Input (per 1K) | Output (per 1K) | Full Suite Cost |
|-------|----------------|-----------------|-----------------|
| GPT-5 | $0.03 | $0.06 | ~$0.15 |
| GPT-5 mini | $0.01 | $0.02 | ~$0.05 |
| Claude Sonnet 4.5 | $0.003 | $0.015 | ~$0.03 |
| Gemini 2.5 Pro | $0.001 | $0.002 | ~$0.01 |

**Full suite (all 3 models)**: ~$0.20-0.30

*Note: Prices are estimates. Check official documentation for current rates.*

---

## Model Capabilities

### GPT-5 (OpenAI)
- ‚úÖ Reasoning with "minimal" mode
- ‚úÖ Verbosity parameter
- ‚úÖ Code generation
- ‚úÖ Broad knowledge
- ‚ö†Ô∏è Most expensive

**Best for**: General-purpose benchmarks, reasoning tasks

### Claude Sonnet 4.5 (Anthropic)
- ‚úÖ **Best coding model**
- ‚úÖ Computer use (CLI/tool use)
- ‚úÖ 30-hour autonomous operation
- ‚úÖ 1M context (2M coming)
- ‚úÖ Great price/performance

**Best for**: Coding benchmarks (‚≠ê **recommended**)

### Gemini 2.5 Pro (Google)
- ‚úÖ Thinking/reasoning mode
- ‚úÖ Strong in math/science
- ‚úÖ 1M context (2M coming)
- ‚úÖ Cheapest option
- ‚ö†Ô∏è Less proven in coding

**Best for**: Budget testing, math/science benchmarks

---

## Troubleshooting

### "Model not found"

```bash
# Check if model is in config
make eval-models

# If not, add to benchmarks/models.yml
```

### "API key not set"

```bash
# Check which key is needed
ailang eval --list-models

# Set the appropriate key
export ANTHROPIC_API_KEY="sk-ant-..."
```

### "Rate limit exceeded"

```bash
# Add delays between runs (done automatically in suite script)
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5
sleep 10
ailang eval --benchmark json_parse --model claude-sonnet-4-5
```

### Cost tracking

```bash
# Check cost in results
cat eval_results/summary.csv | awk -F, '{sum+=$6} END {print "Total: $" sum}'
```

---

## Adding New Models

When new models release, update `benchmarks/models.yml`:

```yaml
# Example: GPT-6 release
gpt6:
  api_name: "gpt-6-2026-01-01"
  provider: "openai"
  description: "GPT-6 - next generation"
  env_var: "OPENAI_API_KEY"
  pricing:
    input_per_1k: 0.05
    output_per_1k: 0.10
  notes: |
    Released January 2026.
    Improved reasoning and coding.
```

Then rebuild and test:
```bash
make build
ailang eval --list-models
ailang eval --benchmark fizzbuzz --model gpt6 --seed 42
```

---

## Best Practices

1. **Always use `--seed 42`** for reproducible results
2. **Start with `--mock`** to test harness before using API credits
3. **Use `eval-suite`** for comprehensive model comparison
4. **Check `--list-models`** to see current configuration
5. **Update `models.yml`** when new versions release
6. **Track costs** with `summary.csv`

---

## Quick Commands Reference

```bash
# List models
make eval-models
ailang eval --list-models

# Single benchmark
ailang eval --benchmark fizzbuzz --model claude-sonnet-4-5

# Full suite (all models, all benchmarks)
make eval-suite

# Generate report
make eval-report

# Clean results
make eval-clean
```

---

**Last Updated**: October 2, 2025
**Default Model**: Claude Sonnet 4.5 (Anthropic)
**Configuration**: [benchmarks/models.yml](benchmarks/models.yml)

---

# AI Prompt: python.md

# Python Programming Guidelines

You are an expert Python programmer. Write clean, idiomatic Python 3 code.

## Guidelines

- Use Python 3 syntax
- Follow PEP 8 style guidelines
- Write readable, maintainable code
- Use type hints when helpful
- Prefer built-in functions and standard library

## Code Structure

- Use functions to organize code
- Include a `main()` function when appropriate
- Use `if __name__ == "__main__":` for script entry points

## Common Patterns

- Use list comprehensions for simple transformations
- Use f-strings for string formatting
- Use context managers (`with`) for resource management
- Prefer `pathlib` for file paths
- Use exceptions for error handling

## Output

- Output only the code, no explanations
- Do not include markdown code fences unless specifically requested
- Ensure code is complete and runnable

---

# AI Prompt: v0.2.0.md

# AILANG AI Teaching Prompt (v0.2.0-rc1)

**CRITICAL: You MUST write code in AILANG syntax. This is NOT Python, NOT Rust, NOT JavaScript.**

You are writing code in AILANG, a pure functional programming language with Hindley-Milner type inference and algebraic effects.

**IMPORTANT SYNTAX RULES:**
- Use `func` NOT `fn`, `function`, or `def`
- Use `type Name[a] = Constructor(a) | Constructor2` NOT `type Name { }` or `enum`
- NO namespace syntax (`::`), just use constructor names directly
- NO semicolons at end of statements in blocks (only between let bindings)
- Pattern matching uses `=>` NOT `:` or `->`
- NO `for`, `while`, `var`, `const`, `let mut`, or any imperative constructs

## Current Version: v0.2.0-rc1 (Module Execution + Effects)

**‚úÖ WHAT WORKS:**
- ‚úÖ **Module declarations** - `module path/to/module`
- ‚úÖ **Function declarations** - `export func name(params) -> Type { body }`
- ‚úÖ **Import statements** - `import std/io (println)`
- ‚úÖ **Pattern matching** - Constructors, tuples, lists, wildcards
- ‚úÖ **Effect system** - `! {IO, FS}` for side effects
- ‚úÖ **ADTs** - Algebraic data types: `type Option[a] = Some(a) | None`

**‚ö†Ô∏è LIMITATIONS:**
- ‚ö†Ô∏è NO `for`/`while` loops - use recursion
- ‚ö†Ô∏è NO `var` - everything is immutable
- ‚ö†Ô∏è NO pattern guards in match (yet)
- ‚ö†Ô∏è Let expressions limited to 3 nesting levels

## Module Structure

Every AILANG program must be a module with exported functions:

```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello, World!")
}
```

**IMPORTANT**: Always use `module benchmark/solution` as the module name for benchmark programs.

## Functions

```ailang
-- Simple pure function
export func add(x: int, y: int) -> int {
  x + y
}

-- Function with effects (IO, FS)
export func greet(name: string) -> () ! {IO} {
  println("Hello, " ++ name)
}

-- Generic function
export func identity[a](x: a) -> a {
  x
}

-- Multi-statement body (use semicolons)
export func compute() -> int {
  let x = 10;
  let y = 20;
  x + y
}
```

## Algebraic Data Types (ADTs)

**‚úÖ CORRECT AILANG SYNTAX:**
```ailang
type Option[a] = Some(a) | None
type Result[a, e] = Ok(a) | Err(e)
type List[a] = Cons(a, List[a]) | Nil

export func getOrElse[a](opt: Option[a], default: a) -> a {
  match opt {
    Some(x) => x,
    None => default
  }
}
```

**‚ùå WRONG - This is Rust/other languages, NOT AILANG:**
```rust
type Option {        // ‚ùå Wrong - no { } braces
  Some(value)        // ‚ùå Wrong - not AILANG syntax
  None
}

Option::Some(42)     // ‚ùå Wrong - AILANG has no :: operator
fn divide(a, b) { }  // ‚ùå Wrong - use 'func' not 'fn'
```

**‚úÖ CORRECT - Use constructors directly:**
```ailang
Some(42)             // ‚úÖ Correct - no namespace needed
None                 // ‚úÖ Correct
```

## Available Imports

**std/io** - IO operations (requires `! {IO}` effect)
```ailang
import std/io (println, print, readLine)

export func main() -> () ! {IO} {
  println("text")
}
```

**std/fs** - File operations (requires `! {FS}` effect)
```ailang
import std/fs (readFile, writeFile, exists)

export func readData() -> string ! {FS} {
  readFile("data.txt")
}
```

**std/option** - Option type
```ailang
import std/option (Option, Some, None)
```

## Recursion (instead of loops)

```ailang
export func factorial(n: int) -> int {
  if n <= 1
  then 1
  else n * factorial(n - 1)
}

export func sum(xs: [int]) -> int {
  match xs {
    [] => 0,
    _ => head(xs) + sum(tail(xs))
  }
}
```

## Common Mistakes to Avoid

‚ùå **Don't use for/while loops:**
```ailang
for i in [1, 2, 3] { println(i) }  -- ‚ùå NOT supported
```

‚úÖ **Use recursion or pattern matching:**
```ailang
export func printAll(xs: [int]) -> () ! {IO} {
  match xs {
    [] => (),
    _ => {
      println(show(head(xs)));
      printAll(tail(xs))
    }
  }
}
```

‚ùå **Don't use mutable variables:**
```ailang
var x = 5
x = x + 1  -- ‚ùå NOT supported
```

‚úÖ **Use let bindings:**
```ailang
let x = 5;
let y = x + 1;
y
```

‚ùå **Don't forget module and export:**
```ailang
func main() {  -- ‚ùå Missing 'module' declaration and 'export'
  println("hello")
}
```

‚úÖ **Always use module and export:**
```ailang
module examples/hello
import std/io (println)

export func main() -> () ! {IO} {
  println("hello")
}
```

## Complete Working Examples

### Example 1: Safe Division with Option
```ailang
module benchmark/solution

import std/io (println)

type Option[a] = Some(a) | None

export func safeDivide(a: float, b: float) -> Option[float] {
  if b == 0.0
  then None
  else Some(a / b)
}

export func printResult(result: Option[float]) -> () ! {IO} {
  match result {
    Some(v) => println("Result: " ++ show(v)),
    None => println("Error: Division by zero")
  }
}

export func main() -> () ! {IO} {
  let r1 = safeDivide(10.0, 2.0);
  printResult(r1);
  let r2 = safeDivide(10.0, 0.0);
  printResult(r2)
}
```

### Example 2: Recursive Loop (FizzBuzz pattern)
```ailang
module benchmark/solution

import std/io (println)

export func loop(start: int, end: int, action: int -> () ! {IO}) -> () ! {IO} {
  if start > end
  then ()
  else {
    action(start);
    loop(start + 1, end, action)
  }
}

export func main() -> () ! {IO} {
  loop(1, 10, \i. println(show(i)))
}
```

### Example 3: List Processing (NO for loops!)
```ailang
module benchmark/solution

import std/io (println)

export func printEach(xs: [int]) -> () ! {IO} {
  match xs {
    [] => (),
    _ => {
      println(show(head(xs)));
      printEach(tail(xs))
    }
  }
}

export func main() -> () ! {IO} {
  printEach([1, 2, 3, 4, 5])
}
```

## Summary

**Structure:**
1. Start with `module benchmark/solution` (REQUIRED for benchmarks!)
2. Import what you need from stdlib (`import std/io (println)`)
3. Define exported functions with `export func name(params) -> ReturnType { }`
4. Declare effects with `! {IO, FS}` when using IO/FS operations
5. Use recursion instead of loops - AILANG has NO for/while loops!

**Remember:**
- ‚úÖ Use `func` NOT `fn`, `function`, or `def`
- ‚úÖ ADTs use `type Name[a] = Cons1(a) | Cons2` syntax
- ‚úÖ NO `::` operator - use constructors directly
- ‚úÖ NO for/while loops - use recursion
- ‚úÖ Everything is immutable (no `var` or mutation)
- ‚úÖ Pattern matching uses `=>` arrows
- ‚úÖ Functions need type signatures
- ‚úÖ Effects must be declared with `! {IO}` or `! {FS}` or `! {IO, FS}`
- ‚úÖ Program runs via: `ailang run file.ail --entry main --caps IO`

**If you're not sure, look at the examples above!** They show the exact AILANG syntax.

---

# AI Prompt: v0.3.0-hints.md

# AILANG AI Teaching Prompt (v0.3.0-hints)

**CRITICAL: You MUST write code in AILANG syntax. This is NOT Python, NOT Rust, NOT JavaScript.**

You are writing code in AILANG, a pure functional programming language with Hindley-Milner type inference and algebraic effects.

**IMPORTANT SYNTAX RULES:**
- Use `func` NOT `fn`, `function`, or `def`
- Use `type Name[a] = Constructor(a) | Constructor2` NOT `type Name { }` or `enum`
- NO namespace syntax (`::`), just use constructor names directly
- Semicolons REQUIRED between statements in blocks
- Pattern matching uses `=>` NOT `:` or `->`
- NO `for`, `while`, `var`, `const`, `let mut`, or any imperative constructs

---

## üö® COMMON ERROR PATTERNS (AVOID THESE!)

Based on real AI code generation errors, here are the most common mistakes:

### ‚ùå ERROR 1: Missing Semicolons in Blocks (PAR_001)
**Symptom**: Parse error mentioning "expected semicolon" or "block"

**‚ùå WRONG:**
```ailang
{
  println("First")
  println("Second")  -- Parse error!
}
```

**‚úÖ CORRECT:**
```ailang
{
  println("First");   -- Semicolon required!
  println("Second")   -- Last statement can omit semicolon
}
```

**Rule**: Every statement in a block EXCEPT the last MUST have a semicolon.

---

### ‚ùå ERROR 2: Accessing Non-Existent Record Fields (TC_REC_001)
**Symptom**: Type error mentioning "field not found" or "record does not contain"

**‚ùå WRONG:**
```ailang
let person = {name: "Alice", age: 30};
person.email  -- ERROR! Field doesn't exist
```

**‚úÖ CORRECT:**
```ailang
-- Option 1: Only access fields that exist
let person = {name: "Alice", age: 30};
person.name  -- ‚úì Works

-- Option 2: Include all needed fields
let person = {name: "Alice", age: 30, email: "alice@example.com"};
person.email  -- ‚úì Works
```

**Rule**: You can only access fields that were explicitly included in the record literal.

---

### ‚ùå ERROR 3: Using Modulo (%) on Floats (TC_INT_001)
**Symptom**: Type error mentioning "Integral" or "modulo not defined for Float"

**‚ùå WRONG:**
```ailang
let result = 5.5 % 2.0  -- ERROR! % only works on integers
```

**‚úÖ CORRECT:**
```ailang
let result = 5 % 2  -- ‚úì Works with integers
```

**Rule**: The modulo operator `%` only works on `int`, not `float`. Use integer literals without decimals.

---

### ‚ùå ERROR 4: Wrong Equality Dictionary (EQ_001)
**Symptom**: Type error mentioning "Eq dictionary" or "expected Eq[T]"

**Why**: Usually caused by mixing types in comparisons or using `show` incorrectly.

**‚ùå WRONG:**
```ailang
let result = 5 == 5.0  -- Comparing int with float
```

**‚úÖ CORRECT:**
```ailang
let result = 5 == 5      -- Both int
let result2 = 5.0 == 5.0  -- Both float
```

**Rule**: Both sides of `==` must be the same type.

---

### ‚ùå ERROR 5: Missing Effect Capabilities (CAP_001)
**Symptom**: Runtime error mentioning "missing capability" or "requires IO/FS/Clock/Net"

**‚ùå WRONG:**
```ailang
-- Function declares IO effect but program doesn't request it
export func main() -> () ! {IO} {
  println("hello")
}
-- Run with: ailang run file.ail  ‚Üê Missing --caps IO!
```

**‚úÖ CORRECT:**
```ailang
export func main() -> () ! {IO} {
  println("hello")
}
-- Run with: ailang run --caps IO --entry main file.ail
```

**Rule**: Always declare effects in function signatures (`! {IO}`) AND request capabilities at runtime (`--caps IO`).

---

### ‚ùå ERROR 6: Undefined Module or Entrypoint (MOD_001)
**Symptom**: Runtime error mentioning "entrypoint not found" or "module not found"

**‚ùå WRONG:**
```ailang
module benchmark/solution

-- Missing export keyword!
func main() -> () ! {IO} {
  println("hello")
}
```

**‚úÖ CORRECT:**
```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {  -- Must export!
  println("hello")
}
```

**Rule**: Entrypoint functions must be `export`ed. Module name should match file structure.

---

## Current Version: v0.3.0 (October 2025)

**‚úÖ WHAT WORKS:**
- ‚úÖ **Module declarations** - `module path/to/module`
- ‚úÖ **Function declarations** - `export func name(params) -> Type { body }`
- ‚úÖ **Import statements** - `import std/io (println)`, `import std/clock (now, sleep)`, `import std/net (httpGet)`
- ‚úÖ **Pattern matching** - Constructors, tuples, lists, wildcards, **guards** (`if` conditions)
- ‚úÖ **Effect system** - `! {IO, FS, Clock, Net}` for side effects with capability security
- ‚úÖ **ADTs** - Algebraic data types: `type Option[a] = Some(a) | None`
- ‚úÖ **Recursion** - Self-recursive and mutually-recursive functions with stack overflow protection
- ‚úÖ **Block expressions** - `{ stmt1; stmt2; result }` for sequencing
- ‚úÖ **Records** - Record literals, field access, subsumption
- ‚úÖ **Type system fixes** - Modulo operator (`%`) and float comparison (`==`) both work correctly

**‚ö†Ô∏è LIMITATIONS:**
- ‚ö†Ô∏è NO `for`/`while` loops - use recursion
- ‚ö†Ô∏è NO `var` - everything is immutable
- ‚ö†Ô∏è NO record update syntax `{r | field: val}` (yet)
- ‚ö†Ô∏è NO error propagation operator `?` (yet)
- ‚ö†Ô∏è NO custom HTTP headers (OpenAI/Claude APIs blocked until v0.4.0)
- ‚ö†Ô∏è `show` is a builtin - do NOT import it

## Module Structure

Every AILANG program must be a module with exported functions:

```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello, World!")
}
```

**IMPORTANT**: Always use `module benchmark/solution` as the module name for benchmark programs.

## Functions

```ailang
-- Simple pure function
export func add(x: int, y: int) -> int {
  x + y
}

-- Function with effects (IO, FS)
export func greet(name: string) -> () ! {IO} {
  println("Hello, " ++ name)
}

-- Generic function
export func identity[a](x: a) -> a {
  x
}

-- Multi-statement body (SEMICOLONS REQUIRED!)
export func compute() -> int {
  let x = 10;
  let y = 20;
  x + y
}
```

## Block Expressions (NEW in v0.3.0!)

Blocks allow sequencing statements with semicolons:

```ailang
export func demo() -> () ! {IO} {
  {
    println("First");
    println("Second");
    println("Third")
  }
}

-- Blocks are expressions - the last value is returned
export func compute() -> int {
  {
    let x = 10;
    let y = 20;
    x + y
  }
}
```

**CRITICAL**: Semicolons REQUIRED between statements! Missing semicolons will cause parse errors (PAR_001).

## Records (NEW in v0.3.0!)

Records are structural types with named fields:

```ailang
-- Record literal
let person = {name: "Alice", age: 30, city: "NYC"}

-- Field access (ONLY fields that exist!)
person.name    -- "Alice"
person.age     -- 30

-- Use in functions
export func describe(p: {name: string, age: int}) -> string {
  p.name ++ " is " ++ show(p.age)
}
```

**‚ö†Ô∏è IMPORTANT**: Record update syntax `{r | field: val}` is NOT yet implemented.
To create a modified record, create a new record literal:

```ailang
-- ‚ùå NOT supported yet:
let older = {person | age: 31}

-- ‚úÖ Instead do this:
let older = {name: person.name, age: 31, city: person.city}
```

**‚ö†Ô∏è CRITICAL**: You can ONLY access fields that exist in the record. Accessing non-existent fields causes TC_REC_001 errors.

## Algebraic Data Types (ADTs)

**‚úÖ CORRECT AILANG SYNTAX:**
```ailang
type Option[a] = Some(a) | None
type Result[a, e] = Ok(a) | Err(e)
type List[a] = Cons(a, List[a]) | Nil

export func getOrElse[a](opt: Option[a], default: a) -> a {
  match opt {
    Some(x) => x,
    None => default
  }
}
```

**‚ùå WRONG - This is Rust/other languages, NOT AILANG:**
```rust
type Option {        // ‚ùå Wrong - no { } braces
  Some(value)        // ‚ùå Wrong - not AILANG syntax
  None
}

Option::Some(42)     // ‚ùå Wrong - AILANG has no :: operator
fn divide(a, b) { }  // ‚ùå Wrong - use 'func' not 'fn'
```

**‚úÖ CORRECT - Use constructors directly:**
```ailang
Some(42)             // ‚úÖ Correct - no namespace needed
None                 // ‚úÖ Correct
```

## Available Imports

**std/io** - IO operations (requires `! {IO}` effect)
```ailang
import std/io (println, print, readLine)

export func main() -> () ! {IO} {
  println("text")
}
```

**std/fs** - File operations (requires `! {FS}` effect)
```ailang
import std/fs (readFile, writeFile, exists)

export func readData() -> string ! {FS} {
  readFile("data.txt")
}
```

**std/clock** - Time operations (requires `! {Clock}` effect) **NEW in v0.3.0!**
```ailang
import std/clock (now, sleep)

export func measureTime() -> () ! {IO, Clock} {
  let start = now();
  sleep(1000);  -- Sleep for 1 second (milliseconds)
  let end = now();
  println("Elapsed: " ++ show(end - start) ++ "ms")
}
```

**std/net** - HTTP operations (requires `! {Net}` effect) **NEW in v0.3.0!**
```ailang
import std/net (httpGet, httpPost)

export func fetchData() -> () ! {IO, Net} {
  let response = httpGet("https://api.example.com/data");
  println(response)
}
```

**IMPORTANT:**
- `show` is a BUILTIN function - do NOT import it from std/io!
- Clock and Net have security restrictions (no localhost, private IPs, file:// URLs blocked)
- Run with capabilities: `ailang run --caps IO,FS,Clock,Net --entry main file.ail`

**std/option** - Option type
```ailang
import std/option (Option, Some, None)
```

## Recursion (instead of loops)

Recursion works perfectly in v0.3.0:

```ailang
export func factorial(n: int) -> int {
  if n <= 1
  then 1
  else n * factorial(n - 1)
}

-- Recursion with IO effects and blocks
export func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}
```

## Complete Working Examples

### Example 1: Safe Division with Option
```ailang
module benchmark/solution

import std/io (println)

type Option[a] = Some(a) | None

export func safeDivide(a: float, b: float) -> Option[float] {
  if b == 0.0
  then None
  else Some(a / b)
}

export func printResult(result: Option[float]) -> () ! {IO} {
  match result {
    Some(v) => println("Result: " ++ show(v)),
    None => println("Error: Division by zero")
  }
}

export func main() -> () ! {IO} {
  let r1 = safeDivide(10.0, 2.0);
  printResult(r1);
  let r2 = safeDivide(10.0, 0.0);
  printResult(r2)
}
```

### Example 2: Countdown with Recursion and Blocks
```ailang
module benchmark/solution

import std/io (println)

export func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}

export func main() -> () ! {IO} {
  countdown(5)
}
```

### Example 3: Records with Field Access
```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  let alice = {name: "Alice", age: 30, city: "NYC"};
  let bob = {name: "Bob", age: 25, city: "SF"};

  println(alice.name ++ ", " ++ show(alice.age) ++ ", " ++ alice.city);
  println(bob.name ++ ", " ++ show(bob.age) ++ ", " ++ bob.city)
}
```

## Summary

**Structure:**
1. Start with `module benchmark/solution` (REQUIRED for benchmarks!)
2. Import what you need from stdlib (`import std/io (println)`)
3. Define exported functions with `export func name(params) -> ReturnType { }`
4. Declare effects with `! {IO, FS}` when using IO/FS operations
5. Use recursion instead of loops - AILANG has NO for/while loops!
6. Use semicolons between statements in blocks (or you'll get PAR_001 errors!)

**Remember:**
- ‚úÖ Use `func` NOT `fn`, `function`, or `def`
- ‚úÖ ADTs use `type Name[a] = Cons1(a) | Cons2` syntax
- ‚úÖ NO `::` operator - use constructors directly
- ‚úÖ NO for/while loops - use recursion
- ‚úÖ Everything is immutable (no `var` or mutation)
- ‚úÖ Pattern matching uses `=>` arrows, guards work (`if` conditions)
- ‚úÖ Semicolons REQUIRED between statements in blocks (PAR_001)
- ‚úÖ `show` is builtin - do NOT import it
- ‚úÖ Records: use literals and field access, NO update syntax yet
- ‚úÖ Only access record fields that exist (TC_REC_001)
- ‚úÖ Modulo `%` only works on int, not float (TC_INT_001)
- ‚úÖ Effects must be declared: `! {IO}`, `! {FS}`, `! {Clock}`, `! {Net}`, or combinations
- ‚úÖ Export entrypoint functions (MOD_001)
- ‚úÖ Request capabilities at runtime with --caps (CAP_001)
- ‚úÖ Modulo operator `%` works: `5 % 3` returns `2`
- ‚úÖ Float comparison works: `0.0 == 0.0` returns `true`
- ‚úÖ Four effects available: IO (console), FS (files), Clock (time), Net (HTTP)

**If you're not sure, look at the examples above!** They show the exact AILANG syntax.

**üéØ Key Difference in v0.3.0-hints:**
This prompt includes explicit error pattern warnings based on real AI code generation failures. Following these hints should significantly reduce common errors.

**v0.3.0 Release Notes (October 2025):**
- Added Clock effect (monotonic time, sleep, deterministic mode)
- Added Net effect (HTTP GET/POST with DNS rebinding prevention, IP blocking)
- Fixed modulo operator (`%`) type defaulting
- Fixed float comparison (`==`) dictionary resolution
- Pattern matching guards now work correctly
- 48+ working examples demonstrating all features

---

# AI Prompt: v0.3.0.md

# AILANG AI Teaching Prompt (v0.3.0)

**CRITICAL: You MUST write code in AILANG syntax. This is NOT Python, NOT Rust, NOT JavaScript.**

You are writing code in AILANG, a pure functional programming language with Hindley-Milner type inference and algebraic effects.

**IMPORTANT SYNTAX RULES:**
- Use `func` NOT `fn`, `function`, or `def`
- Use `type Name[a] = Constructor(a) | Constructor2` NOT `type Name { }` or `enum`
- NO namespace syntax (`::`), just use constructor names directly
- Semicolons REQUIRED between statements in blocks
- Pattern matching uses `=>` NOT `:` or `->`
- NO `for`, `while`, `var`, `const`, `let mut`, or any imperative constructs

## Current Version: v0.3.0 (October 2025)

**‚úÖ WHAT WORKS:**
- ‚úÖ **Module declarations** - `module path/to/module`
- ‚úÖ **Function declarations** - `export func name(params) -> Type { body }`
- ‚úÖ **Import statements** - `import std/io (println)`, `import std/clock (now, sleep)`, `import std/net (httpGet)`
- ‚úÖ **Pattern matching** - Constructors, tuples, lists, wildcards, **guards** (`if` conditions)
- ‚úÖ **Effect system** - `! {IO, FS, Clock, Net}` for side effects with capability security
- ‚úÖ **ADTs** - Algebraic data types: `type Option[a] = Some(a) | None`
- ‚úÖ **Recursion** - Self-recursive and mutually-recursive functions with stack overflow protection
- ‚úÖ **Block expressions** - `{ stmt1; stmt2; result }` for sequencing
- ‚úÖ **Records** - Record literals, field access, subsumption
- ‚úÖ **Type system fixes** - Modulo operator (`%`) and float comparison (`==`) both work correctly

**‚ö†Ô∏è LIMITATIONS:**
- ‚ö†Ô∏è NO `for`/`while` loops - use recursion
- ‚ö†Ô∏è NO `var` - everything is immutable
- ‚ö†Ô∏è NO record update syntax `{r | field: val}` (yet)
- ‚ö†Ô∏è NO error propagation operator `?` (yet)
- ‚ö†Ô∏è NO custom HTTP headers (OpenAI/Claude APIs blocked until v0.4.0)
- ‚ö†Ô∏è `show` is a builtin - do NOT import it

## Module Structure

Every AILANG program must be a module with exported functions:

```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello, World!")
}
```

**IMPORTANT**: Always use `module benchmark/solution` as the module name for benchmark programs.

## Functions

```ailang
-- Simple pure function
export func add(x: int, y: int) -> int {
  x + y
}

-- Function with effects (IO, FS)
export func greet(name: string) -> () ! {IO} {
  println("Hello, " ++ name)
}

-- Generic function
export func identity[a](x: a) -> a {
  x
}

-- Multi-statement body (SEMICOLONS REQUIRED!)
export func compute() -> int {
  let x = 10;
  let y = 20;
  x + y
}
```

## Block Expressions (NEW in v0.3.0!)

Blocks allow sequencing statements with semicolons:

```ailang
export func demo() -> () ! {IO} {
  {
    println("First");
    println("Second");
    println("Third")
  }
}

-- Blocks are expressions - the last value is returned
export func compute() -> int {
  {
    let x = 10;
    let y = 20;
    x + y
  }
}
```

**CRITICAL**: Semicolons REQUIRED between statements! Missing semicolons will cause parse errors.

## Records (NEW in v0.3.0!)

Records are structural types with named fields:

```ailang
-- Record literal
let person = {name: "Alice", age: 30, city: "NYC"}

-- Field access
person.name    -- "Alice"
person.age     -- 30

-- Use in functions
export func describe(p: {name: string, age: int}) -> string {
  p.name ++ " is " ++ show(p.age)
}
```

**‚ö†Ô∏è IMPORTANT**: Record update syntax `{r | field: val}` is NOT yet implemented.
To create a modified record, create a new record literal:

```ailang
-- ‚ùå NOT supported yet:
let older = {person | age: 31}

-- ‚úÖ Instead do this:
let older = {name: person.name, age: 31, city: person.city}
```

## Algebraic Data Types (ADTs)

**‚úÖ CORRECT AILANG SYNTAX:**
```ailang
type Option[a] = Some(a) | None
type Result[a, e] = Ok(a) | Err(e)
type List[a] = Cons(a, List[a]) | Nil

export func getOrElse[a](opt: Option[a], default: a) -> a {
  match opt {
    Some(x) => x,
    None => default
  }
}
```

**‚ùå WRONG - This is Rust/other languages, NOT AILANG:**
```rust
type Option {        // ‚ùå Wrong - no { } braces
  Some(value)        // ‚ùå Wrong - not AILANG syntax
  None
}

Option::Some(42)     // ‚ùå Wrong - AILANG has no :: operator
fn divide(a, b) { }  // ‚ùå Wrong - use 'func' not 'fn'
```

**‚úÖ CORRECT - Use constructors directly:**
```ailang
Some(42)             // ‚úÖ Correct - no namespace needed
None                 // ‚úÖ Correct
```

## Available Imports

**std/io** - IO operations (requires `! {IO}` effect)
```ailang
import std/io (println, print, readLine)

export func main() -> () ! {IO} {
  println("text")
}
```

**std/fs** - File operations (requires `! {FS}` effect)
```ailang
import std/fs (readFile, writeFile, exists)

export func readData() -> string ! {FS} {
  readFile("data.txt")
}
```

**std/clock** - Time operations (requires `! {Clock}` effect) **NEW in v0.3.0!**
```ailang
import std/clock (now, sleep)

export func measureTime() -> () ! {IO, Clock} {
  let start = now();
  sleep(1000);  -- Sleep for 1 second (milliseconds)
  let end = now();
  println("Elapsed: " ++ show(end - start) ++ "ms")
}
```

**std/net** - HTTP operations (requires `! {Net}` effect) **NEW in v0.3.0!**
```ailang
import std/net (httpGet, httpPost)

export func fetchData() -> () ! {IO, Net} {
  let response = httpGet("https://api.example.com/data");
  println(response)
}
```

**IMPORTANT:**
- `show` is a BUILTIN function - do NOT import it from std/io!
- Clock and Net have security restrictions (no localhost, private IPs, file:// URLs blocked)
- Run with capabilities: `ailang run --caps IO,FS,Clock,Net --entry main file.ail`

**std/option** - Option type
```ailang
import std/option (Option, Some, None)
```

## Recursion (instead of loops)

Recursion works perfectly in v0.3.0:

```ailang
export func factorial(n: int) -> int {
  if n <= 1
  then 1
  else n * factorial(n - 1)
}

-- Recursion with IO effects and blocks
export func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}
```

## Common Mistakes to Avoid

‚ùå **Don't use for/while loops:**
```ailang
for i in [1, 2, 3] { println(i) }  -- ‚ùå NOT supported
```

‚úÖ **Use recursion:**
```ailang
export func printAll(xs: [int]) -> () ! {IO} {
  match xs {
    [] => (),
    _ => {
      println(show(head(xs)));
      printAll(tail(xs))
    }
  }
}
```

‚ùå **Don't forget semicolons in blocks:**
```ailang
{
  println("First")
  println("Second")  -- ‚ùå Parse error! Missing semicolon
}
```

‚úÖ **Add semicolons between statements:**
```ailang
{
  println("First");
  println("Second")  -- ‚úÖ Last statement doesn't need semicolon
}
```

‚ùå **Don't import show:**
```ailang
import std/io (println, show)  -- ‚ùå show not in std/io
```

‚úÖ **show is a builtin:**
```ailang
import std/io (println)
-- show is available automatically
println(show(42))
```

‚ùå **Don't forget module and export:**
```ailang
func main() {  -- ‚ùå Missing 'module' declaration and 'export'
  println("hello")
}
```

‚úÖ **Always use module and export:**
```ailang
module benchmark/solution
import std/io (println)

export func main() -> () ! {IO} {
  println("hello")
}
```

## Complete Working Examples

### Example 1: Safe Division with Option
```ailang
module benchmark/solution

import std/io (println)

type Option[a] = Some(a) | None

export func safeDivide(a: float, b: float) -> Option[float] {
  if b == 0.0
  then None
  else Some(a / b)
}

export func printResult(result: Option[float]) -> () ! {IO} {
  match result {
    Some(v) => println("Result: " ++ show(v)),
    None => println("Error: Division by zero")
  }
}

export func main() -> () ! {IO} {
  let r1 = safeDivide(10.0, 2.0);
  printResult(r1);
  let r2 = safeDivide(10.0, 0.0);
  printResult(r2)
}
```

### Example 2: Countdown with Recursion and Blocks
```ailang
module benchmark/solution

import std/io (println)

export func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}

export func main() -> () ! {IO} {
  countdown(5)
}
```

### Example 3: Records with Field Access
```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  let alice = {name: "Alice", age: 30, city: "NYC"};
  let bob = {name: "Bob", age: 25, city: "SF"};

  println(alice.name ++ ", " ++ show(alice.age) ++ ", " ++ alice.city);
  println(bob.name ++ ", " ++ show(bob.age) ++ ", " ++ bob.city)
}
```

## Summary

**Structure:**
1. Start with `module benchmark/solution` (REQUIRED for benchmarks!)
2. Import what you need from stdlib (`import std/io (println)`)
3. Define exported functions with `export func name(params) -> ReturnType { }`
4. Declare effects with `! {IO, FS}` when using IO/FS operations
5. Use recursion instead of loops - AILANG has NO for/while loops!
6. Use semicolons between statements in blocks

**Remember:**
- ‚úÖ Use `func` NOT `fn`, `function`, or `def`
- ‚úÖ ADTs use `type Name[a] = Cons1(a) | Cons2` syntax
- ‚úÖ NO `::` operator - use constructors directly
- ‚úÖ NO for/while loops - use recursion
- ‚úÖ Everything is immutable (no `var` or mutation)
- ‚úÖ Pattern matching uses `=>` arrows, guards work (`if` conditions)
- ‚úÖ Semicolons REQUIRED between statements in blocks
- ‚úÖ `show` is builtin - do NOT import it
- ‚úÖ Records: use literals and field access, NO update syntax yet
- ‚úÖ Effects must be declared: `! {IO}`, `! {FS}`, `! {Clock}`, `! {Net}`, or combinations
- ‚úÖ Modulo operator `%` works: `5 % 3` returns `2`
- ‚úÖ Float comparison works: `0.0 == 0.0` returns `true`
- ‚úÖ Four effects available: IO (console), FS (files), Clock (time), Net (HTTP)

**If you're not sure, look at the examples above!** They show the exact AILANG syntax.

**v0.3.0 Release Notes (October 2025):**
- Added Clock effect (monotonic time, sleep, deterministic mode)
- Added Net effect (HTTP GET/POST with DNS rebinding prevention, IP blocking)
- Fixed modulo operator (`%`) type defaulting
- Fixed float comparison (`==`) dictionary resolution
- Pattern matching guards now work correctly
- 48+ working examples demonstrating all features

---

# Examples Status

## Example Status

### Working Examples ‚úÖ
- `adt_option.ail`
- `adt_simple.ail`
- `arithmetic.ail`
- `block_recursion.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha2)
- `demos/adt_pipeline.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `demos/hello_io.ail`
- `effects_basic.ail`
- `effects_pure.ail`
- `guards_basic.ail`
- `hello.ail`
- `micro_block_if.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha2)
- `micro_block_seq.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha2)
- `micro_io_echo.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `micro_option_map.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `micro_record_person.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha3 M-R5 Day 3)
- `recursion_error.ail`
- `recursion_factorial.ail`
- `recursion_fibonacci.ail`
- `recursion_mutual.ail`
- `recursion_quicksort.ail`
- `showcase/01_type_inference.ail`
- `showcase/02_lambdas.ail`
- `showcase/03_type_classes.ail`
- `showcase/04_closures.ail`
- `simple.ail`
- `test_effect_annotation.ail`
- `test_effect_capability.ail`
- `test_effect_fs.ail`
- `test_effect_io.ail`
- `test_exhaustive_bool_complete.ail`
- `test_exhaustive_bool_incomplete.ail`
- `test_exhaustive_wildcard.ail`
- `test_guard_bool.ail`
- `test_guard_debug.ail`
- `test_guard_false.ail`
- `test_import_ctor.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `test_import_func.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `test_invocation.ail`
- `test_io_builtins.ail`
- `test_module_minimal.ail`
- `test_no_import.ail`
- `test_record_subsumption.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha3 M-R5 Day 3)
- `test_single_guard.ail`
- `test_use_constructor.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `test_with_import.ail`
- `type_classes_working_reference.ail`
- `v3_3/imports.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `v3_3/imports_basic.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)

### Failing Examples ‚ùå
- `demos/effects_pure.ail`
- `experimental/ai_agent_integration.ail`
- `experimental/concurrent_pipeline.ail`
- `experimental/factorial.ail`
- `experimental/quicksort.ail`
- `experimental/web_api.ail`
- `lambda_expressions.ail`
- `list_patterns.ail`
- `patterns.ail`
- `records.ail`
- `showcase/03_lists.ail`
- `test_effect_io_simple.ail`
- `typeclasses.ail`
- `v3_3/math/gcd.ail`

### Skipped Examples ‚è≠Ô∏è
- `block_demo.ail`
- `option_demo.ail`
- `stdlib_demo.ail`
- `stdlib_demo_simple.ail`

**Summary:** 48 passed, 14 failed, 4 skipped (Total: 66)

**Recent improvements:**
- ‚úÖ **M-R5 (v0.3.0-alpha3)**: 11 examples fixed/added via records & row polymorphism!
  - Day 1: 9 examples fixed (demos/adt_pipeline, micro_io_echo, micro_option_map, test_import_ctor, test_import_func, test_use_constructor, v3_3/imports, v3_3/imports_basic)
  - Day 3: 2 new examples (micro_record_person, test_record_subsumption)
- ‚úÖ **M-R8 (v0.3.0-alpha2)**: `micro_block_*.ail`, `block_recursion.ail` (3 files) - Block expressions with recursion
- ‚úÖ **M-R4 (v0.3.0-alpha1)**: `recursion_*.ail` (5 files) - Recursion support with RefCell indirection

---

