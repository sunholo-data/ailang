# AILANG Documentation for LLMs

This file contains all AILANG documentation in a single file for LLM consumption.

Last updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

---


# README

# üß† AILANG: The Deterministic Language for AI Coders

![CI](https://github.com/sunholo-data/ailang/workflows/CI/badge.svg)
![Coverage](https://img.shields.io/badge/coverage-32.6%25-orange.svg)
![Go Version](https://img.shields.io/badge/go-%3E%3D1.22-blue.svg)
![License](https://img.shields.io/badge/license-Apache%202.0-green.svg)

AILANG is a purely functional, effect-typed language designed for **autonomous code synthesis and reasoning**. Unlike human-oriented languages built around IDEs, concurrency, and sugar, AILANG's design goal is **machine decidability, semantic transparency, and compositional determinism**.

---

## üß© Core Philosophy

**For humans, a language is a tool for expression.**
**For AIs, it's a substrate for reasoning.**

AILANG minimizes ambiguity and maximizes predictability. Every construct ‚Äî type, effect, or expression ‚Äî has **deterministic semantics** that can be reflected, verified, and serialized.

---

## üèóÔ∏è Architecture Overview

| Layer | Description | Status |
|-------|-------------|--------|
| **1. Core Semantics** | Pure functional core with algebraic data types (ADTs), first-class effects, and Hindley-Milner type inference. | ‚úÖ Stable |
| **2. Type System** | Polymorphic effects (`! {IO, Œµ}`), `Result` and `Option` types, and fully deterministic unification (TApp-aware). | ‚úÖ Stable |
| **3. Reflection & Meta-Programming** | Typed quasiquotes and semantic reflection (`reflect(typeOf(f))`) for deterministic code generation. | üîú v0.4.x |
| **4. Deterministic Tooling** | Canonical `normalize`, `suggest`, and `apply` commands; JSON schema output; `--emit-trace jsonl` for training data. | üîú v0.3.15 |
| **5. Schema & Hashing Layer** | Machine-readable type/effect registry and versioned semantic hashes for reproducible builds. | üîú v0.4.x |
| **6. Runtime & Effects** | Deterministic evaluator with explicit effect rows; supports IO, FS, Net, Clock; no hidden state or global scheduler. | ‚úÖ Stable |
| **7. Cognitive Interfaces** | JSONL trace export for AI self-training; deterministic edit plans for autonomous refactoring. | üîú v0.4.x |
| **8. Future Extensions** | Capability budgets (`! {IO @limit=2}`), semantic DAG scheduler (`schedule { a >> b \| c }`). | üîÆ v0.5.x+ |

---

## ‚ùå Removed / Deprecated Human-Oriented Features

| Removed Feature | Reason for Removal |
|----------------|-------------------|
| **CSP Concurrency / Session Types** | Replaced by static effect-typed task graphs; no runtime scheduler needed. |
| **Unstructured Macros** | Replaced by typed quasiquotes (deterministic AST templates). |
| **Type Classes** | Replaced by structural reflection and record-based traits; removes implicit resolution. |
| **LSP Server** | Superseded by deterministic JSON-RPC API (`ailangd`) exposing parser/typechecker directly. |
| **IDE-centric DX Features** | AIs interact via CLI / API; autocompletion and hover text are unnecessary. |

---

## üîÆ AI-Native Roadmap

| Milestone | Goal | Example Deliverable |
|-----------|------|-------------------|
| **v0.3.15 ‚Äì Deterministic Tooling** | Canonical normalization, symbol import suggestion, JSON trace export | `ailang suggest-imports file.ail` |
| **v0.4.0 ‚Äì Meta & Reflection Layer** | Typed quasiquotes + reflection API | `quote (x) -> x + 1 : (int)->int` |
| **v0.4.2 ‚Äì Schema Registry** | Machine-readable type/effect schemas for deterministic builds | `/schemas/std/io.json` |
| **v0.5.x ‚Äì Unified Registry Runtime** | Remove legacy builtin registry; single spec source | `RegisterBuiltin(spec)` unified |
| **v0.6.x ‚Äì Capability Budgets & DAG Scheduler** | Deterministic parallelism via static scheduling | `schedule { parse >> decode \| validate }` |
| **v1.0 ‚Äì Cognitive Autonomy** | Full round-trip reasoning: AI reads, edits, compiles, evaluates, and self-trains from traces | `--emit-trace jsonl` ‚Üí fine-tuned validator |

---

## üß™ Current Milestone: v0.3.14 (JSON Decode)

- ‚úÖ Added `std/json.decode : string -> Result[Json, string]` with streaming parser
- ‚úÖ Fixed list/record pattern matching at runtime
- ‚úÖ Unified primitive type casing (`string`, `int`, `float`, `bool`)
- ‚úÖ DX overhaul: operators (`==`, `!=`, `<`, `>=`) now work naturally
- ‚úÖ All **2,847 tests passing**; 100% coverage on new builtin
- üîú **Next**: deterministic tooling (`normalize`, `suggest`, `apply`) in v0.3.15

### Major Milestones

- **v0.3.14 (Oct 2025)**: JSON Decode Release - JSON parsing + pattern matching fixes
- **v0.3.12 (Oct 2025)**: Recovery Release - `show()` builtin restored (recovers 51% of benchmarks)
- **v0.3.11 (Oct 2025)**: Critical row unification fix
- **v0.3.10 (Oct 2025)**: M-DX1 Developer Experience - Builtin system migration (-67% dev time)
- **v0.3.9 (Oct 2025)**: AI API Integration - HTTP headers, JSON encoding, OpenAI example
- **v0.3.6 (Oct 2025)**: AI usability - auto-import, record updates, error detection
- **v0.3.5 (Oct 2025)**: Anonymous functions, `letrec`, numeric conversions

For detailed version history, see [CHANGELOG.md](CHANGELOG.md).

---

## üí° Why AILANG Works Better for AIs

| Human Need | Human Feature | AI Equivalent in AILANG |
|-----------|---------------|------------------------|
| IDE assistance | LSP / autocompletion | Deterministic type/query API |
| Asynchronous code | Threads / goroutines | Static task DAGs with effects |
| Code reuse | Inheritance / traits | Structural reflection & records |
| Debugging | Interactive debugger | Replayable evaluation trace |
| Logging | `print` / `console` | `--emit-trace jsonl` structured logs |
| Macros | text substitution | Typed quasiquotes (semantic macros) |

---

## Quick Start

### Installation

```bash
# From source
git clone https://github.com/sunholo/ailang.git
cd ailang
make install

# Verify installation
ailang --version
```

For detailed installation instructions, see the [Getting Started Guide](docs/guides/getting-started.md).

### Hello World (Module Execution)

```ailang
-- examples/demos/hello_io.ail
module examples/demos/hello_io

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello from AILANG v0.3.14!")
}
```

```bash
ailang run --caps IO examples/demos/hello_io.ail
# Output: Hello from AILANG v0.3.14!
```

**Important**: Flags must come BEFORE the filename:
```bash
# ‚úÖ CORRECT:
ailang run --caps IO --entry main file.ail

# ‚ùå WRONG:
ailang run file.ail --caps IO --entry main
```

### Interactive REPL

The REPL features full type inference and deterministic evaluation:

```bash
ailang repl

Œª> 1 + 2
3 :: Int

Œª> "Hello " ++ "World"
Hello World :: String

Œª> let double = \x. x * 2 in double(21)
42 :: Int

Œª> :type \x. x + x
\x. x + x :: ‚àÄŒ±. Num Œ± ‚áí Œ± ‚Üí Œ±

Œª> :quit
```

**REPL Commands**: `:help`, `:type <expr>`, `:instances`, `:import <module>`, `:history`, `:clear`

See [REPL Commands](docs/reference/repl-commands.md) for full reference.

---

## What AILANG Can Do (Implementation Status)

### ‚úÖ Core Language

- **Pure functional programming** - Lambda calculus, closures, recursion
- **Hindley-Milner type inference** - Row polymorphism, let-polymorphism
- **Built-in type class instances** - `Num`, `Eq`, `Ord`, `Show` (structural reflection planned for v0.4.0)
- **Algebraic effects** - Capability-based security (IO, FS, Clock, Net)
- **Pattern matching** - ADTs with exhaustiveness checking
- **Module system** - Runtime execution, cross-module imports
- **Block expressions** - `{ e1; e2; e3 }` for sequencing
- **JSON support** - Parsing (`std/json.decode`), encoding (`std/json.encode`)

### ‚úÖ Development Tools

- **M-EVAL** - AI code generation benchmarks (multi-model support)
- **M-EVAL-LOOP v2.0** - Native Go eval tools with 90%+ test coverage
- **Structured error reporting** - JSON schemas for deterministic diagnostics
- **Effect system runtime** - Hermetic testing with `MockEffContext`

### üîú Deterministic Tooling (v0.3.15)

- **`ailang normalize`** - Canonical code formatting
- **`ailang suggest-imports`** - Automatic import resolution
- **`ailang apply`** - Deterministic code edits from JSON plans
- **`--emit-trace jsonl`** - Structured execution traces for training

### üîÆ Future (v0.4.0+)

- **Typed quasiquotes** - Deterministic AST templates
- **Structural reflection** - Replace hardcoded type classes
- **Schema registry** - Machine-readable type/effect definitions
- **Capability budgets** - Resource-bounded effects

---

## üìä Test Coverage

**Examples**: 48/66 passing (72.7%)

All record subsumption, effect system (IO, FS, Clock, Net), type class, ADT, recursion, and block expression examples working.

See [examples/STATUS.md](examples/STATUS.md) for detailed status.

<!-- EXAMPLES_STATUS_START -->
## Status

![Examples](https://img.shields.io/badge/examples-52%20passing%2032%20failing-red.svg)

### Example Verification Status

*Last updated: 2025-10-18 21:01:33 UTC*

**Summary:** 52 passed, 32 failed, 4 skipped (Total: 88)

| Example File | Status | Notes |
|--------------|--------|-------|
| `adt_option.ail` | ‚úÖ Pass |  |
| `adt_simple.ail` | ‚úÖ Pass |  |
| `ai_call.ail` | ‚ùå Fail | Warning: import path 'stdlib/std/*' is deprecat... |
| `arithmetic.ail` | ‚ùå Fail | Error: type error in examples/arithmetic (decl ... |
| `block_demo.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `block_recursion.ail` | ‚úÖ Pass |  |
| `bug_float_comparison.ail` | ‚úÖ Pass |  |
| `bug_modulo_operator.ail` | ‚úÖ Pass |  |
| `claude_haiku_call.ail` | ‚ùå Fail | Warning: import path 'stdlib/std/*' is deprecat... |
| `demo_ai_api.ail` | ‚ùå Fail | Error: type error in examples/demo_ai_api (decl... |
| `demo_openai_api.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `demos/adt_pipeline.ail` | ‚úÖ Pass |  |
| `demos/effects_pure.ail` | ‚ùå Fail | Warning: import path 'stdlib/std/*' is deprecat... |
| `demos/hello_io.ail` | ‚úÖ Pass |  |
| `effects_basic.ail` | ‚úÖ Pass |  |
| `effects_pure.ail` | ‚úÖ Pass |  |
| `experimental/ai_agent_integration.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/concurrent_pipeline.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/factorial.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/quicksort.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `experimental/web_api.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `func_expressions.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `guards_basic.ail` | ‚úÖ Pass |  |
| `hello.ail` | ‚ùå Fail | Error: type error in examples/hello (decl 0): u... |
| `json_basic_decode.ail` | ‚úÖ Pass |  |
| `lambda_expressions.ail` | ‚ùå Fail | Error: type error in examples/lambda_expression... |
| `letrec_recursion.ail` | ‚úÖ Pass |  |
| `list_patterns.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `micro_block_if.ail` | ‚úÖ Pass |  |
| `micro_block_seq.ail` | ‚úÖ Pass |  |
| `micro_clock_measure.ail` | ‚ùå Fail | Error: type error in examples/micro_clock_measu... |
| `micro_io_echo.ail` | ‚úÖ Pass |  |
| `micro_net_fetch.ail` | ‚ùå Fail | Error: type error in examples/micro_net_fetch (... |
| `micro_option_map.ail` | ‚úÖ Pass |  |
| `micro_record_person.ail` | ‚úÖ Pass |  |
| `numeric_conversion.ail` | ‚ùå Fail | Error: type error in examples/numeric_conversio... |
| `option_demo.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `patterns.ail` | ‚úÖ Pass |  |
| `records.ail` | ‚ùå Fail | Error: type error in examples/records (decl 3):... |
| `recursion_error.ail` | ‚úÖ Pass |  |
| `recursion_factorial.ail` | ‚úÖ Pass |  |
| `recursion_fibonacci.ail` | ‚úÖ Pass |  |
| `recursion_mutual.ail` | ‚úÖ Pass |  |
| `recursion_quicksort.ail` | ‚úÖ Pass |  |
| `showcase/01_type_inference.ail` | ‚ùå Fail | Error: type error in examples/showcase/01_type_... |
| `showcase/02_lambdas.ail` | ‚ùå Fail | Error: type error in examples/showcase/02_lambd... |
| `showcase/03_lists.ail` | ‚ùå Fail | Error: type error in examples/showcase/03_lists... |
| `showcase/03_type_classes.ail` | ‚ùå Fail | Error: type error in examples/showcase/03_type_... |
| `showcase/04_closures.ail` | ‚ùå Fail | Error: type error in examples/showcase/04_closu... |
| `simple.ail` | ‚úÖ Pass |  |
| `stdlib_demo.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `stdlib_demo_simple.ail` | ‚è≠Ô∏è Skip | Test/demo file |
| `test_effect_annotation.ail` | ‚úÖ Pass |  |
| `test_effect_capability.ail` | ‚úÖ Pass |  |
| `test_effect_fs.ail` | ‚úÖ Pass |  |
| `test_effect_io.ail` | ‚úÖ Pass |  |
| `test_effect_io_simple.ail` | ‚ùå Fail | Error: evaluation error: _io_println: no effect... |
| `test_exhaustive_bool_complete.ail` | ‚úÖ Pass |  |
| `test_exhaustive_bool_incomplete.ail` | ‚úÖ Pass |  |
| `test_exhaustive_wildcard.ail` | ‚úÖ Pass |  |
| `test_fizzbuzz.ail` | ‚úÖ Pass |  |
| `test_float_comparison.ail` | ‚úÖ Pass |  |
| `test_float_eq_works.ail` | ‚úÖ Pass |  |
| `test_float_modulo.ail` | ‚úÖ Pass |  |
| `test_guard_bool.ail` | ‚úÖ Pass |  |
| `test_guard_debug.ail` | ‚úÖ Pass |  |
| `test_guard_false.ail` | ‚úÖ Pass |  |
| `test_import_ctor.ail` | ‚úÖ Pass |  |
| `test_import_func.ail` | ‚úÖ Pass |  |
| `test_integral.ail` | ‚úÖ Pass |  |
| `test_invocation.ail` | ‚úÖ Pass |  |
| `test_io_builtins.ail` | ‚úÖ Pass |  |
| `test_m_r7_comprehensive.ail` | ‚ùå Fail | Error: module loading error: failed to load exa... |
| `test_module_minimal.ail` | ‚úÖ Pass |  |
| `test_modulo_works.ail` | ‚úÖ Pass |  |
| `test_net_file_protocol.ail` | ‚ùå Fail | Error: type error in examples/test_net_file_pro... |
| `test_net_localhost.ail` | ‚ùå Fail | Error: type error in examples/test_net_localhos... |
| `test_net_security.ail` | ‚ùå Fail | Error: type error in examples/test_net_security... |
| `test_no_import.ail` | ‚úÖ Pass |  |
| `test_record_subsumption.ail` | ‚úÖ Pass |  |
| `test_single_guard.ail` | ‚úÖ Pass |  |
| `test_use_constructor.ail` | ‚úÖ Pass |  |
| `test_with_import.ail` | ‚úÖ Pass |  |
| `type_classes_working_reference.ail` | ‚ùå Fail | Error: type error in examples/type_classes_work... |
| `typeclasses.ail` | ‚ùå Fail | Error: type error in examples/typeclasses (decl... |
| `v3_3/imports.ail` | ‚úÖ Pass |  |
| `v3_3/imports_basic.ail` | ‚úÖ Pass |  |
| `v3_3/math/gcd.ail` | ‚ùå Fail | Error: entrypoint 'main' not found in module |

<!-- EXAMPLES_STATUS_END -->

---

## Documentation

üìñ **[Complete Documentation](https://sunholo-data.github.io/ailang/)** - Visit our full documentation site

**Quick Links:**
- **[Getting Started](https://sunholo-data.github.io/ailang/docs/guides/getting-started)** - Installation and tutorial
- **[Language Guide](https://sunholo-data.github.io/ailang/docs/category/language-guide)** - Syntax and features
- **[REPL Guide](https://sunholo-data.github.io/ailang/docs/guides/repl)** - Interactive development
- **[Benchmarks](https://sunholo-data.github.io/ailang/docs/benchmarks/performance)** - AI code generation performance
- **[Examples](https://sunholo-data.github.io/ailang/docs/examples/overview)** - Code examples and patterns

---

## Development

```bash
# Build and install
make install

# Run tests
make test

# Start REPL
make repl

# Run example
make run FILE=examples/hello.ail

# Auto-rebuild on changes
make watch-install

# Check coverage
make test-coverage-badge

# AI Evaluation & Design Generation
make eval-suite          # Run AI benchmarks (AILANG vs Python)
make eval-report         # Generate evaluation report
make eval-analyze        # Analyze failures, generate design docs
```

See the [Development Guide](https://sunholo-data.github.io/ailang/docs/guides/development) for detailed instructions.

---

## üìö Specification Reference

- **Core**: `/internal/types/`, `/internal/eval/`
- **Effects**: `/internal/effects/`
- **Builtins**: `/internal/builtins/spec.go`
- **Standard Library**: `/stdlib/std/*`
- **Design Docs**: `/design_docs/`

---

## Project Structure

```
ailang/
‚îú‚îÄ‚îÄ cmd/ailang/         # CLI entry point
‚îú‚îÄ‚îÄ internal/           # Core implementation
‚îÇ   ‚îú‚îÄ‚îÄ repl/           # Interactive REPL
‚îÇ   ‚îú‚îÄ‚îÄ lexer/          # Tokenizer
‚îÇ   ‚îú‚îÄ‚îÄ parser/         # Parser
‚îÇ   ‚îú‚îÄ‚îÄ types/          # Type system
‚îÇ   ‚îú‚îÄ‚îÄ eval/           # Evaluator
‚îÇ   ‚îú‚îÄ‚îÄ effects/        # Effect system runtime
‚îÇ   ‚îú‚îÄ‚îÄ builtins/       # Builtin registry
‚îÇ   ‚îî‚îÄ‚îÄ eval_harness/   # AI evaluation framework
‚îú‚îÄ‚îÄ stdlib/             # Standard library
‚îú‚îÄ‚îÄ examples/           # Example programs
‚îú‚îÄ‚îÄ docs/               # Documentation
‚îî‚îÄ‚îÄ design_docs/        # Design documents
```

---

## Contributing

AILANG is an experimental language in active development. Contributions are welcome! Please see the [Development Guide](https://sunholo-data.github.io/ailang/docs/guides/development) for guidelines.

---

## ‚öñÔ∏è License & Philosophy

AILANG is **open infrastructure for Cognitive DevOps** ‚Äî systems that write, test, and deploy themselves deterministically.

**Our design north star: build languages AIs enjoy using.**

Apache 2.0 - See [LICENSE](LICENSE) for details.

---

## Acknowledgments

AILANG draws inspiration from:
- **Haskell** (type system, purity)
- **OCaml** (module system, effects)
- **Rust** (capability-based security)
- **Idris/Agda** (reflection and metaprogramming)

---

*For AI agents: This is a deterministic functional language with Hindley-Milner type inference, algebraic effects, and explicit effect tracking. The REPL is fully functional. Module execution works with capability-based security. See [CLAUDE.md](CLAUDE.md) and [Complete Documentation](https://sunholo-data.github.io/ailang/) for exact capabilities.*

---

# Guide: getting-started.md

# Getting Started with AILANG

## ü§ñ For AI Agents: Quick Integration

**AILANG is designed for AI-assisted development.** To integrate AILANG into your AI coding agent:

### Step 1: Install AILANG

```bash
# macOS (Apple Silicon)
curl -L https://github.com/sunholo-data/ailang/releases/latest/download/ailang-darwin-arm64.tar.gz | tar -xz
sudo mv ailang /usr/local/bin/

# macOS (Intel)
curl -L https://github.com/sunholo-data/ailang/releases/latest/download/ailang-darwin-amd64.tar.gz | tar -xz
sudo mv ailang /usr/local/bin/

# Linux
curl -L https://github.com/sunholo-data/ailang/releases/latest/download/ailang-linux-amd64.tar.gz | tar -xz
sudo mv ailang /usr/local/bin/

# Verify
ailang --version
```

### Step 2: Load the AILANG Teaching Prompt

**Provide your AI agent with the current AILANG syntax guide:**

üìñ **[AILANG v0.3.8 Teaching Prompt](/docs/prompts/v0.3.8)**

This prompt teaches AI models:
- ‚úÖ Correct AILANG syntax (not Python/Rust/JavaScript)
- ‚úÖ Pure functional programming with recursion
- ‚úÖ Module system with effects (IO, FS, Clock, Net)
- ‚úÖ Record updates, pattern matching, ADTs
- ‚úÖ Auto-imported std/prelude (no manual imports for comparisons)

**Copy the full prompt** from [prompts/v0.3.8.md](/docs/prompts/v0.3.8) and include it in your AI agent's system prompt or context.

### Step 3: Test AI Code Generation

Ask your AI agent to write AILANG code:

```
Using AILANG v0.3.8, write a program that reads a file and counts the number of lines.

[Include full v0.3.8 prompt here]
```

**Expected output:**
```typescript
module benchmark/solution

import std/io (println)
import std/fs (readFile)

export func countLines(content: string) -> int {
  -- Implementation using recursion
  ...
}

export func main() -> () ! {IO, FS} {
  let content = readFile("data.txt");
  println("Lines: " ++ show(countLines(content)))
}
```

### Step 4: Run AI-Generated Code

```bash
ailang run --caps IO,FS --entry main solution.ail
```

### AI Success Metrics (v0.3.8)

**Current benchmark results:**
- **AILANG**: 49.1% success rate (28/57 benchmarks)
- **Improvement**: +10.5% from v0.3.7 (38.6% ‚Üí 49.1%)
- **Best model**: Claude Sonnet 4.5 (68.4% across all tasks)

See [AI Prompt Guide](/docs/guides/ai-prompt-guide) for detailed instructions.

---

## üë§ For Human Developers: Manual Installation

### Installation Options

#### From GitHub Releases (Recommended)

Download pre-built binaries from the [latest release](https://github.com/sunholo-data/ailang/releases/latest).

#### From Source (For Development)

```bash
git clone https://github.com/sunholo/ailang.git
cd ailang
make install
ailang --version
```

**Add Go bin to PATH:**
```bash
# For zsh (macOS default)
echo 'export PATH="$HOME/go/bin:$PATH"' >> ~/.zshrc
source ~/.zshrc
```

**Development workflow:**
```bash
make quick-install    # Fast rebuild after changes
make test            # Run tests
make verify-examples # Test example files
```

## Quick Start

### Hello World (v0.3.8 Module Syntax)

```typescript
-- hello.ail
module examples/hello

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello, AILANG!")
}
```

Run it:
```bash
ailang run --caps IO --entry main hello.ail
```

**Note**: Flags must come BEFORE the filename when using `ailang run`.

### Working with Values

```typescript
-- values.ail
let name = "AILANG" in
let version = 0.0 in
print("Welcome to " ++ name ++ " v" ++ show(version))
```

### Lambda Expressions

```typescript
-- Lambda syntax with closures
let add = \x y. x + y in
let add5 = add(5) in  -- Partial application
print("Result: " ++ show(add5(3)))  -- Result: 8

-- Higher-order functions
let compose = \f g x. f(g(x)) in
let double = \x. x * 2 in
let inc = \x. x + 1 in
let doubleThenInc = compose(inc)(double) in
print("Composed: " ++ show(doubleThenInc(5)))  -- Composed: 11
```

### Using the REPL

Start the interactive REPL:
```bash
ailang repl
```

Try some expressions:
```typescript
Œª> 1 + 2
3 :: Int

Œª> "Hello " ++ "World"
Hello World :: String

Œª> let double = \x. x * 2 in double(21)
42 :: Int

Œª> :type \x. x + x
\x. x + x :: ‚àÄŒ±. Num Œ± ‚áí Œ± ‚Üí Œ±

Œª> :quit
```

## Working Examples (v0.3.8)

The following examples are confirmed to work with the current implementation:

**Recursion**:
- `examples/recursion_factorial.ail` - Recursive factorial function
- `examples/recursion_fibonacci.ail` - Fibonacci sequence
- `examples/recursion_quicksort.ail` - Quicksort implementation
- `examples/recursion_mutual.ail` - Mutual recursion (isEven/isOdd)

**Records**:
- `examples/micro_record_person.ail` - Record literals and field access
- `examples/test_record_subsumption.ail` - Record subsumption

**Effects**:
- `examples/test_effect_io.ail` - IO effect examples
- `examples/test_effect_fs.ail` - File system operations
- `examples/micro_clock_measure.ail` - Clock effect (time, sleep)
- `examples/micro_net_fetch.ail` - Net effect (HTTP GET)

**Pattern Matching & ADTs**:
- `examples/adt_simple.ail` - Algebraic data types
- `examples/adt_option.ail` - Option type with pattern matching
- `examples/guards_basic.ail` - Pattern guards

**Blocks**:
- `examples/micro_block_if.ail` - Block expressions with if
- `examples/micro_block_seq.ail` - Sequential blocks
- `examples/block_recursion.ail` - Recursion in blocks

See [examples/STATUS.md](https://github.com/sunholo-data/ailang/blob/main/examples/STATUS.md) for the complete list of 48+ working examples.

## Next Steps

- Learn the [language syntax](../reference/language-syntax.md)
- Explore [REPL commands](../reference/repl-commands.md)
- Check [implementation status](../reference/implementation-status.md)
- Read the [development guide](./development.md)
---

# Guide: ai-prompt-guide.md

# AI Prompt Guide: Teaching AILANG to Language Models

**Purpose**: This document points to the canonical AILANG teaching prompt for AI models.

**KPI**: One of AILANG's key success metrics is **"teachability to AI"** - how easily can an LLM learn to write correct AILANG code from a single prompt?

---

## Canonical Prompt (v0.3.8)

**The official AILANG teaching prompt is maintained at**:

### üìñ [prompts/v0.3.8.md](../prompts/v0.3.8)

This prompt is:
- ‚úÖ **Validated through eval benchmarks** - Tested across GPT-5, Gemini 2.5 Pro, Claude Sonnet 4.5
- ‚úÖ **Up-to-date with v0.3.8 features** - Record updates, auto-import prelude, anonymous functions
- ‚úÖ **Versioned with SHA-256 hashing** - Reproducible eval results
- ‚úÖ **Actively maintained** - Updated as language evolves

---

## Quick Reference

**Current version**: v0.3.8 (AI Usability Improvements)

**What works in v0.3.8**:
- ‚úÖ Module execution with effects
- ‚úÖ Recursion (self-recursive and mutually-recursive)
- ‚úÖ Block expressions (`{ stmt1; stmt2; result }`)
- ‚úÖ Records (literals + field access + **updates**)
- ‚úÖ **Multi-line ADTs** `type Tree = | Leaf | Node` - NEW in v0.3.8!
- ‚úÖ **Record update syntax** `{base | field: value}`
- ‚úÖ **Auto-import std/prelude** - No imports needed for comparisons
- ‚úÖ **Anonymous functions** `func(x: int) -> int { x * 2 }`
- ‚úÖ **Numeric conversions** `intToFloat`, `floatToInt`
- ‚úÖ Effects: IO, FS, Clock, Net
- ‚úÖ Type classes, ADTs, pattern matching
- ‚úÖ REPL with full type checking

**What doesn't work yet**:
- ‚ùå Pattern guards (parsed but not evaluated)
- ‚ùå Error propagation operator `?`
- ‚ùå Deep let nesting (4+ levels)
- ‚ùå Typed quasiquotes
- ‚ùå CSP concurrency

**For complete details**, see [prompts/v0.3.8.md](/docs/prompts/v0.3.8)

---

## Using the Prompt

### For AI Code Generation

When asking an AI model (Claude, GPT, Gemini) to write AILANG code, provide the full prompt from [prompts/v0.3.8.md](/docs/prompts/v0.3.8).

**Example usage**:
```
I need you to write AILANG code to solve this problem: [problem description]

First, read this AILANG syntax guide:
[paste contents of prompts/v0.3.8.md]

Now write the code.
```

### For Eval Benchmarks

The eval harness automatically loads the correct prompt version:

```yaml
# benchmarks/example.yml
id: example_task
languages: ["ailang", "python"]
prompt_files:
  ailang: "prompts/v0.3.8.md"
  python: "prompts/python.md"
task_prompt: |
  Write a program that [task description]
```

See [benchmarks/README.md](https://github.com/sunholo-data/ailang/tree/main/benchmarks) for details.

---

## Current Prompt

**Version**: v0.3.8 - [View full prompt](/docs/prompts/v0.3.8)

**Features**:
- Multi-line ADTs: `type Tree = | Leaf | Node` (v0.3.8)
- Record updates: `{base | field: value}` (v0.3.6)
- Auto-import std/prelude (v0.3.6)
- Anonymous functions: `func(x: int) -> int { x * 2 }` (v0.3.5)
- Numeric conversions: `intToFloat`, `floatToInt` (v0.3.5)
- Full module system with effects

**Why prompt quality matters**:
- Better AI code generation
- Reproducible eval results
- Consistent teaching across models

---

## Eval Results

**Current success rates** (v0.3.8 prompt on v0.3.8):
- **Overall**: 49.1% AILANG success rate (vs 82.5% Python baseline)
- **Claude Sonnet 4.5**: 68.4% best performer
- **Gemini 2.5 Pro**: 65.8%
- **GPT-5**: 63.2%

**Improvement trajectory**:
- v0.3.7: 38.6% ‚Üí v0.3.8: 49.1% (+10.5% improvement)
- Fixed benchmarks: pattern_matching_complex, adt_option, error_handling, and more

See [Benchmark Dashboard](/docs/benchmarks/performance) for detailed metrics.

---

## Contributing Improvements

If you find ways to improve the AILANG teaching prompt:

1. **Test your changes** with the eval harness:
   ```bash
   ailang eval --benchmark all --model gpt-4o-mini
   ```

2. **Measure impact**:
   ```bash
   tools/compare_prompts.sh old_version new_version
   ```

3. **Update the prompt** at `prompts/v0.3.8.md` (or create new version)

4. **Document changes** in `prompts/versions.json` (future enhancement)

---

## See Also

- **[CLAUDE.md](https://github.com/sunholo-data/ailang/blob/main/CLAUDE.md)** - Instructions for AI assistants working on AILANG development
- **[examples/](https://github.com/sunholo-data/ailang/tree/main/examples)** - Working AILANG code examples
- **[Language Reference](/docs/reference/language-syntax)** - Complete AILANG syntax guide
- **[benchmarks/](https://github.com/sunholo-data/ailang/tree/main/benchmarks)** - Eval harness benchmark suite

---

*Last updated: October 15, 2025 for v0.3.8/v0.3.8*

---

# Guide: module_execution.md

# Module Execution Guide

**AILANG v0.2.0** - Complete guide to executing modules with entrypoint functions

---

## Overview

AILANG v0.2.0 introduces the **Module Execution Runtime** (M-R1), enabling you to run modules with exported entrypoint functions. This guide covers basic usage, requirements, and common patterns.

## Quick Start

### Basic Usage

```bash
# Run a module with a main() function
ailang --entry main run examples/hello.ail

# Run with a different entrypoint
ailang --entry greet run examples/demo.ail

# Pass arguments via JSON
ailang --entry process --args-json '{"input": "data"}' run examples/processor.ail
```

### Minimal Example

```typescript
-- hello.ail
module examples/hello

export func main() -> () {
    _io_println("Hello from AILANG!")
}
```

Run with:
```bash
ailang --entry main run examples/hello.ail
# Output: Hello from AILANG!
```

---

## Module Structure

### Anatomy of an Executable Module

```typescript
-- my_module.ail
module examples/my_module
import stdlib/std/option (Some, None)

-- Private helper (not exported)
func helper(x: int) -> int {
    x * 2
}

-- Exported entrypoint (0 arguments)
export func main() -> int {
    helper(21)
}

-- Exported entrypoint (1 argument)
export func process(input: {value: int}) -> int {
    helper(input.value)
}
```

### Module Declaration

- **Required**: Every executable module must have a `module` declaration
- **Path matching**: Module path must match file path
  - File: `examples/demo.ail` ‚Üí Module: `module examples/demo`
  - File: `src/utils/math.ail` ‚Üí Module: `module src/utils/math`

---

## Entrypoint Functions

### Requirements

An entrypoint function must:
1. ‚úÖ Be **exported** from the module (`export func`)
2. ‚úÖ Be a **function** (not a value)
3. ‚úÖ Have **0 or 1 parameters** (v0.2.0 limitation)
4. ‚úÖ Be specified via `--entry <name>` flag

### Supported Arities

#### 0-Argument Functions

```typescript
export func main() -> int {
    42
}
```

Run with:
```bash
ailang --entry main run module.ail
# Output: 42
```

#### 1-Argument Functions

```typescript
export func greet(name: string) -> () {
    _io_println(name)
}
```

Run with:
```bash
ailang --entry greet --args-json '"World"' run module.ail
# Output: World
```

#### Record Parameters (Recommended Pattern)

```typescript
export func process(params: {input: string, count: int}) -> () {
    _io_println(params.input)
}
```

Run with:
```bash
ailang --entry process --args-json '{"input": "data", "count": 5}' run module.ail
# Output: data
```

### Multi-Argument Workaround

Functions with 2+ parameters are not directly supported. Wrap parameters in a record:

‚ùå **Not supported:**
```typescript
export func add(x: int, y: int) -> int {
    x + y
}
```

‚úÖ **Supported pattern:**
```typescript
export func add(params: {x: int, y: int}) -> int {
    params.x + params.y
}
```

Run with:
```bash
ailang --entry add --args-json '{"x": 10, "y": 32}' run module.ail
# Output: 42
```

---

## stdlib Functions

### IO Builtins

AILANG v0.2.0 provides three builtin IO functions:

#### `_io_print(s: string) -> ()`

Print a string without a newline.

```typescript
export func main() -> () {
    _io_print("Hello")
    _io_print(" ")
    _io_print("World")
}
```

Output: `Hello World`

#### `_io_println(s: string) -> ()`

Print a string with a newline.

```typescript
export func main() -> () {
    _io_println("Line 1")
    _io_println("Line 2")
}
```

Output:
```
Line 1
Line 2
```

#### `_io_readLine() -> string`

Read a line from stdin (blocking).

```typescript
export func main() -> () {
    _io_println("Enter your name:")
    let name = _io_readLine() in
    _io_println(name)
}
```

---

## Return Values and Output

### Printing Results

- **Non-Unit values**: Printed to stdout automatically
- **Unit values**: Silent (no output)

```typescript
-- Returns int, prints to stdout
export func compute() -> int {
    42
}

-- Returns unit, no output
export func greet() -> () {
    _io_println("Hello")
}
```

### Exit Codes

- **Success**: Exit code 0
- **Runtime error**: Exit code 1
- **Type error**: Exit code 1
- **Parse error**: Exit code 1

---

## Effects and Type Checking

### Effect Annotations (v0.2.0)

Effects are **type-checked** but **not enforced** at runtime in v0.2.0.

```typescript
-- Effect annotation required for IO operations
export func main() -> () ! {IO} {
    _io_println("Hello")
}
```

**Note**: Runtime effect enforcement (capability checks) is planned for v0.3.0 (M-R2).

### Pure Functions

Pure functions have no effect annotation:

```typescript
export pure func add(x: int, y: int) -> int {
    x + y
}
```

---

## Common Patterns

### Simple Script

```typescript
module scripts/hello

export func main() -> () {
    _io_println("Hello from AILANG!")
}
```

### CLI Tool with Arguments

```typescript
module tools/greeter

export func greet(config: {name: string, greeting: string}) -> () {
    _io_print(config.greeting)
    _io_print(" ")
    _io_println(config.name)
}
```

Usage:
```bash
ailang --entry greet --args-json '{"name":"Alice","greeting":"Hello"}' run tools/greeter.ail
```

### Interactive Program

```typescript
module apps/echo

export func main() -> () {
    _io_println("Enter text:")
    let input = _io_readLine() in
    _io_println(input)
}
```

---

## Error Handling

### Common Errors

#### Entrypoint Not Found

```
Error: entrypoint 'main' not found in module examples/demo
  Available exports: greet, process
```

**Solution**: Use `--entry <name>` with an exported function name.

#### Wrong Arity

```
Error: entrypoint 'process' takes 2 parameters. v0.2.0 supports 0 or 1.
  Suggestion: wrap as 'wrapper(p:{...}) -> ...' and pass --args-json
```

**Solution**: Wrap parameters in a record type.

#### Not a Function

```
Error: entrypoint 'config' is not a function (got RecordValue)
```

**Solution**: Only functions can be entrypoints. Values cannot be executed.

#### Module Path Mismatch

```
Error: module declaration 'hello' doesn't match canonical path 'examples/hello'
Suggestions:
  1. Rename module to: module examples/hello
  2. Move file to: hello.ail
```

**Solution**: Ensure module path matches file path.

---

## Known Limitations (v0.2.0)

### Supported ‚úÖ
- 0-argument and 1-argument entrypoints
- Builtin IO functions (`_io_print`, `_io_println`, `_io_readLine`)
- JSON argument parsing
- Module imports and dependency resolution
- Type checking with effects
- Pure functions

### Not Yet Supported ‚è≥
- **Multi-argument functions** (2+ parameters)
  - Workaround: Use record parameter
- **Effect enforcement** at runtime
  - Effects are type-checked only
  - Runtime capability checks coming in M-R2 (v0.3.0)
- **Pattern matching guards**
  - Planned for M-P4
- **Multi-statement function bodies**
  - Parser limitation, planned for future release

---

## Advanced Topics

### Module Dependencies

Modules can import other modules:

```typescript
-- math/utils.ail
module math/utils

export func double(x: int) -> int {
    x * 2
}
```

```typescript
-- app/main.ail
module app/main
import math/utils (double)

export func main() -> () {
    let result = double(21) in
    _io_println(show(result))
}
```

### Encapsulation

Only **exported** bindings are accessible from other modules:

```typescript
module lib/secret

-- Private (not accessible from imports)
func private_helper() -> int {
    42
}

-- Public (accessible via import)
export func public_api() -> int {
    private_helper()
}
```

---

## CLI Reference

### Flags

- `--entry <name>`: Specify entrypoint function (required for modules)
- `--args-json <json>`: Pass arguments as JSON (for 1-arg functions)
- `--runner <mode>`: Choose execution runner (`module` or `fallback`)
- `--no-print`: Suppress output (exit code only)

### Examples

```bash
# Basic execution
ailang --entry main run app.ail

# With arguments
ailang --entry process --args-json '{"data": [1,2,3]}' run app.ail

# Use fallback runner (pre-M-R1 execution)
ailang --runner fallback run app.ail

# Exit code only (no output)
ailang --entry main --no-print run app.ail
echo $?  # Check exit code
```

---

## Troubleshooting

### Module won't load

1. Check module path matches file path
2. Ensure all imports exist
3. Verify no circular imports
4. Check for syntax errors: `ailang check module.ail`

### Function won't execute

1. Ensure function is exported: `export func ...`
2. Check arity (0 or 1 parameters only)
3. Verify entrypoint name: `--entry <name>`
4. Check type errors: `ailang check module.ail`

### No output

- Functions returning `()` (Unit) produce no output
- Use `_io_println()` for explicit output
- Check stderr for errors: `ailang ... 2>&1 | grep Error`

---

## What's Next?

### v0.3.0 (M-R2: Effect Runtime)
- Runtime effect enforcement
- Capability-based security
- IO and FS capabilities
- Deny-by-default model

### v0.4.0 (Pattern Matching Polish)
- Guards in match expressions
- Exhaustiveness checking
- Decision tree optimization

### Future
- Multi-statement function bodies
- Async/await concurrency
- Quasiquotes (SQL, HTML, regex)
- Training data export

---

## Resources

- **Examples**: `examples/` directory
- **stdlib**: `stdlib/std/io.ail`, `stdlib/std/option.ail`
- **Design docs**: `design_docs/20251002/m_r1_module_execution.md`
- **CHANGELOG**: Track new features and breaking changes

---

**Version**: v0.2.0-rc1
**Last Updated**: October 2, 2025
**Status**: Complete

---

# Guide: wasm-integration.md

---
id: wasm-integration
title: WebAssembly Integration Guide
sidebar_label: WASM Integration
---

# WebAssembly Integration Guide

AILANG can run entirely in the browser using WebAssembly, enabling interactive demonstrations and online playgrounds without requiring server-side execution.

## Overview

The AILANG WebAssembly build provides:

- **Full Language Support**: Complete AILANG interpreter compiled to WASM
- **Client-Side Execution**: No server needed after initial load
- **Small Bundle Size**: ~5.7MB uncompressed (~1-2MB with gzip)
- **React Integration**: Ready-made component for easy integration
- **Offline Capable**: Works offline after first load

## Quick Start

### 1. Build WASM Binary

```bash
cd ailang
make build-wasm
```

This produces `bin/ailang.wasm`.

### 2. Integration Options

#### Option A: Docusaurus (Recommended)

1. Copy assets:
```bash
cp bin/ailang.wasm docs/static/wasm/
cp "$(go env GOROOT)/misc/wasm/wasm_exec.js" docs/static/wasm/
cp web/ailang-repl.js docs/src/components/
cp web/AilangRepl.jsx docs/src/components/
```

2. Add to `docusaurus.config.js`:
```javascript
module.exports = {
  scripts: [
    {
      src: '/wasm/wasm_exec.js',
      async: false,
    },
  ],
  // ... rest of config
};
```

3. Use in MDX:
```mdx
---
title: Try AILANG
---

import AilangRepl from '@site/src/components/AilangRepl';

<AilangRepl />
```

#### Option B: Vanilla HTML

```html
<!DOCTYPE html>
<html>
<head>
  <title>AILANG REPL</title>
  <script src="wasm_exec.js"></script>
  <script src="ailang-repl.js"></script>
</head>
<body>
  <div id="repl-container"></div>

  <script>
    const repl = new AilangREPL();

    repl.init('/path/to/ailang.wasm').then(() => {
      console.log('AILANG ready!');

      // Evaluate expressions
      const result = repl.eval('1 + 2');
      console.log(result); // "3 :: Int"
    });
  </script>
</body>
</html>
```

#### Option C: React (Custom)

```jsx
import { useEffect, useState } from 'react';
import AilangREPL from './ailang-repl';

export default function MyReplComponent() {
  const [repl, setRepl] = useState(null);
  const [result, setResult] = useState('');

  useEffect(() => {
    const replInstance = new AilangREPL();
    replInstance.init('/wasm/ailang.wasm').then(() => {
      setRepl(replInstance);
    });
  }, []);

  const handleEval = (input) => {
    if (repl) {
      const output = repl.eval(input);
      setResult(output);
    }
  };

  return (
    <div>
      <input onKeyDown={(e) => {
        if (e.key === 'Enter') handleEval(e.target.value);
      }} />
      <pre>{result}</pre>
    </div>
  );
}
```

## JavaScript API

### `AilangREPL` Class

```javascript
const repl = new AilangREPL();
```

#### Methods

##### `init(wasmPath)`

Initialize the WASM module.

```javascript
await repl.init('/wasm/ailang.wasm');
```

**Parameters:**
- `wasmPath` (string): Path to `ailang.wasm` file

**Returns:** Promise that resolves when REPL is ready

##### `eval(input)`

Evaluate an AILANG expression.

```javascript
const result = repl.eval('1 + 2');
// Returns: "3 :: Int"
```

**Parameters:**
- `input` (string): AILANG code to evaluate

**Returns:** Result string (includes value and type)

##### `command(cmd)`

Execute a REPL command.

```javascript
const type = repl.command(':type \x. x');
// Returns: "\x. x :: a -> a"
```

**Parameters:**
- `cmd` (string): REPL command (e.g., `:type`, `:help`)

**Returns:** Command output string

##### `reset()`

Reset the REPL environment.

```javascript
repl.reset();
```

**Returns:** Status message

##### `onReady(callback)`

Register callback for when REPL is ready.

```javascript
repl.onReady(() => {
  console.log('REPL initialized!');
});
```

## REPL Commands

The WebAssembly REPL supports the same commands as the CLI:

| Command | Description |
|---------|-------------|
| `:help` | Show available commands |
| `:type <expr>` | Display expression type |
| `:instances` | Show type class instances |
| `:reset` | Clear environment |

## Limitations

The browser version has these limitations compared to the CLI:

| Feature | CLI | WASM |
|---------|-----|------|
| Expression evaluation | ‚úÖ | ‚úÖ |
| Type inference | ‚úÖ | ‚úÖ |
| Pattern matching | ‚úÖ | ‚úÖ |
| Type classes | ‚úÖ | ‚úÖ |
| File I/O (`FS` effect) | ‚úÖ | ‚ùå |
| Module imports | ‚úÖ | ‚ùå |
| History persistence | ‚úÖ | ‚ùå |

## Deployment

### Static Hosting

WASM files work on any static host:

```bash
# Build and deploy
make build-wasm
cp bin/ailang.wasm your-site/static/wasm/
# Deploy your-site/ to Netlify/Vercel/GitHub Pages
```

### CDN Optimization

1. **Enable Compression:**
```nginx
# nginx.conf
gzip_types application/wasm;
```

2. **Set Cache Headers:**
```nginx
location ~* \.wasm$ {
  add_header Cache-Control "public, max-age=31536000, immutable";
}
```

3. **Use HTTP/2:**
WASM benefits from HTTP/2 multiplexing for faster loading.

### Performance Tips

- **Lazy Loading**: Only load WASM when user navigates to playground
- **Service Worker**: Cache WASM for offline use
- **CDN**: Serve from edge locations
- **Preload**: Add `<link rel="preload" href="ailang.wasm" as="fetch">`

## CI/CD Integration

### GitHub Actions

WASM is automatically built and released:

```yaml
# .github/workflows/release.yml (excerpt)
- name: Build WASM binary
  run: make build-wasm

- name: Create Release
  uses: softprops/action-gh-release@v2
  with:
    files: bin/ailang-wasm.tar.gz
```

### Docusaurus Deployment

WASM is included in documentation builds:

```yaml
# .github/workflows/docusaurus-deploy.yml (excerpt)
- name: Build WASM binary
  run: make build-wasm

- name: Copy static assets
  run: |
    cp bin/ailang.wasm docs/static/wasm/
    cp web/ailang-repl.js docs/src/components/
```

## Troubleshooting

### "WebAssembly not supported"

**Solution**: Use a modern browser:
- Chrome 57+
- Firefox 52+
- Safari 11+
- Edge 16+

### "Failed to load AILANG WASM"

**Solutions**:
1. Check browser console for network errors
2. Verify `ailang.wasm` path is correct
3. Ensure `wasm_exec.js` loaded first
4. Check CORS headers if serving from different domain

### "REPL not initialized"

**Solution**: Wait for `init()` promise or use `onReady()`:

```javascript
repl.init('/wasm/ailang.wasm').then(() => {
  // Safe to use repl here
  repl.eval('1 + 2');
});
```

### Slow Loading

**Solutions**:
1. Enable gzip compression (reduces to ~1-2MB)
2. Use CDN
3. Add preload hints:
   ```html
   <link rel="preload" href="/wasm/ailang.wasm" as="fetch" crossorigin>
   ```

## Examples

See:
- [Live Playground](/docs/playground) - Try it now
- [Integration Example](https://github.com/sunholo-data/ailang/blob/main/web/example.mdx)
- [Component Source](https://github.com/sunholo-data/ailang/blob/main/web/AilangRepl.jsx)

## Next Steps

- [Try the Playground](/docs/playground)
- [Download Latest Release](https://github.com/sunholo-data/ailang/releases/latest)
- [Report Issues](https://github.com/sunholo-data/ailang/issues)

---

# AI Teaching Prompt (Latest: v0.3.12)

# AILANG AI Teaching Prompt (v0.3.12)

**CRITICAL: You MUST write code in AILANG syntax. This is NOT Python, NOT Rust, NOT JavaScript.**

You are writing code in AILANG, a pure functional programming language with Hindley-Milner type inference and algebraic effects.

## ‚ö†Ô∏è CRITICAL: What AILANG is NOT

**DO NOT generate code like this - these will FAIL:**

‚ùå **WRONG - Single-line statements without module:**
```
PRINT 5 % 3
```
Every program MUST start with `module benchmark/solution`

‚ùå **WRONG - Imperative style with loops:**
```python
loop {
  x = read();
  if (x == "") { break; }
  println(x);  # WRONG - no loops in AILANG
}
```
AILANG has NO `loop`, `break`, `while`, `for`. Use recursion!

‚ùå **WRONG - Python/JavaScript syntax:**
```python
for i in range(10):
    println(i)  # WRONG - no for loops
```
This is not Python. Use functional recursion.

‚ùå **WRONG - Assignment statements:**
```
x = 10;
x = x + 1;
```
No mutable variables. Use `let` bindings.

**‚úÖ CORRECT - Functional AILANG:**
```ailang
module benchmark/solution

import std/io (println)

export func loop(n: int) -> () ! {IO} {
  if n > 10
  then ()
  else {
    println(show(n));
    loop(n + 1)
  }
}

export func main() -> () ! {IO} {
  loop(1)
}
```

## MANDATORY Structure

**EVERY AILANG program MUST have this structure:**

1. **Module declaration**: `module benchmark/solution` (first line)
2. **Imports**: `import std/io (println)` (if using IO)
3. **Functions**: `export func main() -> () ! {IO} { ... }`

**IMPORTANT SYNTAX RULES:**
- Use `func` NOT `fn`, `function`, or `def`
- Use `type Name[a] = Constructor(a) | Constructor2` NOT `type Name { }` or `enum`
- NO namespace syntax (`::`), just use constructor names directly
- Semicolons REQUIRED between statements in blocks
- Pattern matching uses `=>` NOT `:` or `->`
- NO `for`, `while`, `var`, `const`, `let mut`, or any imperative constructs

## Current Version: v0.3.12 (October 2025)

**‚úÖ WHAT WORKS:**
- ‚úÖ **`show()` function** - NEW v0.3.12: Polymorphic `show(value)` converts ANY value to string! Use for printing numbers, bools, ADTs
- ‚úÖ **Module declarations** - `module path/to/module`
- ‚úÖ **Function declarations** - `export func name(params) -> Type { body }`
- ‚úÖ **Anonymous functions** - `func(x: int) -> int { x * 2 }` (inline lambdas)
- ‚úÖ **Recursive lambdas** - `letrec fib = \n. if n < 2 then n else fib(n-1) + fib(n-2) in ...`
- ‚úÖ **Numeric conversions** - `intToFloat(42)`, `floatToInt(3.14)`
- ‚úÖ **Auto-import std/prelude** - Zero imports needed for comparisons (`<`, `>`, `==`, `!=`)
- ‚úÖ **Record updates** - `{base | field: value}` functional updates
- ‚úÖ **Multi-line ADTs** - Optional leading pipe `type Tree = | Leaf | Node`
- ‚úÖ **Import statements** - `import std/io (println)`, `import std/clock (now, sleep)`, `import std/net (httpGet)`
- ‚úÖ **Pattern matching** - Constructors, tuples, lists, wildcards, **guards** (`if` conditions)
- ‚úÖ **Effect system** - `! {IO, FS, Clock, Net}` for side effects with capability security
- ‚úÖ **ADTs** - Algebraic data types: `type Option[a] = Some(a) | None`
- ‚úÖ **Recursion** - Self-recursive and mutually-recursive functions with stack overflow protection
- ‚úÖ **Block expressions** - `{ stmt1; stmt2; result }` for sequencing
- ‚úÖ **Records** - Record literals, field access, updates, subsumption
- ‚úÖ **Type system fixes** - Modulo operator (`%`) and float comparison (`==`) both work correctly
- ‚úÖ **JSON encoding** - `std/json` module with `Json` ADT and `encode()` function
- ‚úÖ **HTTP headers** - `httpRequest()` with custom headers and Result-based error handling

**‚ö†Ô∏è LIMITATIONS:**
- ‚ö†Ô∏è NO `for`/`while` loops - use recursion
- ‚ö†Ô∏è NO `var` - everything is immutable
- ‚ö†Ô∏è NO error propagation operator `?` (yet)
- ‚ö†Ô∏è NO custom HTTP headers (OpenAI/Claude APIs blocked until v0.4.0)
- ‚ö†Ô∏è NO list spread patterns `[x, ...rest]` (yet) - use Cons constructor
- ‚ö†Ô∏è `show` is a builtin - do NOT import it

## üìã IMPORT CHECKLIST - Read Before Writing Code!

**NEW in v0.3.6: std/prelude is AUTO-IMPORTED!**

**You NO LONGER need to import Ord or Eq** for comparison operators:

```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  if 5 > 3 then println("Works!") else ()  // ‚úÖ NO import needed!
}
```

**Common imports:**
- `println`, `print` ‚Üí `import std/io (println)`
- `readFile`, `writeFile` ‚Üí `import std/fs (readFile, writeFile)`
- `now`, `sleep` ‚Üí `import std/clock (now, sleep)`
- `httpGet`, `httpPost` ‚Üí `import std/net (httpGet, httpPost)`
- `httpRequest` (NEW) ‚Üí `import std/net (httpRequest)` for custom headers
- JSON encoding (NEW) ‚Üí `import std/json (encode, jo, ja, kv, js, jnum)`
- `show` ‚Üí builtin, **DO NOT IMPORT**
- `<`, `>`, `<=`, `>=`, `==`, `!=` ‚Üí **AUTO-IMPORTED, NO IMPORT NEEDED!**

**IMPORTANT**: If you see error "No instance for Ord" or "No instance for Eq", you may have set `AILANG_NO_PRELUDE=1`. This is rare - std/prelude is auto-imported by default.

## Module Structure

Every AILANG program must be a module with exported functions:

```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  println("Hello, World!")
}
```

**IMPORTANT**: Always use `module benchmark/solution` as the module name for benchmark programs.

## üÜï NEW in v0.3.12: `show()` Function

**CRITICAL: Use `show()` to convert ANY value to a string!**

The `show()` function is a polymorphic builtin that converts ANY value (int, float, bool, records, ADTs, lists) to a string representation:

```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  // ‚úÖ CORRECT - Use show() to convert numbers to strings
  println("Number: " ++ show(42));           // "Number: 42"
  println("Float: " ++ show(3.14));          // "Float: 3.14"
  println("Bool: " ++ show(true));           // "Bool: true"
  println("Result: " ++ show(5 % 3));        // "Result: 2"

  // ‚úÖ Works with ADTs
  let opt = Some(42);
  println("Option: " ++ show(opt));          // "Option: Some(42)"

  // ‚ùå WRONG - Don't try to concat numbers directly
  println("Number: " ++ 42);                 // ERROR: type mismatch
}
```

**When to use `show()`:**
- Converting numbers (int/float) to strings: `show(42)`, `show(3.14)`
- Converting booleans to strings: `show(true)`
- Converting ADT constructors: `show(Some(42))` ‚Üí `"Some(42)"`
- Converting lists: `show([1, 2, 3])` ‚Üí `"[1, 2, 3]"`
- Any time you need to print a non-string value

**Remember:**
- `show()` is a BUILTIN - **DO NOT IMPORT IT**
- Type signature: `show : ‚àÄŒ±. Œ± -> string`
- Always available, no import needed

## Functions

```ailang
-- Simple pure function
export func add(x: int, y: int) -> int {
  x + y
}

-- Function with effects (IO, FS)
export func greet(name: string) -> () ! {IO} {
  println("Hello, " ++ name)
}

-- Generic function
export func identity[a](x: a) -> a {
  x
}

-- Multi-statement body (SEMICOLONS REQUIRED!)
export func compute() -> int {
  let x = 10;
  let y = 20;
  x + y
}
```

## Anonymous Functions

Inline lambda expressions with familiar syntax:

```ailang
-- Anonymous function literal
let double = func(x: int) -> int { x * 2 }

-- With type inference
let add = func(x, y) { x + y }

-- With effects
let greet = func(name: string) -> () ! {IO} {
  println("Hello, " ++ name)
}

-- Higher-order functions
let apply = func(f: func(int) -> int, x: int) -> int { f(x) }
apply(func(n: int) -> int { n * 2 }, 5)  -- 10
```

**IMPORTANT**: Use `=>` for lambdas (`\x. body`), use `-> {` for func expressions.

## Recursive Lambdas

The `letrec` keyword enables recursive function definitions in expressions:

```ailang
-- Fibonacci using letrec
letrec fib = \n. if n < 2 then n else fib(n - 1) + fib(n - 2) in
fib(10)  -- 55

-- Factorial
letrec factorial = \n. if n == 0 then 1 else n * factorial(n - 1) in
factorial(5)  -- 120
```

**Use case**: Recursive functions in REPL or inside expressions without full function declarations.

## Numeric Conversions

Explicit type conversion builtins for int ‚Üî float:

```ailang
-- Int to Float
intToFloat(42)  -- 42.0

-- Float to Int (truncates towards zero)
floatToInt(3.14)   -- 3
floatToInt(-3.14)  -- -3

-- Mixed arithmetic (requires conversion)
let result = intToFloat(1) + 2.5  -- 3.5
```

**IMPORTANT**: AILANG does NOT do automatic numeric coercion. You MUST use these builtins.

## Block Expressions

Blocks allow sequencing statements with semicolons:

```ailang
export func demo() -> () ! {IO} {
  {
    println("First");
    println("Second");
    println("Third")
  }
}

-- Blocks are expressions - the last value is returned
export func compute() -> int {
  {
    let x = 10;
    let y = 20;
    x + y
  }
}
```

**CRITICAL**: Semicolons REQUIRED between statements! Missing semicolons will cause parse errors.

## Records (with NEW Update Syntax!)

Records are structural types with named fields:

```ailang
-- Record literal
let person = {name: "Alice", age: 30, city: "NYC"}

-- Field access
person.name    -- "Alice"
person.age     -- 30

-- Use in functions
export func describe(p: {name: string, age: int}) -> string {
  p.name ++ " is " ++ show(p.age)
}
```

**NEW in v0.3.6: Record Update Syntax!**

Functional record updates create a new record with specified fields changed:

```ailang
let person = {name: "Alice", age: 30, city: "NYC"};

-- Update one field
let older = {person | age: 31};
-- Result: {name: "Alice", age: 31, city: "NYC"}

-- Update multiple fields
let moved = {older | city: "SF", age: 32};
-- Result: {name: "Alice", age: 32, city: "SF"}

-- Complex base expressions work
let updated = {getRecord() | field: value};
let nested = {config.server | port: 8080};
```

**IMPORTANT**: Updates are immutable - they create NEW records, leaving originals unchanged!

## Algebraic Data Types (ADTs)

**‚úÖ CORRECT AILANG SYNTAX:**

```ailang
type Option[a] = Some(a) | None
type Result[a, e] = Ok(a) | Err(e)
type List[a] = Cons(a, List[a]) | Nil

export func getOrElse[a](opt: Option[a], default: a) -> a {
  match opt {
    Some(x) => x,
    None => default
  }
}
```

**NEW in v0.3.8: Multi-line ADTs with Optional Leading Pipe!**

```ailang
-- Single-line (traditional)
type Tree = Leaf(int) | Node(Tree, int, Tree)

-- Multi-line (NEW - optional leading pipe)
type Tree =
  | Leaf(int)
  | Node(Tree, int, Tree)

-- Also valid (no leading pipe on first variant)
type Tree =
  Leaf(int)
  | Node(Tree, int, Tree)
```

Both styles work identically! Use multi-line for complex ADTs with many variants.

**‚ùå WRONG - This is Rust/other languages, NOT AILANG:**
```rust
type Option {        // ‚ùå Wrong - no { } braces
  Some(value)        // ‚ùå Wrong - not AILANG syntax
  None
}

Option::Some(42)     // ‚ùå Wrong - AILANG has no :: operator
fn divide(a, b) { }  // ‚ùå Wrong - use 'func' not 'fn'
```

**‚úÖ CORRECT - Use constructors directly:**
```ailang
Some(42)             // ‚úÖ Correct - no namespace needed
None                 // ‚úÖ Correct
```

## Available Imports

**std/io** - IO operations (requires `! {IO}` effect)
```ailang
import std/io (println, print, readLine)

export func main() -> () ! {IO} {
  println("text")
}
```

**std/fs** - File operations (requires `! {FS}` effect)
```ailang
import std/fs (readFile, writeFile, exists)

export func readData() -> string ! {FS} {
  readFile("data.txt")
}
```

**std/clock** - Time operations (requires `! {Clock}` effect)
```ailang
import std/clock (now, sleep)

export func measureTime() -> () ! {IO, Clock} {
  let start = now();
  sleep(1000);  -- Sleep for 1 second (milliseconds)
  let end = now();
  println("Elapsed: " ++ show(end - start) ++ "ms")
}
```

**std/json** - JSON encoding (NEW v0.3.9)
```ailang
import std/json (encode, jo, ja, kv, js, jnum, jb, jn)

export func buildJSON() -> string ! {} {
  let obj = jo([
    kv("name", js("Alice")),
    kv("age", jnum(30.0)),
    kv("active", jb(true)),
    kv("hobbies", ja([js("reading"), js("coding")]))
  ]);
  encode(obj)  -- Returns: {"name":"Alice","age":30,"active":true,"hobbies":["reading","coding"]}
}
```

**std/net** - HTTP operations (requires `! {Net}` effect)
```ailang
import std/net (httpGet, httpPost)

export func fetchData() -> () ! {IO, Net} {
  let response = httpGet("https://api.example.com/data");
  println(response)
}
```

**std/net (Advanced)** - HTTP with headers (NEW v0.3.9)
```ailang
import std/net (httpRequest, NetError, Transport, InvalidHeader)
import std/json (encode, jo, kv, js)

export func callAPI(apiKey: string) -> () ! {IO, Net} {
  let headers = [
    {name: "Authorization", value: concat_String("Bearer ", apiKey)},
    {name: "Content-Type", value: "application/json"}
  ];
  let body = encode(jo([kv("message", js("Hello"))]));

  match httpRequest("POST", "https://api.example.com/endpoint", headers, body) {
    Ok(resp) =>
      if resp.ok then println(resp.body)
      else println(concat_String("HTTP error: ", show(resp.status)))
    Err(err) => match err {
      Transport(msg) => println(concat_String("Network error: ", msg))
      InvalidHeader(hdr) => println(concat_String("Invalid header: ", hdr))
      -- DisallowedHost, BodyTooLarge also available
    }
  }
}
```

**IMPORTANT:**
- `show` is a BUILTIN function - do NOT import it from std/io!
- Clock and Net have security restrictions (no localhost, private IPs, file:// URLs blocked)
- Run with capabilities: `ailang run --caps IO,FS,Clock,Net --entry main file.ail`

**std/option** - Option type
```ailang
import std/option (Option, Some, None)
```

## Recursion (instead of loops)

Recursion works perfectly in v0.3.8:

```ailang
export func factorial(n: int) -> int {
  if n <= 1
  then 1
  else n * factorial(n - 1)
}

-- Recursion with IO effects and blocks
export func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}
```

## Recursion Limitation in REPL

**IMPORTANT:** Recursive lambdas are NOT supported in let-bindings:

```ailang
-- ‚ùå DOES NOT WORK - let bindings cannot be recursive
let fib = \n. if n < 2 then n else fib(n - 1) + fib(n - 2) in fib(10)
-- Error: undefined variable: fib
```

**‚úÖ WORKAROUND:** Use `func` declarations in module files instead:

```ailang
-- In a .ail file:
module examples/fib
export func fib(n: int) -> int {
  if n < 2 then n else fib(n - 1) + fib(n - 2)
}
```

**Why:** Module-level `func` declarations are automatically recursive. The `letrec` keyword does not exist in AILANG's surface syntax.

## Common Mistakes to Avoid

‚ùå **Don't use for/while loops:**
```ailang
for i in [1, 2, 3] { println(i) }  -- ‚ùå NOT supported
```

‚úÖ **Use recursion:**
```ailang
export func printAll(xs: [int]) -> () ! {IO} {
  match xs {
    [] => (),
    _ => {
      println(show(head(xs)));
      printAll(tail(xs))
    }
  }
}
```

‚ùå **Don't forget semicolons in blocks:**
```ailang
{
  println("First")
  println("Second")  -- ‚ùå Parse error! Missing semicolon
}
```

‚úÖ **Add semicolons between statements:**
```ailang
{
  println("First");
  println("Second")  -- ‚úÖ Last statement doesn't need semicolon
}
```

‚ùå **Don't import show:**
```ailang
import std/io (println, show)  -- ‚ùå show not in std/io
```

‚úÖ **show is a builtin:**
```ailang
import std/io (println)
-- show is available automatically
println(show(42))
```

‚ùå **Don't forget module and export:**
```ailang
func main() {  -- ‚ùå Missing 'module' declaration and 'export'
  println("hello")
}
```

‚úÖ **Always use module and export:**
```ailang
module benchmark/solution
import std/io (println)

export func main() -> () ! {IO} {
  println("hello")
}
```

## Complete Working Examples

### Example 1: Safe Division with Option
```ailang
module benchmark/solution

import std/io (println)

type Option[a] = Some(a) | None

export func safeDivide(a: float, b: float) -> Option[float] {
  if b == 0.0
  then None
  else Some(a / b)
}

export func printResult(result: Option[float]) -> () ! {IO} {
  match result {
    Some(v) => println("Result: " ++ show(v)),
    None => println("Error: Division by zero")
  }
}

export func main() -> () ! {IO} {
  let r1 = safeDivide(10.0, 2.0);
  printResult(r1);
  let r2 = safeDivide(10.0, 0.0);
  printResult(r2)
}
```

### Example 2: Countdown with Recursion and Blocks
```ailang
module benchmark/solution

import std/io (println)

export func countdown(n: int) -> () ! {IO} {
  if n <= 0 then {
    println("Done!")
  } else {
    println(show(n));
    countdown(n - 1)
  }
}

export func main() -> () ! {IO} {
  countdown(5)
}
```

### Example 3: Records with Update Syntax
```ailang
module benchmark/solution

import std/io (println)

export func main() -> () ! {IO} {
  let alice = {name: "Alice", age: 30, city: "NYC"};

  -- Update age (NEW in v0.3.6!)
  let older = {alice | age: 31};

  -- Update city
  let moved = {older | city: "SF"};

  println(moved.name ++ ", " ++ show(moved.age) ++ ", " ++ moved.city)
}
```

## Summary

**Structure:**
1. Start with `module benchmark/solution` (REQUIRED for benchmarks!)
2. Import what you need from stdlib (`import std/io (println)`)
3. Define exported functions with `export func name(params) -> ReturnType { }`
4. Declare effects with `! {IO, FS}` when using IO/FS operations
5. Use recursion instead of loops - AILANG has NO for/while loops!
6. Use semicolons between statements in blocks

**Remember:**
- ‚úÖ Use `func` NOT `fn`, `function`, or `def`
- ‚úÖ ADTs use `type Name[a] = Cons1(a) | Cons2` syntax (multi-line optional)
- ‚úÖ NO `::` operator - use constructors directly
- ‚úÖ NO for/while loops - use recursion
- ‚úÖ Everything is immutable (no `var` or mutation)
- ‚úÖ Pattern matching uses `=>` arrows, guards work (`if` conditions)
- ‚úÖ Semicolons REQUIRED between statements in blocks
- ‚úÖ `show` is builtin - do NOT import it
- ‚úÖ Records: literals, field access, AND update syntax `{r | field: val}`
- ‚úÖ Effects must be declared: `! {IO}`, `! {FS}`, `! {Clock}`, `! {Net}`, or combinations
- ‚úÖ Modulo operator `%` works: `5 % 3` returns `2`
- ‚úÖ Float comparison works: `0.0 == 0.0` returns `true`
- ‚úÖ std/prelude AUTO-IMPORTED: No need to import Ord/Eq for comparisons!
- ‚úÖ Four effects available: IO (console), FS (files), Clock (time), Net (HTTP)

**If you're not sure, look at the examples above!** They show the exact AILANG syntax.

**v0.3.8 Release Notes (October 2025):**
- **Multi-line ADTs**: Optional leading pipe `type Tree = | Leaf | Node` for better readability
- **Operator lowering fix**: Division operators now resolve correctly (fixes runtime errors)
- **Benchmark improvements**: 49.1% success rate (up from 38.6% in v0.3.7) - +10.5% improvement!
- **Test coverage**: 28.9% (improving steadily)
- All previous features: auto-import std/prelude, record updates, Clock/Net effects, numeric conversions

---

# Examples Status

## Example Status

### Working Examples ‚úÖ
- `adt_option.ail`
- `adt_simple.ail`
- `ai_call.ail` ‚Üê ‚ú® NEW (v0.3.9) - OpenAI API integration
- `arithmetic.ail`
- `block_recursion.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha2)
- `claude_haiku_call.ail` ‚Üê ‚ú® NEW (v0.3.9) - Anthropic API integration
- `demos/adt_pipeline.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `demos/hello_io.ail`
- `effects_basic.ail`
- `effects_pure.ail`
- `guards_basic.ail`
- `hello.ail`
- `micro_block_if.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha2)
- `micro_block_seq.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha2)
- `micro_io_echo.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `micro_option_map.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `micro_record_person.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha3 M-R5 Day 3)
- `recursion_error.ail`
- `recursion_factorial.ail`
- `recursion_fibonacci.ail`
- `recursion_mutual.ail`
- `recursion_quicksort.ail`
- `showcase/01_type_inference.ail`
- `showcase/02_lambdas.ail`
- `showcase/03_type_classes.ail`
- `showcase/04_closures.ail`
- `simple.ail`
- `test_effect_annotation.ail`
- `test_effect_capability.ail`
- `test_effect_fs.ail`
- `test_effect_io.ail`
- `test_exhaustive_bool_complete.ail`
- `test_exhaustive_bool_incomplete.ail`
- `test_exhaustive_wildcard.ail`
- `test_guard_bool.ail`
- `test_guard_debug.ail`
- `test_guard_false.ail`
- `test_import_ctor.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `test_import_func.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `test_invocation.ail`
- `test_io_builtins.ail`
- `test_module_minimal.ail`
- `test_no_import.ail`
- `test_record_subsumption.ail` ‚Üê ‚ú® NEW (v0.3.0-alpha3 M-R5 Day 3)
- `test_single_guard.ail`
- `test_use_constructor.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `test_with_import.ail`
- `type_classes_working_reference.ail`
- `v3_3/imports.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)
- `v3_3/imports_basic.ail` ‚Üê ‚úÖ FIXED (M-R5 Day 1)

### Failing Examples ‚ùå
- `demos/effects_pure.ail`
- `experimental/ai_agent_integration.ail`
- `experimental/concurrent_pipeline.ail`
- `experimental/factorial.ail`
- `experimental/quicksort.ail`
- `experimental/web_api.ail`
- `lambda_expressions.ail`
- `list_patterns.ail`
- `patterns.ail`
- `records.ail`
- `showcase/03_lists.ail`
- `test_effect_io_simple.ail`
- `typeclasses.ail`
- `v3_3/math/gcd.ail`

### Skipped Examples ‚è≠Ô∏è
- `block_demo.ail`
- `option_demo.ail`
- `stdlib_demo.ail`
- `stdlib_demo_simple.ail`

**Summary:** 50 passed, 14 failed, 4 skipped (Total: 68)

**Recent improvements:**
- ‚úÖ **v0.3.9 (Oct 2025)**: 2 new AI API integration examples!
  - `ai_call.ail`: OpenAI GPT-4o-mini integration with JSON encoding
  - `claude_haiku_call.ail`: Anthropic Claude Haiku integration (verified with real API)
- ‚úÖ **M-R5 (v0.3.0-alpha3)**: 11 examples fixed/added via records & row polymorphism!
  - Day 1: 9 examples fixed (demos/adt_pipeline, micro_io_echo, micro_option_map, test_import_ctor, test_import_func, test_use_constructor, v3_3/imports, v3_3/imports_basic)
  - Day 3: 2 new examples (micro_record_person, test_record_subsumption)
- ‚úÖ **M-R8 (v0.3.0-alpha2)**: `micro_block_*.ail`, `block_recursion.ail` (3 files) - Block expressions with recursion
- ‚úÖ **M-R4 (v0.3.0-alpha1)**: `recursion_*.ail` (5 files) - Recursion support with RefCell indirection

---

