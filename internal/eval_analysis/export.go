package eval_analysis

import (
	"encoding/csv"
	"fmt"
	"html/template"
	"sort"
	"strings"
	"time"
)

// ExportFormat represents the output format for reports
type ExportFormat string

const (
	FormatMarkdown ExportFormat = "markdown"
	FormatHTML     ExportFormat = "html"
	FormatCSV      ExportFormat = "csv"
)

// GenerateReport creates a comprehensive evaluation report
func GenerateReport(matrix *PerformanceMatrix, history []*Baseline) string {
	return ExportMarkdown(matrix, history)
}

// ExportMarkdown generates a GitHub-flavored markdown report
func ExportMarkdown(matrix *PerformanceMatrix, history []*Baseline) string {
	var sb strings.Builder

	// Title
	sb.WriteString(fmt.Sprintf("# Evaluation Report: %s\n\n", matrix.Version))
	sb.WriteString(fmt.Sprintf("**Generated**: %s\n\n", time.Now().Format("2006-01-02 15:04:05")))

	// Executive Summary
	sb.WriteString("## Executive Summary\n\n")
	sb.WriteString(fmt.Sprintf("- **Total Runs**: %d\n", matrix.TotalRuns))
	sb.WriteString(fmt.Sprintf("- **0-Shot Success**: %.1f%%\n", matrix.Aggregates.ZeroShotSuccess*100))
	sb.WriteString(fmt.Sprintf("- **Final Success** (with repair): %.1f%%\n", matrix.Aggregates.FinalSuccess*100))
	sb.WriteString(fmt.Sprintf("- **Repairs Used**: %d (%.1f%% success rate)\n",
		matrix.Aggregates.RepairUsed,
		matrix.Aggregates.RepairSuccessRate*100))
	sb.WriteString(fmt.Sprintf("- **Total Cost**: $%.4f\n", matrix.Aggregates.TotalCostUSD))
	sb.WriteString(fmt.Sprintf("- **Avg Duration**: %.0fms\n\n", matrix.Aggregates.AvgDurationMs))

	// Model Comparison
	if len(matrix.Models) > 0 {
		sb.WriteString("## Model Performance\n\n")
		sb.WriteString("| Model | Runs | 0-Shot | Final | Avg Tokens | Avg Cost |\n")
		sb.WriteString("|-------|------|--------|-------|------------|----------|\n")

		// Sort models by final success rate
		type modelEntry struct {
			name  string
			stats *ModelStats
		}
		var models []modelEntry
		for name, stats := range matrix.Models {
			models = append(models, modelEntry{name, stats})
		}
		sort.Slice(models, func(i, j int) bool {
			return models[i].stats.Aggregates.FinalSuccess > models[j].stats.Aggregates.FinalSuccess
		})

		for _, m := range models {
			sb.WriteString(fmt.Sprintf("| %s | %d | %.1f%% | %.1f%% | %.0f | $%.4f |\n",
				m.name,
				m.stats.TotalRuns,
				m.stats.Aggregates.ZeroShotSuccess*100,
				m.stats.Aggregates.FinalSuccess*100,
				float64(m.stats.Aggregates.TotalTokens)/float64(m.stats.TotalRuns),
				m.stats.Aggregates.TotalCostUSD/float64(m.stats.TotalRuns)))
		}
		sb.WriteString("\n")
	}

	// Benchmark Success Rates
	if len(matrix.Benchmarks) > 0 {
		sb.WriteString("## Benchmark Performance\n\n")
		sb.WriteString("| Benchmark | Success Rate | Avg Tokens | Languages |\n")
		sb.WriteString("|-----------|--------------|------------|----------|\n")

		// Sort benchmarks by success rate
		type benchEntry struct {
			id    string
			stats *BenchmarkStats
		}
		var benchmarks []benchEntry
		for id, stats := range matrix.Benchmarks {
			benchmarks = append(benchmarks, benchEntry{id, stats})
		}
		sort.Slice(benchmarks, func(i, j int) bool {
			return benchmarks[i].stats.SuccessRate > benchmarks[j].stats.SuccessRate
		})

		for _, b := range benchmarks {
			sb.WriteString(fmt.Sprintf("| %s | %.1f%% | %.0f | %s |\n",
				b.id,
				b.stats.SuccessRate*100,
				b.stats.AvgTokens,
				strings.Join(b.stats.Languages, ", ")))
		}
		sb.WriteString("\n")
	}

	// Error Code Distribution
	if len(matrix.ErrorCodes) > 0 {
		sb.WriteString("## Error Analysis\n\n")
		sb.WriteString("| Error Code | Count | Repair Success Rate |\n")
		sb.WriteString("|------------|-------|--------------------|\n")

		for _, ec := range matrix.ErrorCodes {
			sb.WriteString(fmt.Sprintf("| %s | %d | %.1f%% |\n",
				ec.Code,
				ec.Count,
				ec.RepairSuccess*100))
		}
		sb.WriteString("\n")
	}

	// Trend Analysis
	if len(history) > 1 {
		sb.WriteString("## Trend Analysis\n\n")
		sb.WriteString("| Version | Success Rate | Change |\n")
		sb.WriteString("|---------|--------------|--------|\n")

		for i, baseline := range history {
			successRate := float64(baseline.SuccessCount) / float64(baseline.TotalBenchmarks) * 100
			change := ""
			if i > 0 {
				prevRate := float64(history[i-1].SuccessCount) / float64(history[i-1].TotalBenchmarks) * 100
				delta := successRate - prevRate
				if delta > 0 {
					change = fmt.Sprintf("+%.1f%%", delta)
				} else if delta < 0 {
					change = fmt.Sprintf("%.1f%%", delta)
				} else {
					change = "0.0%"
				}
			}
			sb.WriteString(fmt.Sprintf("| %s | %.1f%% | %s |\n",
				baseline.Version,
				successRate,
				change))
		}
		sb.WriteString("\n")
	}

	// Footer
	sb.WriteString("---\n\n")
	sb.WriteString("*Generated by AILANG M-EVAL-LOOP*\n")

	return sb.String()
}

// ExportHTML generates an HTML report with Bootstrap styling
func ExportHTML(matrix *PerformanceMatrix, history []*Baseline) (string, error) {
	tmpl := `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evaluation Report: {{.Matrix.Version}}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { padding: 20px; }
        .metric-card { margin-bottom: 20px; }
        .success-high { color: #28a745; font-weight: bold; }
        .success-medium { color: #ffc107; font-weight: bold; }
        .success-low { color: #dc3545; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Evaluation Report: {{.Matrix.Version}}</h1>
        <p class="text-muted">Generated: {{.Timestamp}}</p>

        <div class="row">
            <div class="col-md-3 metric-card">
                <div class="card">
                    <div class="card-body text-center">
                        <h5 class="card-title">Total Runs</h5>
                        <h2>{{.Matrix.TotalRuns}}</h2>
                    </div>
                </div>
            </div>
            <div class="col-md-3 metric-card">
                <div class="card">
                    <div class="card-body text-center">
                        <h5 class="card-title">0-Shot Success</h5>
                        <h2 class="{{successClass .Matrix.Aggregates.ZeroShotSuccess}}">{{printf "%.1f%%" (mult .Matrix.Aggregates.ZeroShotSuccess 100)}}</h2>
                    </div>
                </div>
            </div>
            <div class="col-md-3 metric-card">
                <div class="card">
                    <div class="card-body text-center">
                        <h5 class="card-title">Final Success</h5>
                        <h2 class="{{successClass .Matrix.Aggregates.FinalSuccess}}">{{printf "%.1f%%" (mult .Matrix.Aggregates.FinalSuccess 100)}}</h2>
                    </div>
                </div>
            </div>
            <div class="col-md-3 metric-card">
                <div class="card">
                    <div class="card-body text-center">
                        <h5 class="card-title">Total Cost</h5>
                        <h2>${{printf "%.4f" .Matrix.Aggregates.TotalCostUSD}}</h2>
                    </div>
                </div>
            </div>
        </div>

        <h2 class="mt-5">Model Performance</h2>
        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Model</th>
                    <th>Runs</th>
                    <th>0-Shot</th>
                    <th>Final</th>
                    <th>Avg Tokens</th>
                </tr>
            </thead>
            <tbody>
                {{range .Models}}
                <tr>
                    <td>{{.Name}}</td>
                    <td>{{.Stats.TotalRuns}}</td>
                    <td>{{printf "%.1f%%" (mult .Stats.Aggregates.ZeroShotSuccess 100)}}</td>
                    <td>{{printf "%.1f%%" (mult .Stats.Aggregates.FinalSuccess 100)}}</td>
                    <td>{{printf "%.0f" (div .Stats.Aggregates.TotalTokens .Stats.TotalRuns)}}</td>
                </tr>
                {{end}}
            </tbody>
        </table>

        <footer class="mt-5 text-center text-muted">
            <p>Generated by AILANG M-EVAL-LOOP</p>
        </footer>
    </div>
</body>
</html>`

	// Prepare template data
	type modelData struct {
		Name  string
		Stats *ModelStats
	}
	var models []modelData
	for name, stats := range matrix.Models {
		models = append(models, modelData{name, stats})
	}

	funcMap := template.FuncMap{
		"mult": func(a, b float64) float64 { return a * b },
		"div":  func(a, b int) float64 { return float64(a) / float64(b) },
		"successClass": func(rate float64) string {
			if rate >= 0.8 {
				return "success-high"
			} else if rate >= 0.5 {
				return "success-medium"
			}
			return "success-low"
		},
	}

	t, err := template.New("report").Funcs(funcMap).Parse(tmpl)
	if err != nil {
		return "", err
	}

	var sb strings.Builder
	data := struct {
		Matrix    *PerformanceMatrix
		Models    []modelData
		Timestamp string
	}{
		Matrix:    matrix,
		Models:    models,
		Timestamp: time.Now().Format("2006-01-02 15:04:05"),
	}

	if err := t.Execute(&sb, data); err != nil {
		return "", err
	}

	return sb.String(), nil
}

// ExportCSV generates a CSV export of benchmark results
func ExportCSV(results []*BenchmarkResult) (string, error) {
	var sb strings.Builder
	w := csv.NewWriter(&sb)

	// Write header
	header := []string{
		"id", "lang", "model", "seed",
		"first_attempt_ok", "repair_used", "repair_ok",
		"compile_ok", "runtime_ok", "stdout_ok",
		"error_category", "err_code",
		"input_tokens", "output_tokens", "total_tokens",
		"cost_usd", "duration_ms",
		"timestamp",
	}
	if err := w.Write(header); err != nil {
		return "", err
	}

	// Write rows
	for _, r := range results {
		row := []string{
			r.ID, r.Lang, r.Model, fmt.Sprintf("%d", r.Seed),
			fmt.Sprintf("%t", r.FirstAttemptOk),
			fmt.Sprintf("%t", r.RepairUsed),
			fmt.Sprintf("%t", r.RepairOk),
			fmt.Sprintf("%t", r.CompileOk),
			fmt.Sprintf("%t", r.RuntimeOk),
			fmt.Sprintf("%t", r.StdoutOk),
			r.ErrorCategory, r.ErrCode,
			fmt.Sprintf("%d", r.InputTokens),
			fmt.Sprintf("%d", r.OutputTokens),
			fmt.Sprintf("%d", r.TotalTokens),
			fmt.Sprintf("%.4f", r.CostUSD),
			fmt.Sprintf("%d", r.DurationMs),
			r.Timestamp.Format(time.RFC3339),
		}
		if err := w.Write(row); err != nil {
			return "", err
		}
	}

	w.Flush()
	if err := w.Error(); err != nil {
		return "", err
	}

	return sb.String(), nil
}
